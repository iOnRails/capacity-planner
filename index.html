<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Capacity Planner</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #232733;
    --border: #2e3345;
    --text: #e2e4eb;
    --text2: #8b90a0;
    --accent: #6c5ce7;
    --accent2: #a29bfe;
    --green: #00b894;
    --yellow: #fdcb6e;
    --red: #e17055;
    --orange: #e67e22;
    --blue: #0984e3;
    --pink: #e84393;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* â”€â”€ Header â”€â”€ */
  .app-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 28px; background: var(--surface);
    border-bottom: 1px solid var(--border);
    position: sticky; top: 0; z-index: 100;
  }
  .app-header h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.3px; }
  .app-header h1 span { color: var(--accent2); }
  .header-right { display: flex; gap: 12px; align-items: center; }

  /* â”€â”€ Vertical Selector â”€â”€ */
  .vertical-selector { display: flex; align-items: center; gap: 8px; }
  .vertical-selector label {
    font-size: 11px; color: var(--text2); text-transform: uppercase;
    letter-spacing: 0.8px; font-weight: 600;
  }
  .vertical-select {
    padding: 7px 32px 7px 14px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    color: var(--text); font-size: 14px; font-weight: 700;
    outline: none; cursor: pointer; appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b90a0'%3E%3Cpath d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 10px center;
    transition: border-color 0.15s;
  }
  .vertical-select:hover, .vertical-select:focus { border-color: var(--accent); }

  /* â”€â”€ Config Panel â”€â”€ */
  .config-bar {
    background: var(--surface); border-bottom: 1px solid var(--border);
    padding: 14px 28px; display: flex; gap: 28px; align-items: flex-end; flex-wrap: wrap;
  }
  .config-section h3 {
    font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
    color: var(--text2); margin-bottom: 6px; font-weight: 600;
  }
  .config-inputs { display: flex; gap: 10px; flex-wrap: wrap; }
  .config-field { display: flex; flex-direction: column; gap: 3px; }
  .config-field label { font-size: 10px; color: var(--text2); font-weight: 500; }
  .config-field input {
    width: 64px; padding: 5px 8px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 6px;
    color: var(--text); font-size: 13px; font-weight: 600;
    text-align: center; outline: none;
  }
  .config-field input:focus { border-color: var(--accent); }
  .size-mapping { display: flex; gap: 5px; align-items: center; }
  .size-chip { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .size-chip span { font-size: 9px; color: var(--text2); font-weight: 600; }
  .size-chip input {
    width: 40px; padding: 3px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; text-align: center; outline: none;
  }
  .size-chip input:focus { border-color: var(--accent); }

  /* â”€â”€ Capacity Bars â”€â”€ */
  .capacity-overview {
    padding: 14px 28px; display: flex; gap: 14px; flex-wrap: wrap;
    background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .cap-bar-container { flex: 1; min-width: 160px; }
  .cap-bar-label {
    display: flex; justify-content: space-between;
    font-size: 11px; margin-bottom: 3px; font-weight: 500;
  }
  .cap-bar-track {
    height: 18px; background: var(--bg); border-radius: 5px;
    overflow: hidden; border: 1px solid var(--border);
  }
  .cap-bar-fill {
    height: 100%; border-radius: 4px; transition: width 0.4s ease, background 0.3s;
    display: flex; align-items: center; justify-content: flex-end;
    padding-right: 5px; font-size: 9px; font-weight: 700;
    color: rgba(255,255,255,0.9);
  }
  .cap-total {
    flex: 1; min-width: 160px; background: var(--surface2);
    border-radius: 8px; padding: 6px 12px; border: 1px solid var(--border);
  }
  .cap-total .cap-bar-label { font-weight: 700; font-size: 12px; }

  /* â”€â”€ Track Capacity Allocation â”€â”€ */
  .track-alloc-section {
    padding: 14px 28px; background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .track-alloc-section h3 { font-size: 12px; margin: 0 0 10px 0; color: var(--text); }
  .track-alloc-grid {
    display: grid; grid-template-columns: 120px repeat(4, 1fr) auto; gap: 6px 10px; align-items: center;
  }
  .track-alloc-header { font-size: 10px; text-transform: uppercase; color: var(--muted); font-weight: 600; letter-spacing: 0.5px; }
  .track-alloc-label { font-size: 12px; font-weight: 600; color: var(--text); }
  .track-alloc-input {
    width: 100%; padding: 4px 6px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px; text-align: center; outline: none;
  }
  .track-alloc-input:focus { border-color: var(--accent); }
  .track-alloc-input.over-cap { border-color: #e17055; background: rgba(225,112,85,0.1); }
  .track-alloc-remaining { font-size: 11px; text-align: center; }
  .track-alloc-remaining.ok { color: #00b894; }
  .track-alloc-remaining.warn { color: #fdcb6e; }
  .track-alloc-remaining.over { color: #e17055; font-weight: 700; }
  .track-cap-bar { margin-top: 2px; height: 4px; background: var(--bg); border-radius: 2px; overflow: hidden; }
  .track-cap-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }

  /* â”€â”€ Total Demand â”€â”€ */
  .demand-section {
    padding: 14px 28px; display: flex; gap: 16px; flex-wrap: wrap;
    background: var(--surface); border-bottom: 1px solid var(--border); align-items: stretch;
  }
  .demand-card {
    flex: 1; min-width: 150px; background: var(--surface2); border-radius: 8px;
    padding: 10px 14px; border: 1px solid var(--border); display: flex; flex-direction: column; gap: 6px;
  }
  .demand-card-title { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); font-weight: 600; }
  .demand-card-value { font-size: 20px; font-weight: 700; color: var(--text); }
  .demand-card-buffered { font-size: 11px; color: var(--accent); font-weight: 500; }
  .demand-buffer-row { display: flex; align-items: center; gap: 6px; margin-top: 2px; }
  .demand-buffer-btn {
    width: 22px; height: 22px; border-radius: 4px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text); font-size: 13px; font-weight: 700;
    cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s;
    padding: 0; line-height: 1;
  }
  .demand-buffer-btn:hover { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .demand-buffer-pct { font-size: 11px; color: var(--muted); min-width: 36px; text-align: center; }

  /* â”€â”€ Filters â”€â”€ */
  .filters-bar {
    padding: 10px 28px; display: flex; gap: 8px; flex-wrap: wrap;
    align-items: center; background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .filter-group { position: relative; }
  .filter-btn {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; cursor: pointer;
    display: flex; align-items: center; gap: 5px; transition: all 0.15s;
  }
  .filter-btn:hover { border-color: var(--accent); }
  .filter-btn.active { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .filter-btn .count {
    background: var(--accent); color: white; font-size: 9px;
    padding: 1px 5px; border-radius: 10px; font-weight: 700;
  }
  .filter-dropdown {
    position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; padding: 6px; z-index: 50; min-width: 150px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
  }
  .filter-dropdown.open { display: block; }
  .filter-option {
    display: flex; align-items: center; gap: 6px; padding: 5px 8px;
    border-radius: 4px; cursor: pointer; font-size: 11px;
  }
  .filter-option:hover { background: rgba(255,255,255,0.05); }
  .filter-option input[type="checkbox"] { accent-color: var(--accent); }
  .search-input {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; outline: none; width: 200px;
  }
  .search-input:focus { border-color: var(--accent); }
  .search-input::placeholder { color: var(--text2); }
  .sort-controls { display: flex; gap: 5px; align-items: center; }
  .sort-controls select {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none; cursor: pointer;
  }

  /* â”€â”€ Btn â”€â”€ */
  .btn {
    padding: 5px 14px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn:hover { border-color: var(--accent); }
  .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-primary:hover { background: var(--accent2); }

  /* â”€â”€ Lane (horizontal) â”€â”€ */
  .lane-section { padding: 0 28px 8px; }
  .lane-header-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 28px 10px; margin: 0 -28px;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .lane-header-row h2 {
    font-size: 14px; font-weight: 700; display: flex; align-items: center; gap: 8px;
  }
  .badge {
    font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 700;
  }
  .roadmap-badge { background: rgba(0,184,148,0.2); color: var(--green); }
  .backlog-badge { background: rgba(139,144,160,0.2); color: var(--text2); }
  .lane-stats {
    display: flex; gap: 8px; align-items: center;
  }
  .stat-chip {
    font-size: 10px; padding: 3px 8px; background: var(--surface);
    border-radius: 6px; color: var(--text2); font-weight: 500;
  }
  .stat-chip strong { color: var(--text); }

  /* â”€â”€ Flow Container â”€â”€ */
  .flow-container {
    display: flex; flex-wrap: wrap; gap: 6px; padding: 10px;
    min-height: 80px; border-radius: 10px;
    background: var(--surface); border: 1px solid var(--border);
    transition: all 0.2s;
    margin-top: 10px;
  }
  .flow-container.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
    box-shadow: inset 0 0 20px rgba(108,92,231,0.08);
  }
  .flow-container.roadmap-flow { border-color: rgba(0,184,148,0.25); }
  .empty-flow {
    width: 100%; display: flex; align-items: center; justify-content: center;
    min-height: 70px; color: var(--text2); font-size: 12px;
    border: 2px dashed var(--border); border-radius: 8px;
  }

  /* â”€â”€ Track (sub-lane within roadmap) â”€â”€ */
  .track-group { margin-top: 10px; }
  .track-row {
    display: flex; align-items: stretch; gap: 0;
  }
  .track-label {
    writing-mode: vertical-lr; text-orientation: mixed;
    transform: rotate(180deg);
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; font-weight: 700; letter-spacing: 0.5px;
    padding: 8px 6px; border-radius: 10px 0 0 10px;
    min-width: 32px; text-align: center; white-space: nowrap;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .track-flow {
    display: flex; flex-wrap: wrap; gap: 6px; padding: 10px;
    min-height: 60px; border-radius: 0 10px 10px 0;
    background: var(--surface); border: 1px solid var(--border);
    border-left: none; flex: 1; transition: all 0.2s;
    align-content: flex-start;
  }
  .track-flow.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
  }
  .track-divider {
    height: 1px; background: var(--border); margin: 0 0 0 32px; opacity: 0.5;
  }
  .track-empty {
    display: flex; align-items: center; justify-content: center;
    width: 100%; min-height: 40px; color: var(--text2); font-size: 11px;
    border: 1px dashed var(--border); border-radius: 6px;
    font-style: italic;
  }

  /* â”€â”€ Project Block (proportional) â”€â”€ */
  .project-block {
    position: relative; border-radius: 8px; cursor: grab;
    transition: all 0.15s; user-select: none; overflow: hidden;
    display: flex; flex-direction: column; justify-content: space-between;
    border: 1px solid transparent;
  }
  .project-block:hover {
    border-color: rgba(255,255,255,0.3);
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    transform: translateY(-2px);
    z-index: 5;
  }
  .project-block.dragging { opacity: 0.3; transform: scale(0.95); }
  .project-block.in-progress { box-shadow: inset 0 0 0 2px var(--green); }

  /* â”€â”€ Overflow indicator â”€â”€ */
  .project-block.overflow-block {
    border: 2px solid #ff4444 !important;
    box-shadow: 0 0 12px rgba(255,68,68,0.5), inset 0 0 0 1px rgba(255,68,68,0.3);
    animation: overflow-pulse 1.5s ease-in-out infinite alternate;
  }
  @keyframes overflow-pulse {
    from { box-shadow: 0 0 8px rgba(255,68,68,0.4), inset 0 0 0 1px rgba(255,68,68,0.2); }
    to { box-shadow: 0 0 16px rgba(255,68,68,0.7), inset 0 0 0 1px rgba(255,68,68,0.4); }
  }
  .overflow-badge {
    position: absolute; top: 3px; left: 3px; z-index: 10;
    background: #ff4444; color: white; font-size: 8px; font-weight: 800;
    padding: 2px 5px; border-radius: 3px; letter-spacing: 0.3px;
    text-shadow: 0 1px 1px rgba(0,0,0,0.3); line-height: 1.2;
    pointer-events: none;
  }

  .block-content {
    padding: 8px 10px; display: flex; flex-direction: column;
    height: 100%; overflow: hidden;
  }
  .block-title {
    font-size: 11px; font-weight: 600; line-height: 1.25;
    overflow: hidden; text-overflow: ellipsis;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .block-bottom {
    display: flex; justify-content: space-between; align-items: flex-end;
    margin-top: auto; padding-top: 4px;
  }
  .block-jira {
    font-size: 9px; color: rgba(255,255,255,0.7); font-weight: 600;
  }
  .block-sprints {
    font-size: 10px; font-weight: 800; color: white;
    background: rgba(0,0,0,0.3); padding: 1px 6px; border-radius: 4px;
  }
  .block-pillar-line {
    height: 3px; width: 100%; opacity: 0.8;
  }

  /* â”€â”€ Ghost block (split allocation) â”€â”€ */
  .project-block.ghost-block {
    border: 2px dashed rgba(162,155,254,0.6) !important;
    opacity: 0.75;
    background: repeating-linear-gradient(
      -45deg, transparent, transparent 4px, rgba(0,0,0,0.08) 4px, rgba(0,0,0,0.08) 8px
    ) !important;
  }
  .project-block.ghost-block:hover { opacity: 0.9; }
  .ghost-origin {
    position: absolute; bottom: 3px; left: 6px; font-size: 8px; font-weight: 700;
    color: rgba(162,155,254,0.9); pointer-events: none; letter-spacing: 0.3px;
  }
  .ghost-link-icon {
    position: absolute; top: 3px; left: 3px; font-size: 10px; z-index: 10;
    pointer-events: none;
  }

  /* â”€â”€ Split button on block â”€â”€ */
  .block-split {
    position: absolute; top: 4px; right: 26px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-split { opacity: 1; }
  .block-split:hover { background: var(--accent); }

  /* â”€â”€ Split modal â”€â”€ */
  .split-modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    z-index: 300; display: flex; align-items: center; justify-content: center;
  }
  .split-modal {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 12px; padding: 20px; min-width: 340px;
    box-shadow: 0 16px 48px rgba(0,0,0,0.5);
  }
  .split-modal h3 { font-size: 14px; margin-bottom: 12px; }
  .split-modal-fields { display: flex; flex-direction: column; gap: 8px; margin-bottom: 14px; }
  .split-field-row { display: flex; align-items: center; gap: 10px; }
  .split-field-row label { width: 70px; font-size: 12px; font-weight: 500; }
  .split-field-row select, .split-field-row input {
    flex: 1; padding: 6px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px;
  }
  .split-modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
  .split-modal-actions button {
    padding: 6px 16px; border-radius: 6px; border: 1px solid var(--border);
    font-size: 12px; cursor: pointer; transition: all 0.15s;
  }
  .split-modal-actions .btn-save { background: var(--accent); color: white; border-color: var(--accent); }
  .split-modal-actions .btn-save:hover { opacity: 0.8; }
  .split-modal-actions .btn-cancel { background: var(--surface); color: var(--text); }
  .split-modal-actions .btn-cancel:hover { background: var(--surface2); }
  .split-modal-actions .btn-remove { background: var(--red); color: white; border-color: var(--red); }
  .split-modal-actions .btn-remove:hover { opacity: 0.8; }
  .split-existing { margin-bottom: 12px; padding: 8px; background: var(--bg); border-radius: 6px; }
  .split-existing-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; font-size: 11px;
  }

  /* â”€â”€ Move button on block â”€â”€ */
  .block-move {
    position: absolute; top: 4px; right: 4px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-move { opacity: 1; }
  .block-move:hover { background: var(--accent); }

  /* â”€â”€ Tooltip â”€â”€ */
  .tooltip-overlay {
    position: fixed; z-index: 200; pointer-events: none;
  }
  .tooltip-card {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 10px; padding: 14px 16px; width: 320px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  }
  .tooltip-card .tt-title { font-size: 13px; font-weight: 700; margin-bottom: 8px; }
  .tooltip-card .tt-meta { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 8px; }
  .tooltip-card .tt-efforts { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 6px; }
  .tooltip-card .tt-total {
    font-size: 12px; font-weight: 700; color: var(--accent2); text-align: right;
  }
  .pill {
    font-size: 10px; padding: 2px 8px; border-radius: 10px;
    font-weight: 600; white-space: nowrap;
  }
  .pill-pillar { opacity: 0.9; color: white; }
  .pill-expansion { background: #00b894; }
  .pill-acquisition { background: #0984e3; }
  .pill-core-platform { background: #6c5ce7; }
  .pill-comms { background: #e67e22; }
  .pill-gamification { background: #e84393; }
  .pill-core-bonus { background: #fdcb6e; color: #333; }
  .pill-market { background: rgba(255,255,255,0.08); color: var(--text2); }
  .pill-kpi { background: rgba(9,132,227,0.15); color: var(--blue); }
  .pill-impact { font-weight: 700; }
  .impact-XS { background: rgba(139,144,160,0.15); color: var(--text2); }
  .impact-S { background: rgba(0,184,148,0.12); color: var(--green); }
  .impact-M { background: rgba(9,132,227,0.15); color: var(--blue); }
  .impact-L { background: rgba(108,92,231,0.15); color: var(--accent2); }
  .impact-XL { background: rgba(230,126,34,0.15); color: var(--orange); }
  .impact-XXL { background: rgba(225,112,85,0.15); color: var(--red); }
  .impact-XXXL { background: rgba(225,112,85,0.25); color: var(--red); }
  .effort-tag {
    font-size: 10px; padding: 2px 6px; border-radius: 4px;
    background: rgba(255,255,255,0.06); color: var(--text2); font-weight: 500;
  }
  .effort-tag .val { font-weight: 700; color: var(--text); }

  /* â”€â”€ Empty Vertical â”€â”€ */
  .empty-vertical {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; padding: 80px 40px; text-align: center; gap: 16px;
  }
  .empty-vertical-icon {
    width: 80px; height: 80px; border-radius: 20px; background: var(--surface2);
    border: 2px dashed var(--border); display: flex; align-items: center;
    justify-content: center; font-size: 32px;
  }
  .empty-vertical h2 { font-size: 18px; font-weight: 700; }
  .empty-vertical p { font-size: 13px; color: var(--text2); max-width: 400px; line-height: 1.5; }
  .empty-vertical code {
    background: var(--surface2); padding: 2px 8px; border-radius: 4px;
    font-size: 12px; color: var(--accent2);
  }

  /* â”€â”€ Scroll â”€â”€ */
  .main-scroll { overflow-y: auto; padding-bottom: 40px; }
  .main-scroll::-webkit-scrollbar { width: 6px; }
  .main-scroll::-webkit-scrollbar-track { background: transparent; }
  .main-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* â”€â”€ Color-by legend â”€â”€ */
  .color-legend {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
  }
  .legend-item {
    display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text2);
  }
  .legend-dot {
    width: 10px; height: 10px; border-radius: 3px;
  }

  /* â”€â”€ Tab Switcher â”€â”€ */
  .tab-switcher { display: flex; gap: 4px; background: var(--bg); border-radius: 8px; padding: 3px; }
  .tab-btn {
    padding: 6px 16px; border: none; border-radius: 6px; cursor: pointer;
    font-size: 12px; font-weight: 600; transition: all 0.15s;
    background: transparent; color: var(--text2);
  }
  .tab-btn:hover { color: var(--text); }
  .tab-btn.active { background: var(--accent); color: white; }

  /* â”€â”€ Projects Table â”€â”€ */
  .projects-container {
    padding: 20px 28px; overflow-y: auto;
    max-height: calc(100vh - 70px);
  }
  .projects-toolbar {
    display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;
  }
  .projects-table {
    width: 100%; border-collapse: collapse; font-size: 12px;
  }
  .projects-table th {
    text-align: left; padding: 8px 6px; border-bottom: 2px solid var(--border);
    background: var(--surface); font-size: 10px; text-transform: uppercase;
    font-weight: 700; letter-spacing: 0.5px; color: var(--text2);
    position: sticky; top: 0; z-index: 10;
  }
  .projects-table td {
    padding: 2px 3px; border-bottom: 1px solid var(--border);
    max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .projects-table tbody tr:hover { background: var(--surface2); }
  .projects-table tbody tr.editing-row { background: rgba(108,92,231,0.08); }

  .cell-view {
    padding: 4px 6px; cursor: pointer; border-radius: 4px;
    min-height: 28px; display: flex; align-items: center;
  }
  .cell-view:hover { background: rgba(108,92,231,0.1); }
  .cell-input {
    width: 100%; padding: 4px 6px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none;
    font-family: inherit;
  }
  .cell-select {
    width: 100%; padding: 4px 4px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none; cursor: pointer;
  }
  .btn-icon {
    width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text2); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; transition: all 0.15s;
  }
  .btn-icon:hover { border-color: var(--accent); color: var(--text); }
  .btn-icon.danger:hover { border-color: var(--red); color: var(--red); background: rgba(225,112,85,0.1); }

  .project-count-badge {
    font-size: 11px; color: var(--text2); padding: 4px 10px;
    background: var(--surface); border-radius: 6px;
  }

  /* â”€â”€ Bulk Actions â”€â”€ */
  .bulk-bar {
    display: flex; gap: 10px; align-items: center; padding: 10px 16px;
    background: rgba(108,92,231,0.12); border: 1px solid var(--accent);
    border-radius: 8px; margin-bottom: 12px;
  }
  .bulk-bar .bulk-count {
    font-size: 12px; font-weight: 700; color: var(--accent2);
  }
  .bulk-bar .bulk-sep {
    width: 1px; height: 20px; background: var(--border);
  }
  .bulk-edit-group {
    display: flex; gap: 6px; align-items: center;
  }
  .bulk-edit-group select, .bulk-edit-group input {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none;
  }
  .bulk-edit-group select:focus, .bulk-edit-group input:focus { border-color: var(--accent); }
  .btn-sm {
    padding: 4px 10px; border-radius: 5px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn-sm:hover { border-color: var(--accent); }
  .btn-sm.danger { border-color: var(--red); color: var(--red); }
  .btn-sm.danger:hover { background: rgba(225,112,85,0.15); }
  .btn-sm.apply { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-sm.apply:hover { background: var(--accent2); }

  .row-checkbox {
    accent-color: var(--accent); cursor: pointer; width: 14px; height: 14px;
  }
  .projects-table th.check-col, .projects-table td.check-col {
    width: 30px; text-align: center; padding: 4px;
  }

  /* â”€â”€ Drop Indicator â”€â”€ */
  .drop-indicator {
    width: 3px; min-height: 70px; background: var(--accent);
    border-radius: 2px; flex-shrink: 0;
    box-shadow: 0 0 8px rgba(108,92,231,0.6);
    animation: pulse-indicator 0.8s ease-in-out infinite alternate;
  }
  @keyframes pulse-indicator {
    from { opacity: 0.6; }
    to { opacity: 1; }
  }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useMemo, useCallback, useRef, useEffect } = React;

const VERTICALS = [
  { key: 'growth', label: 'Growth', color: '#6c5ce7', icon: 'ðŸ“ˆ' },
  { key: 'sportsbook', label: 'Sportsbook', color: '#00b894', icon: 'âš½' },
  { key: 'casino', label: 'Casino', color: '#e84393', icon: 'ðŸŽ°' },
  { key: 'account', label: 'Account', color: '#0984e3', icon: 'ðŸ‘¤' },
  { key: 'payments', label: 'Payments', color: '#fdcb6e', icon: 'ðŸ’³' },
];

// â”€â”€ API Configuration â”€â”€
// Set this to your Railway API URL after deploying, e.g. 'https://your-app.railway.app'
const API_URL = window.API_URL || 'https://capacity-planner-production-1cf7.up.railway.app';

const DEFAULT_SIZE_MAP = { XS: 0.5, S: 1, M: 2, L: 3, XL: 5, XXL: 8, XXXL: 13 };
const DEFAULT_TRACK_CAPACITY = {
  'core-bonus': { backend: 0, frontend: 0, natives: 0, qa: 0 },
  'gateway': { backend: 0, frontend: 0, natives: 0, qa: 0 },
  'seo-aff': { backend: 0, frontend: 0, natives: 0, qa: 0 },
};
const DEFAULT_CAPACITY = { backend: 40, frontend: 30, natives: 25, qa: 20 };

const PILLAR_COLORS = {
  'Expansion': '#00b894', 'Acquisition': '#0984e3', 'Core Platform': '#6c5ce7',
  'Comms': '#e67e22', 'Gamification': '#e84393', 'Core Bonus': '#fdcb6e',
};
const PILLAR_CLASSES = {
  'Expansion': 'pill-expansion', 'Acquisition': 'pill-acquisition',
  'Core Platform': 'pill-core-platform', 'Comms': 'pill-comms',
  'Gamification': 'pill-gamification', 'Core Bonus': 'pill-core-bonus',
};

function getCapColor(pct) {
  if (pct <= 70) return 'var(--green)';
  if (pct <= 90) return 'var(--yellow)';
  return 'var(--red)';
}

function getBlockBg(pillar) {
  const c = PILLAR_COLORS[pillar] || '#6c5ce7';
  return `linear-gradient(135deg, ${c}cc, ${c}88)`;
}

// Migrate old track keys to new ones
function migrateTracks(tracks) {
  const result = { ...tracks };
  if ('gamification' in result && !('gateway' in result)) {
    result['gateway'] = result['gamification'];
    delete result['gamification'];
  }
  // Ensure all expected keys exist
  if (!result['core-bonus']) result['core-bonus'] = [];
  if (!result['gateway']) result['gateway'] = [];
  if (!result['seo-aff']) result['seo-aff'] = [];
  return result;
}

function migrateTrackCapacity(tc) {
  const result = tc ? JSON.parse(JSON.stringify(tc)) : {};
  const ZERO = { backend: 0, frontend: 0, natives: 0, qa: 0 };
  if (!result['core-bonus']) result['core-bonus'] = { ...ZERO };
  if (!result['gateway']) result['gateway'] = { ...ZERO };
  if (!result['seo-aff']) result['seo-aff'] = { ...ZERO };
  return result;
}

const BLOCK_HEIGHT = 80;
const MIN_WIDTH = 100;
const MAX_WIDTH = 360;
const PX_PER_SPRINT = 20;

function App() {
  const [activeVertical, setActiveVertical] = useState('growth');
  const [sizeMap, setSizeMap] = useState({...DEFAULT_SIZE_MAP});
  const [tooltip, setTooltip] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [activeTab, setActiveTab] = useState('planner');
  const [editingCell, setEditingCell] = useState(null);
  const [editValue, setEditValue] = useState('');
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [bulkField, setBulkField] = useState('pillar');
  const [bulkValue, setBulkValue] = useState('');
  const [saveStatus, setSaveStatus] = useState(null); // {type: 'ok'|'error', msg: '...'}
  const [buffer, setBuffer] = useState({ backend: 0, frontend: 0, natives: 0, qa: 0 });
  const [splitModal, setSplitModal] = useState(null); // { projectId, projectName, existing: {...} }

  const TRACKS = [
    { key: 'core-bonus', label: 'Core Bonus', gradient: 'linear-gradient(180deg, #fdcb6ecc, #fdcb6e88)', borderColor: 'rgba(253,203,110,0.4)' },
    { key: 'gateway', label: 'Gateway', gradient: 'linear-gradient(180deg, #e84393cc, #e8439388)', borderColor: 'rgba(232,67,147,0.4)' },
    { key: 'seo-aff', label: 'SEO & AFF', gradient: 'linear-gradient(180deg, #00b894cc, #00b89488)', borderColor: 'rgba(0,184,148,0.4)' },
  ];

  // Data loaded from API
  const [verticalData, setVerticalData] = useState({});
  const [verticalStates, setVerticalStates] = useState(() => {
    const state = {};
    for (const v of VERTICALS) state[v.key] = { capacity: {...DEFAULT_CAPACITY}, tracks: { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }, trackCapacity: JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY)), splits: {} };
    return state;
  });

  // Load data from API
  const loadVertical = useCallback(async (key) => {
    try {
      const [projRes, stateRes] = await Promise.all([
        fetch(`${API_URL}/api/verticals/${key}/projects`).then(r => r.json()),
        fetch(`${API_URL}/api/verticals/${key}/state`).then(r => r.json()),
      ]);
      setVerticalData(prev => ({ ...prev, [key]: projRes.projects || [] }));
      setVerticalStates(prev => ({
        ...prev,
        [key]: {
          capacity: stateRes.capacity || {...DEFAULT_CAPACITY},
          tracks: migrateTracks(stateRes.tracks || { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }),
          trackCapacity: migrateTrackCapacity(stateRes.trackCapacity),
          splits: stateRes.splits || {},
        }
      }));
    } catch (e) {
      console.error('Failed to load vertical:', key, e);
    }
  }, []);

  useEffect(() => {
    (async () => {
      setLoading(true);
      await loadVertical(activeVertical);
      setLoading(false);
    })();
  }, [activeVertical, loadVertical]);

  // Auto-save state to API (debounced)
  const saveTimer = useRef(null);
  const saveState = useCallback(async (key, state) => {
    try {
      setSaving(true);
      await fetch(`${API_URL}/api/verticals/${key}/state`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ capacity: state.capacity, tracks: state.tracks, trackCapacity: state.trackCapacity, splits: state.splits }),
      });
    } catch (e) {
      console.error('Failed to save state:', e);
    } finally {
      setSaving(false);
    }
  }, []);

  const debouncedSave = useCallback((key, state) => {
    if (saveTimer.current) clearTimeout(saveTimer.current);
    saveTimer.current = setTimeout(() => saveState(key, state), 800);
  }, [saveState]);

  // Save projects to API
  const projectSaveTimer = useRef(null);
  const saveStatusTimer = useRef(null);
  const saveProjects = useCallback(async (key, projects) => {
    try {
      setSaving(true);
      setSaveStatus(null);
      const url = `${API_URL}/api/verticals/${encodeURIComponent(key)}/projects`;
      console.log('Saving to:', url, 'projects:', projects.length);
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ projects }),
      });
      let data;
      try { data = await res.json(); } catch (jsonErr) {
        const text = await res.text().catch(() => '');
        setSaveStatus({ type: 'error', msg: `Save failed (${res.status}): not JSON - ${text.slice(0,100)}` });
        return;
      }
      if (!res.ok) {
        setSaveStatus({ type: 'error', msg: `Save failed: ${data.error || res.status}` });
        console.error('Save projects failed:', data);
      } else {
        setSaveStatus({ type: 'ok', msg: `Saved ${data.projectCount} projects` });
        if (saveStatusTimer.current) clearTimeout(saveStatusTimer.current);
        saveStatusTimer.current = setTimeout(() => setSaveStatus(null), 3000);
      }
    } catch (e) {
      setSaveStatus({ type: 'error', msg: `Save error: ${e.message}` });
      console.error('Save projects error:', e);
    } finally {
      setSaving(false);
    }
  }, []);

  const debouncedSaveProjects = useCallback((key, projects) => {
    if (projectSaveTimer.current) clearTimeout(projectSaveTimer.current);
    projectSaveTimer.current = setTimeout(() => saveProjects(key, projects), 800);
  }, [saveProjects]);

  const currentData = verticalData[activeVertical] || [];
  const currentState = verticalStates[activeVertical] || { capacity: {...DEFAULT_CAPACITY}, tracks: { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }, trackCapacity: JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY)), splits: {} };
  const capacity = currentState.capacity;
  const tracks = currentState.tracks;
  const trackCapacity = currentState.trackCapacity || JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY));
  const splits = currentState.splits || {};

  const roadmapIds = useMemo(() => {
    const s = new Set();
    for (const arr of Object.values(tracks)) arr.forEach(id => s.add(id));
    return s;
  }, [tracks]);

  const setCapacity = (updater) => {
    setVerticalStates(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          capacity: typeof updater === 'function' ? updater(prev[activeVertical].capacity) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };
  const updateTrackCapacity = (trackKey, discipline, value) => {
    setVerticalStates(prev => {
      const prevTC = prev[activeVertical].trackCapacity || JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY));
      const newTC = { ...prevTC, [trackKey]: { ...prevTC[trackKey], [discipline]: value } };
      // Validate: sum across tracks for this discipline can't exceed total capacity
      const sum = Object.values(newTC).reduce((s, tc) => s + (tc[discipline] || 0), 0);
      if (sum > prev[activeVertical].capacity[discipline]) return prev; // block the change
      const newState = {
        ...prev,
        [activeVertical]: { ...prev[activeVertical], trackCapacity: newTC }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const saveSplit = (projectId, targetTrack, sizings) => {
    setVerticalStates(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (!prevSplits[projectId]) prevSplits[projectId] = {};
      prevSplits[projectId] = { ...prevSplits[projectId], [targetTrack]: sizings };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const removeSplit = (projectId, targetTrack) => {
    setVerticalStates(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (prevSplits[projectId]) {
        const updated = { ...prevSplits[projectId] };
        delete updated[targetTrack];
        if (Object.keys(updated).length === 0) delete prevSplits[projectId];
        else prevSplits[projectId] = updated;
      }
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const setTracks = (updater) => {
    setVerticalStates(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          tracks: typeof updater === 'function' ? updater(prev[activeVertical].tracks) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const [search, setSearch] = useState('');
  const [filters, setFilters] = useState({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
  const [openFilter, setOpenFilter] = useState(null);
  const [sortBy, setSortBy] = useState('impact');
  const [colorBy, setColorBy] = useState('pillar');
  const dragItem = useRef(null);
  const dragSource = useRef(null);

  const handleVerticalChange = (key) => {
    setActiveVertical(key);
    setSearch('');
    setFilters({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
    setLoading(true);
  };

  const sizeToSprints = useCallback((size) => {
    if (!size || size === 'nan' || size === '' || size === 'NaN') return 0;
    return sizeMap[size] || 0;
  }, [sizeMap]);

  const projectSprints = useCallback((p) => ({
    backend: sizeToSprints(p.backend),
    frontend: sizeToSprints(p.frontend),
    natives: sizeToSprints(p.natives),
    qa: sizeToSprints(p.qa),
    total: sizeToSprints(p.backend) + sizeToSprints(p.frontend) + sizeToSprints(p.natives) + sizeToSprints(p.qa)
  }), [sizeToSprints]);

  const uniqueValues = useMemo(() => ({
    pillar: [...new Set(currentData.map(p => p.pillar).filter(Boolean))].sort(),
    market: [...new Set(currentData.map(p => p.targetMarket).filter(Boolean))].sort(),
    epic: [...new Set(currentData.map(p => p.masterEpic).filter(Boolean))].sort(),
    kpi: [...new Set(currentData.map(p => p.targetKPI).filter(Boolean))].sort(),
    impact: ['XS','S','M','L','XL','XXL','XXXL'],
  }), [currentData]);

  const filterProjects = useCallback((projects) => {
    return projects.filter(p => {
      if (search) {
        const q = search.toLowerCase();
        if (!p.subTask.toLowerCase().includes(q) && !p.nvrd.toLowerCase().includes(q) && !p.masterEpic.toLowerCase().includes(q)) return false;
      }
      if (filters.pillar.length && !filters.pillar.includes(p.pillar)) return false;
      if (filters.market.length && !filters.market.includes(p.targetMarket)) return false;
      if (filters.epic.length && !filters.epic.includes(p.masterEpic)) return false;
      if (filters.kpi.length && !filters.kpi.includes(p.targetKPI)) return false;
      if (filters.impact.length && !filters.impact.includes(p.impact)) return false;
      return true;
    });
  }, [search, filters]);

  const impactOrder = { XXXL: 7, XXL: 6, XL: 5, L: 4, M: 3, S: 2, XS: 1 };
  const sortProjects = useCallback((projects) => {
    return [...projects].sort((a, b) => {
      if (sortBy === 'impact') return (impactOrder[b.impact]||0) - (impactOrder[a.impact]||0);
      if (sortBy === 'effort') return projectSprints(b).total - projectSprints(a).total;
      if (sortBy === 'name') return a.subTask.localeCompare(b.subTask);
      if (sortBy === 'epic') return a.masterEpic.localeCompare(b.masterEpic);
      if (sortBy === 'pillar') return a.pillar.localeCompare(b.pillar);
      return 0;
    });
  }, [sortBy, projectSprints]);

  const roadmapProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);
  const backlogProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => !roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);

  const usedCapacity = useMemo(() => {
    return currentData.filter(p => roadmapIds.has(p.id)).reduce((acc, p) => {
      const s = projectSprints(p);
      return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
    }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
  }, [roadmapIds, projectSprints, currentData]);

  // Apply buffer to roadmap used capacity
  const bufferedUsed = useMemo(() => ({
    backend: Math.round(usedCapacity.backend * (1 + buffer.backend / 100) * 10) / 10,
    frontend: Math.round(usedCapacity.frontend * (1 + buffer.frontend / 100) * 10) / 10,
    natives: Math.round(usedCapacity.natives * (1 + buffer.natives / 100) * 10) / 10,
    qa: Math.round(usedCapacity.qa * (1 + buffer.qa / 100) * 10) / 10,
  }), [usedCapacity, buffer]);

  const totalCapacity = capacity.backend + capacity.frontend + capacity.natives + capacity.qa;
  const totalUsed = bufferedUsed.backend + bufferedUsed.frontend + bufferedUsed.natives + bufferedUsed.qa;

  // Total demand across ALL projects (not just roadmap)
  const totalDemand = useMemo(() => {
    return currentData.reduce((acc, p) => {
      const s = projectSprints(p);
      return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
    }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
  }, [currentData, projectSprints]);

  const bufferedDemand = useMemo(() => ({
    backend: Math.round(totalDemand.backend * (1 + buffer.backend / 100) * 10) / 10,
    frontend: Math.round(totalDemand.frontend * (1 + buffer.frontend / 100) * 10) / 10,
    natives: Math.round(totalDemand.natives * (1 + buffer.natives / 100) * 10) / 10,
    qa: Math.round(totalDemand.qa * (1 + buffer.qa / 100) * 10) / 10,
  }), [totalDemand, buffer]);

  // Remove id from all tracks
  const removeFromTracks = (trks, id) => {
    const n = {};
    for (const k of Object.keys(trks)) n[k] = trks[k].filter(x => x !== id);
    return n;
  };

  const moveToTrack = (id, trackKey, insertIndex) => setTracks(prev => {
    const n = removeFromTracks(prev, id);
    if (insertIndex !== undefined) n[trackKey].splice(insertIndex, 0, id);
    else n[trackKey].push(id);
    return n;
  });
  const moveToBacklog = (id) => setTracks(prev => removeFromTracks(prev, id));

  const handleDragStart = (e, id, source) => {
    dragItem.current = id; dragSource.current = source;
    e.dataTransfer.effectAllowed = 'move';
    setTimeout(() => e.target.classList.add('dragging'), 0);
  };
  const handleDragEnd = (e) => {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
  };
  const handleDragOver = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
  const handleDragEnter = (e) => { e.currentTarget.classList.add('drag-over'); };
  const handleDragLeave = (e) => { if (!e.currentTarget.contains(e.relatedTarget)) e.currentTarget.classList.remove('drag-over'); };

  const handleDropOnTrack = (e, trackKey) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current) return;
    moveToTrack(dragItem.current, trackKey);
  };

  const handleDropOnBlock = (e, trackKey, blockId, blockIndex) => {
    e.preventDefault(); e.stopPropagation();
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current || dragItem.current === blockId) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    const insertIdx = dropAfter ? blockIndex + 1 : blockIndex;
    // Adjust index if dragging from same track before this position
    const currentTrackIds = tracks[trackKey] || [];
    const currentIdx = currentTrackIds.indexOf(dragItem.current);
    let adjustedIdx = insertIdx;
    if (currentIdx !== -1 && currentIdx < insertIdx) adjustedIdx = insertIdx - 1;
    moveToTrack(dragItem.current, trackKey, adjustedIdx);
  };

  const handleDragOverBlock = (e, trackKey, blockId) => {
    e.preventDefault(); e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    if (!dragItem.current || dragItem.current === blockId) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    // Show drop indicator
    const existing = e.currentTarget.parentElement.querySelectorAll('.drop-indicator');
    existing.forEach(el => el.remove());
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    if (dropAfter) {
      e.currentTarget.after(indicator);
    } else {
      e.currentTarget.before(indicator);
    }
  };

  const handleDropOnBacklog = (e) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    if (dragItem.current && dragSource.current !== 'backlog') moveToBacklog(dragItem.current);
  };

  const toggleFilter = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: prev[key].includes(value) ? prev[key].filter(v => v !== value) : [...prev[key], value] }));
  };
  const activeFilterCount = Object.values(filters).reduce((s, a) => s + a.length, 0);

  useEffect(() => {
    const handler = (e) => { if (!e.target.closest('.filter-group')) setOpenFilter(null); };
    document.addEventListener('click', handler);
    return () => document.removeEventListener('click', handler);
  }, []);

  const getBlockWidth = (p) => {
    const sprints = projectSprints(p).total;
    return Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, sprints * PX_PER_SPRINT));
  };

  const handleMouseEnter = (e, p) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setTooltip({ p, x: rect.right + 8, y: rect.top });
  };
  const handleMouseLeave = () => setTooltip(null);

  const renderCapBar = (label, used, total) => {
    const pct = total > 0 ? Math.round((used / total) * 100) : 0;
    const barColor = getCapColor(pct);
    return (
      <div className="cap-bar-container">
        <div className="cap-bar-label">
          <span>{label}</span>
          <span style={{color: barColor, fontWeight:700}}>{used}/{total} ({pct}%)</span>
        </div>
        <div className="cap-bar-track">
          <div className="cap-bar-fill" style={{ width: `${Math.min(pct,100)}%`, background: barColor }}>
            {pct > 15 ? `${pct}%` : ''}
          </div>
        </div>
      </div>
    );
  };

  // Find which track a project primarily lives in
  const getProjectHomeTrack = useCallback((projectId) => {
    for (const t of TRACKS) {
      if ((tracks[t.key] || []).includes(projectId)) return t;
    }
    return null;
  }, [tracks]);

  const renderBlock = (p, lane, trackKey, blockIndex) => {
    const s = projectSprints(p);
    const w = getBlockWidth(p);
    const isTrack = lane === 'roadmap' && trackKey;
    const overflowDisciplines = (isTrack && trackOverflow[trackKey] && trackOverflow[trackKey][p.id]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    const hasSplits = splits[p.id] && Object.keys(splits[p.id]).length > 0;
    return (
      <div key={p.id}
        className={`project-block ${p.inProgress ? 'in-progress' : ''} ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar) }}
        draggable
        onDragStart={(e) => handleDragStart(e, p.id, lane)}
        onDragEnd={handleDragEnd}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
        {...(isTrack ? {
          onDragOver: (e) => handleDragOverBlock(e, trackKey, p.id),
          onDrop: (e) => handleDropOnBlock(e, trackKey, p.id, blockIndex),
        } : {})}
      >
        {isOverflow && (
          <div className="overflow-badge" title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        {hasSplits && <div className="ghost-link-icon" title="Has split allocations">ðŸ”—</div>}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{s.total}sp</span>
          </div>
        </div>
        {isTrack && (
          <button className="block-split"
            onClick={(e) => { e.stopPropagation(); setSplitModal({ projectId: p.id, projectName: p.subTask, homeTrack: trackKey }); }}
            title="Split to another swimlane">
            â‘‚
          </button>
        )}
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); lane === 'backlog' ? moveToTrack(p.id, 'core-bonus') : moveToBacklog(p.id); }}
          title={lane === 'backlog' ? 'Add to Roadmap' : 'Remove from Roadmap'}>
          {lane === 'backlog' ? 'ï¼‹' : 'âœ•'}
        </button>
      </div>
    );
  };

  const renderGhostBlock = (p, splitSizing, trackKey, homeTrack) => {
    const totalSp = (splitSizing.backend || 0) + (splitSizing.frontend || 0) + (splitSizing.natives || 0) + (splitSizing.qa || 0);
    const w = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, totalSp * PX_PER_SPRINT));
    const homeLabel = TRACKS.find(t => t.key === homeTrack)?.label || homeTrack;
    // Check overflow for ghost blocks too
    const overflowDisciplines = (trackOverflow[trackKey] && trackOverflow[trackKey][`ghost-${p.id}`]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    return (
      <div key={`ghost-${p.id}`}
        className={`project-block ghost-block ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar) }}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
      >
        <div className="ghost-link-icon">ðŸ”—</div>
        {isOverflow && (
          <div className="overflow-badge" style={{left:'auto',right:3}} title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{totalSp}sp</span>
          </div>
        </div>
        <div className="ghost-origin">â†— {homeLabel}</div>
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); removeSplit(p.id, trackKey); }}
          title="Remove split">
          âœ•
        </button>
      </div>
    );
  };

  // Compute ghost blocks per track
  const ghostsByTrack = useMemo(() => {
    const result = {};
    for (const t of TRACKS) result[t.key] = [];
    for (const [pidStr, trackSplits] of Object.entries(splits)) {
      const pid = parseInt(pidStr) || pidStr;
      const p = projectById[pid];
      if (!p) continue;
      for (const [targetTrack, sizing] of Object.entries(trackSplits)) {
        if (result[targetTrack]) {
          result[targetTrack].push({ project: p, sizing, homeTrack: getProjectHomeTrack(pid)?.key });
        }
      }
    }
    return result;
  }, [splits, projectById, getProjectHomeTrack]);

  const FilterDropdown = ({ filterKey, label }) => {
    const values = uniqueValues[filterKey];
    const selected = filters[filterKey];
    const isOpen = openFilter === filterKey;
    return (
      <div className="filter-group">
        <button className={`filter-btn ${selected.length ? 'active' : ''}`}
          onClick={(e) => { e.stopPropagation(); setOpenFilter(isOpen ? null : filterKey); }}>
          {label}
          {selected.length > 0 && <span className="count">{selected.length}</span>}
          <span style={{fontSize:10}}>â–¾</span>
        </button>
        <div className={`filter-dropdown ${isOpen ? 'open' : ''}`}>
          {values.map(v => (
            <label key={v} className="filter-option">
              <input type="checkbox" checked={selected.includes(v)} onChange={() => toggleFilter(filterKey, v)} />
              {v}
            </label>
          ))}
        </div>
      </div>
    );
  };

  const projectById = useMemo(() => {
    const m = {};
    for (const p of currentData) m[p.id] = p;
    return m;
  }, [currentData]);

  const trackProjects = useMemo(() => {
    const result = {};
    const filtered = new Set(filterProjects(currentData).map(p => p.id));
    for (const t of TRACKS) {
      result[t.key] = (tracks[t.key] || []).map(id => projectById[id]).filter(p => p && filtered.has(p.id));
    }
    return result;
  }, [tracks, projectById, filterProjects, currentData]);

  // Per-track used capacity (including ghost splits)
  const trackUsed = useMemo(() => {
    const result = {};
    for (const t of TRACKS) {
      const fromProjects = (trackProjects[t.key] || []).reduce((acc, p) => {
        const s = projectSprints(p);
        return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
      }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
      // Add ghost split sizings
      const fromGhosts = (ghostsByTrack[t.key] || []).reduce((acc, g) => {
        return { backend: acc.backend + (g.sizing.backend || 0), frontend: acc.frontend + (g.sizing.frontend || 0), natives: acc.natives + (g.sizing.natives || 0), qa: acc.qa + (g.sizing.qa || 0) };
      }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
      result[t.key] = {
        backend: fromProjects.backend + fromGhosts.backend,
        frontend: fromProjects.frontend + fromGhosts.frontend,
        natives: fromProjects.natives + fromGhosts.natives,
        qa: fromProjects.qa + fromGhosts.qa,
      };
    }
    return result;
  }, [trackProjects, projectSprints, ghostsByTrack]);

  // Unallocated capacity per discipline
  const unallocated = useMemo(() => {
    const result = {};
    for (const d of ['backend', 'frontend', 'natives', 'qa']) {
      const allocated = Object.values(trackCapacity).reduce((s, tc) => s + (tc[d] || 0), 0);
      result[d] = capacity[d] - allocated;
    }
    return result;
  }, [capacity, trackCapacity]);

  // Per-track overflow detection: which projects push a discipline over the track's allocation
  const trackOverflow = useMemo(() => {
    const result = {};
    for (const t of TRACKS) {
      const tc = trackCapacity[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
      const hasAllocation = Object.values(tc).some(v => v > 0);
      if (!hasAllocation) { result[t.key] = {}; continue; }
      const running = { backend:0, frontend:0, natives:0, qa:0 };
      const overflows = {};
      // Check real projects
      for (const p of (trackProjects[t.key] || [])) {
        const s = projectSprints(p);
        for (const d of ['backend','frontend','natives','qa']) running[d] += s[d];
        const exceeded = [];
        for (const d of ['backend','frontend','natives','qa']) {
          if (tc[d] > 0 && running[d] > tc[d]) exceeded.push(d);
        }
        if (exceeded.length > 0) overflows[p.id] = exceeded;
      }
      // Check ghost blocks
      for (const g of (ghostsByTrack[t.key] || [])) {
        for (const d of ['backend','frontend','natives','qa']) running[d] += (g.sizing[d] || 0);
        const exceeded = [];
        for (const d of ['backend','frontend','natives','qa']) {
          if (tc[d] > 0 && running[d] > tc[d]) exceeded.push(d);
        }
        if (exceeded.length > 0) overflows[`ghost-${g.project.id}`] = exceeded;
      }
      result[t.key] = overflows;
    }
    return result;
  }, [trackProjects, trackCapacity, projectSprints, ghostsByTrack]);

  const activeV = VERTICALS.find(v => v.key === activeVertical);
  const roadmapTotalSprints = currentData.filter(p => roadmapIds.has(p.id)).reduce((s, p) => s + projectSprints(p).total, 0);

  // â”€â”€ Projects Table Component â”€â”€
  const VALID_SIZES = ['', 'XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];
  const VALID_IMPACTS = ['XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];

  const updateProject = (projectId, field, value) => {
    const updated = currentData.map(p => p.id === projectId ? { ...p, [field]: value } : p);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell(null);
  };

  const addProject = () => {
    const maxId = currentData.length > 0 ? Math.max(...currentData.map(p => p.id)) : 0;
    const newProject = {
      id: maxId + 1, nvrd: '', masterEpic: '', subTask: 'New Project',
      pillar: '', targetMarket: '', targetKPI: '', impact: 'M',
      backend: '', frontend: '', natives: '', qa: '', inProgress: false,
    };
    const updated = [...currentData, newProject];
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell({ id: newProject.id, field: 'subTask' });
    setEditValue('New Project');
  };

  const deleteProject = (projectId) => {
    if (!window.confirm('Delete this project?')) return;
    const updated = currentData.filter(p => p.id !== projectId);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => removeFromTracks(prev, projectId));
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
  };

  // â”€â”€ Bulk operations â”€â”€
  const toggleSelect = (id) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  };

  const toggleSelectAll = () => {
    if (selectedIds.size === currentData.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(currentData.map(p => p.id)));
    }
  };

  const bulkDelete = () => {
    if (selectedIds.size === 0) return;
    if (!window.confirm(`Delete ${selectedIds.size} selected project${selectedIds.size > 1 ? 's' : ''}?`)) return;
    const updated = currentData.filter(p => !selectedIds.has(p.id));
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => {
      let t = prev;
      for (const id of selectedIds) t = removeFromTracks(t, id);
      return t;
    });
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
    setSelectedIds(new Set());
  };

  const bulkEdit = () => {
    if (selectedIds.size === 0 || !bulkField) return;
    const updated = currentData.map(p =>
      selectedIds.has(p.id) ? { ...p, [bulkField]: bulkValue } : p
    );
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
  };

  const BULK_FIELD_OPTIONS = [
    { key: 'pillar', label: 'Pillar' },
    { key: 'targetMarket', label: 'Market' },
    { key: 'targetKPI', label: 'KPI' },
    { key: 'impact', label: 'Impact' },
    { key: 'backend', label: 'Backend' },
    { key: 'frontend', label: 'Frontend' },
    { key: 'natives', label: 'Natives' },
    { key: 'qa', label: 'QA' },
    { key: 'masterEpic', label: 'Epic' },
  ];

  const sizeFields = new Set(['impact', 'backend', 'frontend', 'natives', 'qa']);

  const startEdit = (id, field, value) => {
    setEditingCell({ id, field });
    setEditValue(value || '');
  };

  const commitEditRef = useRef(null);
  commitEditRef.current = () => {
    if (editingCell) {
      updateProject(editingCell.id, editingCell.field, editValue);
    }
  };
  const commitEdit = () => commitEditRef.current();

  const dropdownFields = { impact: VALID_IMPACTS, backend: VALID_SIZES, frontend: VALID_SIZES, natives: VALID_SIZES, qa: VALID_SIZES };

  const renderEditableCell = (p, field) => {
    const isEditing = editingCell?.id === p.id && editingCell?.field === field;
    const value = p[field] || '';

    if (isEditing) {
      if (dropdownFields[field]) {
        return (
          <select className="cell-select" value={editValue}
            onChange={(e) => { updateProject(p.id, field, e.target.value); }}
            onBlur={() => setEditingCell(null)}
            onKeyDown={(e) => { if (e.key === 'Escape') setEditingCell(null); }}
            autoFocus>
            {dropdownFields[field].map(v => <option key={v} value={v}>{v || 'â€”'}</option>)}
          </select>
        );
      }
      return (
        <input className="cell-input" value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={commitEdit}
          onKeyDown={(e) => {
            if (e.key === 'Enter') commitEdit();
            if (e.key === 'Escape') setEditingCell(null);
          }}
          autoFocus />
      );
    }
    return (
      <div className="cell-view" onClick={() => startEdit(p.id, field, value)}>
        {value || 'â€”'}
      </div>
    );
  };

  const TABLE_COLS = [
    { key: 'nvrd', label: 'NVRD', width: '8%' },
    { key: 'masterEpic', label: 'Epic', width: '12%' },
    { key: 'subTask', label: 'Sub Task', width: '22%' },
    { key: 'pillar', label: 'Pillar', width: '9%' },
    { key: 'targetMarket', label: 'Market', width: '7%' },
    { key: 'targetKPI', label: 'KPI', width: '8%' },
    { key: 'impact', label: 'Impact', width: '6%' },
    { key: 'backend', label: 'BE', width: '5%' },
    { key: 'frontend', label: 'FE', width: '5%' },
    { key: 'natives', label: 'Native', width: '5%' },
    { key: 'qa', label: 'QA', width: '5%' },
  ];

  const projectsTableJSX = (
    <div className="projects-container">
      <div className="projects-toolbar">
        <button className="btn btn-primary" onClick={addProject}>+ Add Project</button>
        <span className="project-count-badge">{currentData.length} projects</span>
        {selectedIds.size > 0 && (
          <button className="btn-sm" onClick={() => setSelectedIds(new Set())} style={{marginLeft:4}}>
            Deselect all
          </button>
        )}
        {saveStatus && (
          <span style={{
            fontSize: 11, padding: '3px 10px', borderRadius: 6, fontWeight: 600,
            background: saveStatus.type === 'ok' ? 'rgba(0,184,148,0.15)' : 'rgba(225,112,85,0.15)',
            color: saveStatus.type === 'ok' ? 'var(--green)' : 'var(--red)',
          }}>{saveStatus.msg}</span>
        )}
      </div>

      {selectedIds.size > 0 && (
        <div className="bulk-bar">
          <span className="bulk-count">{selectedIds.size} selected</span>
          <div className="bulk-sep" />
          <button className="btn-sm danger" onClick={bulkDelete}>
            Delete selected
          </button>
          <div className="bulk-sep" />
          <div className="bulk-edit-group">
            <span style={{fontSize:11, color:'var(--text2)'}}>Set</span>
            <select value={bulkField} onChange={e => { setBulkField(e.target.value); setBulkValue(''); }}>
              {BULK_FIELD_OPTIONS.map(o => <option key={o.key} value={o.key}>{o.label}</option>)}
            </select>
            <span style={{fontSize:11, color:'var(--text2)'}}>to</span>
            {sizeFields.has(bulkField) ? (
              <select value={bulkValue} onChange={e => setBulkValue(e.target.value)}>
                <option value="">â€” select â€”</option>
                {(bulkField === 'impact' ? VALID_IMPACTS : VALID_SIZES.filter(Boolean)).map(v =>
                  <option key={v} value={v}>{v}</option>
                )}
              </select>
            ) : (
              <input type="text" value={bulkValue} onChange={e => setBulkValue(e.target.value)}
                placeholder="value..." style={{width:120}} />
            )}
            <button className="btn-sm apply" onClick={bulkEdit} disabled={!bulkValue}>
              Apply
            </button>
          </div>
        </div>
      )}

      <table className="projects-table">
        <thead>
          <tr>
            <th className="check-col">
              <input type="checkbox" className="row-checkbox"
                checked={currentData.length > 0 && selectedIds.size === currentData.length}
                onChange={toggleSelectAll} />
            </th>
            <th style={{width:'3%'}}>#</th>
            {TABLE_COLS.map(c => <th key={c.key} style={{width:c.width}}>{c.label}</th>)}
            <th style={{width:'5%'}}></th>
          </tr>
        </thead>
        <tbody>
          {currentData.map((p, i) => (
            <tr key={p.id} className={`${editingCell?.id === p.id ? 'editing-row' : ''} ${selectedIds.has(p.id) ? 'editing-row' : ''}`}>
              <td className="check-col">
                <input type="checkbox" className="row-checkbox"
                  checked={selectedIds.has(p.id)}
                  onChange={() => toggleSelect(p.id)} />
              </td>
              <td style={{color:'var(--text2)', fontSize:10}}>{i+1}</td>
              {TABLE_COLS.map(c => <td key={c.key}>{renderEditableCell(p, c.key)}</td>)}
              <td>
                <button className="btn-icon danger" onClick={() => deleteProject(p.id)} title="Delete project">
                  Ã—
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      {currentData.length === 0 && (
        <div style={{textAlign:'center', padding:'60px 40px', color:'var(--text2)'}}>
          <p style={{fontSize:16, marginBottom:12}}>No projects yet</p>
          <p style={{fontSize:13}}>Click <strong>"+ Add Project"</strong> to create your first project.</p>
        </div>
      )}
    </div>
  );

  const renderTooltip = () => {
    if (!tooltip) return null;
    const { p, x, y } = tooltip;
    const s = projectSprints(p);
    const efforts = [];
    if (s.backend) efforts.push({ label: 'BE', val: p.backend, sprints: s.backend });
    if (s.frontend) efforts.push({ label: 'FE', val: p.frontend, sprints: s.frontend });
    if (s.natives) efforts.push({ label: 'Native', val: p.natives, sprints: s.natives });
    if (s.qa) efforts.push({ label: 'QA', val: p.qa, sprints: s.qa });
    // Keep tooltip on screen
    const tx = Math.min(x, window.innerWidth - 340);
    const ty = Math.min(y, window.innerHeight - 200);
    return (
      <div className="tooltip-overlay" style={{ left: tx, top: ty }}>
        <div className="tooltip-card">
          <div className="tt-title">{p.subTask}</div>
          <div className="tt-meta">
            <span className={`pill pill-pillar ${PILLAR_CLASSES[p.pillar]||''}`}>{p.pillar}</span>
            <span className="pill pill-market">{p.targetMarket}</span>
            <span className="pill pill-kpi">{p.targetKPI}</span>
            <span className={`pill pill-impact impact-${p.impact}`}>Impact: {p.impact}</span>
          </div>
          <div className="tt-efforts">
            {efforts.map(e => (
              <span key={e.label} className="effort-tag">{e.label}: <span className="val">{e.val}</span> ({e.sprints}sp)</span>
            ))}
          </div>
          <div className="tt-total">Total: {s.total} man-sprints</div>
        </div>
      </div>
    );
  };

  return (
    <>
      <div className="app-header">
        <h1>
          <span style={{color: activeV.color}}>{activeV.icon}</span>
          {' '}{activeV.label} <span>Capacity Planner</span>
        </h1>
        <div className="header-right">
          <div className="tab-switcher">
            <button className={`tab-btn ${activeTab === 'planner' ? 'active' : ''}`}
              onClick={() => setActiveTab('planner')}>Planner</button>
            <button className={`tab-btn ${activeTab === 'projects' ? 'active' : ''}`}
              onClick={() => setActiveTab('projects')}>Projects</button>
          </div>
          <div className="vertical-selector">
            <label>Vertical</label>
            <select className="vertical-select" value={activeVertical}
              onChange={e => handleVerticalChange(e.target.value)}>
              {VERTICALS.map(v => (
                <option key={v.key} value={v.key}>{v.icon} {v.label}</option>
              ))}
            </select>
          </div>
          {saving && <span style={{fontSize:11, color:'var(--accent2)'}}>Saving...</span>}
          {currentData.length > 0 && activeTab === 'planner' && (
            <span style={{fontSize:12, color:'var(--text2)'}}>
              {roadmapIds.size} in roadmap Â· {currentData.length - roadmapIds.size} in backlog
            </span>
          )}
        </div>
      </div>

      {loading ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon" style={{animation:'pulse-indicator 1s ease-in-out infinite alternate'}}>â³</div>
          <h2>Loading {activeV.label} data...</h2>
        </div>
      ) : activeTab === 'projects' ? (
        projectsTableJSX
      ) : currentData.length === 0 ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon">{activeV.icon}</div>
          <h2>{activeV.label} Backlog</h2>
          <p>No project data loaded for this vertical yet. Switch to the <strong>Projects</strong> tab above to add projects.</p>
        </div>
      ) : (<>

      <div className="config-bar">
        <div className="config-section">
          <h3>Team Capacity (man-sprints)</h3>
          <div className="config-inputs">
            {['backend','frontend','natives','qa'].map(k => (
              <div key={k} className="config-field">
                <label>{k.charAt(0).toUpperCase() + k.slice(1)}</label>
                <input type="number" min="0" value={capacity[k]}
                  onChange={e => setCapacity(prev => ({...prev, [k]: parseInt(e.target.value)||0}))} />
              </div>
            ))}
          </div>
        </div>
        <div className="config-section">
          <h3>T-shirt â†’ Sprints</h3>
          <div className="size-mapping">
            {Object.entries(sizeMap).map(([size, val]) => (
              <div key={size} className="size-chip">
                <span>{size}</span>
                <input type="number" min="0" step="0.5" value={val}
                  onChange={e => setSizeMap(prev => ({...prev, [size]: parseFloat(e.target.value)||0}))} />
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="track-alloc-section">
        <h3>Capacity Allocation per Swimlane</h3>
        <div className="track-alloc-grid">
          <div className="track-alloc-header"></div>
          {['backend','frontend','natives','qa'].map(d => (
            <div key={d} className="track-alloc-header">{d.charAt(0).toUpperCase()+d.slice(1)}</div>
          ))}
          <div className="track-alloc-header"></div>
          {TRACKS.map(t => {
            const used = trackUsed[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
            const tc = trackCapacity[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
            return (
              <React.Fragment key={t.key}>
                <div className="track-alloc-label" style={{borderLeft:`3px solid ${t.borderColor}`, paddingLeft:8}}>{t.label}</div>
                {['backend','frontend','natives','qa'].map(d => {
                  const pct = tc[d] > 0 ? Math.round(used[d] / tc[d] * 100) : 0;
                  const color = pct > 100 ? '#e17055' : pct > 80 ? '#fdcb6e' : '#00b894';
                  return (
                    <div key={d}>
                      <input type="number" min="0" className={`track-alloc-input${used[d] > tc[d] && tc[d] > 0 ? ' over-cap' : ''}`}
                        value={tc[d]} onChange={e => updateTrackCapacity(t.key, d, parseInt(e.target.value)||0)} />
                      {tc[d] > 0 && <div className="track-cap-bar"><div className="track-cap-fill" style={{width:`${Math.min(pct,100)}%`, background: color}} /></div>}
                    </div>
                  );
                })}
                <div style={{fontSize:10,color:'var(--muted)'}}>
                  {Object.values(used).reduce((a,b)=>a+b,0)}/{Object.values(tc).reduce((a,b)=>a+b,0)}
                </div>
              </React.Fragment>
            );
          })}
          <div className="track-alloc-label" style={{fontWeight:700}}>Remaining</div>
          {['backend','frontend','natives','qa'].map(d => (
            <div key={d} className={`track-alloc-remaining ${unallocated[d] < 0 ? 'over' : unallocated[d] === 0 ? 'warn' : 'ok'}`}>
              {unallocated[d]}
            </div>
          ))}
          <div></div>
        </div>
      </div>

      <div className="capacity-overview">
        {renderCapBar('Backend', bufferedUsed.backend, capacity.backend)}
        {renderCapBar('Frontend', bufferedUsed.frontend, capacity.frontend)}
        {renderCapBar('Natives', bufferedUsed.natives, capacity.natives)}
        {renderCapBar('QA', bufferedUsed.qa, capacity.qa)}
        <div className="cap-total">
          {renderCapBar('Total Capacity', totalUsed, totalCapacity)}
        </div>
      </div>

      <div className="demand-section">
        {['backend', 'frontend', 'natives', 'qa'].map(k => (
          <div key={k} className="demand-card">
            <div className="demand-card-title">{k.charAt(0).toUpperCase() + k.slice(1)} Total Demand</div>
            <div className="demand-card-value">{totalDemand[k]} <span style={{fontSize:11,color:'var(--muted)',fontWeight:400}}>sprints</span></div>
            <div className="demand-buffer-row">
              <button className="demand-buffer-btn" onClick={() => setBuffer(prev => ({...prev, [k]: prev[k] - 5}))}>âˆ’</button>
              <span className="demand-buffer-pct">{buffer[k] >= 0 ? '+' : ''}{buffer[k]}%</span>
              <button className="demand-buffer-btn" onClick={() => setBuffer(prev => ({...prev, [k]: prev[k] + 5}))}>+</button>
            </div>
            {buffer[k] !== 0 && (
              <div className="demand-card-buffered">With buffer: {bufferedDemand[k]} sprints</div>
            )}
          </div>
        ))}
      </div>

      <div className="filters-bar">
        <input className="search-input" placeholder="Search projects..." value={search} onChange={e => setSearch(e.target.value)} />
        <FilterDropdown filterKey="pillar" label="Pillar" />
        <FilterDropdown filterKey="epic" label="Epic" />
        <FilterDropdown filterKey="market" label="Market" />
        <FilterDropdown filterKey="kpi" label="KPI" />
        <FilterDropdown filterKey="impact" label="Impact" />
        {activeFilterCount > 0 && (
          <button className="btn" onClick={() => setFilters({pillar:[],market:[],epic:[],kpi:[],impact:[]})}>
            Clear ({activeFilterCount})
          </button>
        )}
        <div style={{marginLeft:'auto'}} className="sort-controls">
          <span style={{fontSize:10,color:'var(--text2)'}}>Sort:</span>
          <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
            <option value="impact">Impact â†“</option>
            <option value="effort">Effort â†“</option>
            <option value="epic">Epic</option>
            <option value="pillar">Pillar</option>
            <option value="name">Name</option>
          </select>
        </div>
        <div className="color-legend">
          {Object.entries(PILLAR_COLORS).map(([name, color]) => (
            <div key={name} className="legend-item">
              <div className="legend-dot" style={{background: color}}></div>
              {name}
            </div>
          ))}
        </div>
      </div>

      <div className="main-scroll">
        {/* Roadmap Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              âœ… In Roadmap
              <span className="badge roadmap-badge">{roadmapProjects.length}</span>
              <span style={{fontSize:11,color:'var(--text2)',fontWeight:400,marginLeft:8}}>
                {roadmapTotalSprints} total sprints
              </span>
            </h2>
            <div className="lane-stats">
              {['backend','frontend','natives','qa'].map(k => (
                <span key={k} className="stat-chip">
                  {k.charAt(0).toUpperCase()+k.slice(1)}: <strong>{bufferedUsed[k]}</strong>/{capacity[k]}
                </span>
              ))}
            </div>
          </div>
          <div className="track-group">
            {TRACKS.map((track, i) => (
              <React.Fragment key={track.key}>
                {i > 0 && <div className="track-divider" />}
                <div className="track-row">
                  <div className="track-label" style={{background: track.gradient}}>
                    {track.label}
                    {(() => {
                      const tc = trackCapacity[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                      const tu = trackUsed[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                      const totalAlloc = Object.values(tc).reduce((a,b)=>a+b,0);
                      const totalUsedTrack = Object.values(tu).reduce((a,b)=>a+b,0);
                      return totalAlloc > 0 ? (
                        <span style={{fontSize:9,opacity:0.9,display:'block',marginTop:2}}>
                          {totalUsedTrack}/{totalAlloc}
                        </span>
                      ) : null;
                    })()}
                  </div>
                  <div className="track-flow"
                    onDragOver={handleDragOver} onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                    onDrop={(e) => handleDropOnTrack(e, track.key)}
                    style={{borderColor: track.borderColor}}>
                    {(trackProjects[track.key] || []).length === 0 && (ghostsByTrack[track.key] || []).length === 0 && <div className="track-empty">Drag projects here</div>}
                    {(trackProjects[track.key] || []).map((p, idx) => renderBlock(p, 'roadmap', track.key, idx))}
                    {(ghostsByTrack[track.key] || []).map(g => renderGhostBlock(g.project, g.sizing, track.key, g.homeTrack))}
                  </div>
                </div>
              </React.Fragment>
            ))}
          </div>
        </div>

        {/* Backlog Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              ðŸ“‹ Backlog
              <span className="badge backlog-badge">{backlogProjects.length}</span>
            </h2>
            <div style={{display:'flex',gap:6}}>
              <button className="btn btn-primary" onClick={() => {
                const sorted = [...currentData].sort((a,b) => (impactOrder[b.impact]||0) - (impactOrder[a.impact]||0));
                let used = {backend:0,frontend:0,natives:0,qa:0};
                const newTracks = {};
                for (const t of TRACKS) newTracks[t.key] = [];
                for (const p of sorted) {
                  const s = projectSprints(p);
                  if (used.backend+s.backend <= capacity.backend && used.frontend+s.frontend <= capacity.frontend && used.natives+s.natives <= capacity.natives && used.qa+s.qa <= capacity.qa) {
                    newTracks['core-bonus'].push(p.id); used.backend += s.backend; used.frontend += s.frontend; used.natives += s.natives; used.qa += s.qa;
                  }
                }
                setTracks(newTracks);
              }}>Auto-fill by Impact</button>
              <button className="btn" onClick={() => {
                const empty = {};
                for (const t of TRACKS) empty[t.key] = [];
                setTracks(empty);
              }}>Clear All</button>
            </div>
          </div>
          <div className="flow-container"
            onDragOver={handleDragOver} onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave} onDrop={handleDropOnBacklog}>
            {backlogProjects.length === 0 && <div className="empty-flow">All projects are in the roadmap</div>}
            {backlogProjects.map(p => renderBlock(p, 'backlog'))}
          </div>
        </div>
      </div>

      {renderTooltip()}
      </>)}

      {splitModal && (() => {
        const { projectId, projectName, homeTrack } = splitModal;
        const existingSplits = splits[projectId] || {};
        const otherTracks = TRACKS.filter(t => t.key !== homeTrack);
        const [targetTrack, setTargetTrack] = [
          splitModal._targetTrack || otherTracks[0]?.key,
          (v) => setSplitModal(prev => ({ ...prev, _targetTrack: v }))
        ];
        const [splitSizing, setSplitSizing] = [
          splitModal._sizing || existingSplits[targetTrack] || { backend: 0, frontend: 0, natives: 0, qa: 0 },
          (v) => setSplitModal(prev => ({ ...prev, _sizing: typeof v === 'function' ? v(prev._sizing || existingSplits[prev._targetTrack || otherTracks[0]?.key] || { backend:0,frontend:0,natives:0,qa:0 }) : v }))
        ];
        return (
          <div className="split-modal-overlay" onClick={() => setSplitModal(null)}>
            <div className="split-modal" onClick={e => e.stopPropagation()}>
              <h3>Split: {projectName}</h3>
              {Object.keys(existingSplits).length > 0 && (
                <div className="split-existing">
                  <div style={{fontSize:10,color:'var(--muted)',marginBottom:4,fontWeight:600}}>EXISTING SPLITS</div>
                  {Object.entries(existingSplits).map(([tk, sz]) => {
                    const tLabel = TRACKS.find(t => t.key === tk)?.label || tk;
                    const total = (sz.backend||0) + (sz.frontend||0) + (sz.natives||0) + (sz.qa||0);
                    return (
                      <div key={tk} className="split-existing-item">
                        <span>{tLabel}: B{sz.backend||0} F{sz.frontend||0} N{sz.natives||0} Q{sz.qa||0} = {total}sp</span>
                        <button className="btn-sm" style={{fontSize:10,padding:'2px 6px',background:'var(--red)',color:'white',border:'none',borderRadius:3,cursor:'pointer'}}
                          onClick={() => { removeSplit(projectId, tk); setSplitModal(prev => ({...prev})); }}>Remove</button>
                      </div>
                    );
                  })}
                </div>
              )}
              <div className="split-modal-fields">
                <div className="split-field-row">
                  <label>Target Lane</label>
                  <select value={targetTrack} onChange={e => {
                    const newTrack = e.target.value;
                    setSplitModal(prev => ({ ...prev, _targetTrack: newTrack, _sizing: existingSplits[newTrack] || { backend:0, frontend:0, natives:0, qa:0 } }));
                  }}>
                    {otherTracks.map(t => <option key={t.key} value={t.key}>{t.label}</option>)}
                  </select>
                </div>
                {['backend','frontend','natives','qa'].map(d => (
                  <div key={d} className="split-field-row">
                    <label>{d.charAt(0).toUpperCase()+d.slice(1)}</label>
                    <input type="number" min="0" step="0.5" value={splitSizing[d] || 0}
                      onChange={e => setSplitSizing(prev => ({...prev, [d]: parseFloat(e.target.value)||0}))} />
                    <span style={{fontSize:10,color:'var(--muted)'}}> sprints</span>
                  </div>
                ))}
              </div>
              <div className="split-modal-actions">
                <button className="btn-cancel" onClick={() => setSplitModal(null)}>Cancel</button>
                <button className="btn-save" onClick={() => {
                  const finalTarget = splitModal._targetTrack || otherTracks[0]?.key;
                  const finalSizing = splitModal._sizing || existingSplits[finalTarget] || { backend:0,frontend:0,natives:0,qa:0 };
                  saveSplit(projectId, finalTarget, finalSizing);
                  setSplitModal(null);
                }}>Save Split</button>
              </div>
            </div>
          </div>
        );
      })()}
    </>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
