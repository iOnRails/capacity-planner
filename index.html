<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Capacity Planner</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #232733;
    --border: #2e3345;
    --text: #e2e4eb;
    --text2: #8b90a0;
    --accent: #6c5ce7;
    --accent2: #a29bfe;
    --green: #00b894;
    --yellow: #fdcb6e;
    --red: #e17055;
    --orange: #e67e22;
    --blue: #0984e3;
    --pink: #e84393;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* â”€â”€ Header â”€â”€ */
  .app-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 28px; background: var(--surface);
    border-bottom: 1px solid var(--border);
    position: sticky; top: 0; z-index: 100;
  }
  .app-header h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.3px; }
  .app-header h1 span { color: var(--accent2); }
  .header-right { display: flex; gap: 12px; align-items: center; }

  /* â”€â”€ Vertical Selector â”€â”€ */
  .vertical-selector { display: flex; align-items: center; gap: 8px; }
  .vertical-selector label {
    font-size: 11px; color: var(--text2); text-transform: uppercase;
    letter-spacing: 0.8px; font-weight: 600;
  }
  .vertical-select {
    padding: 7px 32px 7px 14px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    color: var(--text); font-size: 14px; font-weight: 700;
    outline: none; cursor: pointer; appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b90a0'%3E%3Cpath d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 10px center;
    transition: border-color 0.15s;
  }
  .vertical-select:hover, .vertical-select:focus { border-color: var(--accent); }

  /* â”€â”€ Settings Panel (tabbed) â”€â”€ */
  .settings-panel {
    background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .settings-tabs {
    display: flex; gap: 0; padding: 0 28px; border-bottom: 1px solid var(--border);
    background: var(--surface2);
  }
  .settings-tab {
    padding: 8px 16px; font-size: 11px; font-weight: 600; color: var(--text2);
    cursor: pointer; border: none; background: none; border-bottom: 2px solid transparent;
    transition: all 0.15s; white-space: nowrap;
  }
  .settings-tab:hover { color: var(--text); background: rgba(108,92,231,0.06); }
  .settings-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .settings-tab-content { padding: 14px 28px; }

  /* â”€â”€ Config Panel â”€â”€ */
  .config-bar {
    display: flex; gap: 28px; align-items: flex-end; flex-wrap: wrap;
  }
  .config-section h3 {
    font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
    color: var(--text2); margin-bottom: 6px; font-weight: 600;
  }
  .config-inputs { display: flex; gap: 10px; flex-wrap: wrap; }
  .config-field { display: flex; flex-direction: column; gap: 3px; }
  .config-field label { font-size: 10px; color: var(--text2); font-weight: 500; }
  .config-field input {
    width: 64px; padding: 5px 8px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 6px;
    color: var(--text); font-size: 13px; font-weight: 600;
    text-align: center; outline: none;
  }
  .config-field input:focus { border-color: var(--accent); }
  .size-mapping { display: flex; gap: 5px; align-items: center; }
  .size-chip { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .size-chip span { font-size: 9px; color: var(--text2); font-weight: 600; }
  .size-chip input {
    width: 40px; padding: 3px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; text-align: center; outline: none;
  }
  .size-chip input:focus { border-color: var(--accent); }

  /* â”€â”€ Capacity Bars â”€â”€ */
  .capacity-overview {
    display: flex; gap: 14px; flex-wrap: wrap;
  }
  .cap-bar-container { flex: 1; min-width: 160px; }
  .cap-bar-label {
    display: flex; justify-content: space-between;
    font-size: 11px; margin-bottom: 3px; font-weight: 500;
  }
  .cap-bar-track {
    height: 18px; background: var(--bg); border-radius: 5px;
    overflow: hidden; border: 1px solid var(--border);
  }
  .cap-bar-fill {
    height: 100%; border-radius: 4px; transition: width 0.4s ease, background 0.3s;
    display: flex; align-items: center; justify-content: flex-end;
    padding-right: 5px; font-size: 9px; font-weight: 700;
    color: rgba(255,255,255,0.9);
  }
  .cap-total {
    flex: 1; min-width: 160px; background: var(--surface2);
    border-radius: 8px; padding: 6px 12px; border: 1px solid var(--border);
  }
  .cap-total .cap-bar-label { font-weight: 700; font-size: 12px; }

  /* â”€â”€ Track Capacity Allocation â”€â”€ */
  .track-alloc-section { }
  .track-alloc-grid {
    display: grid; grid-template-columns: 120px repeat(4, 1fr) auto; gap: 6px 10px; align-items: center;
  }
  .track-alloc-header { font-size: 10px; text-transform: uppercase; color: var(--muted); font-weight: 600; letter-spacing: 0.5px; }
  .track-alloc-label { font-size: 12px; font-weight: 600; color: var(--text); }
  .track-alloc-input {
    width: 100%; padding: 4px 6px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px; text-align: center; outline: none;
  }
  .track-alloc-input:focus { border-color: var(--accent); }
  .track-alloc-input.over-cap { border-color: #e17055; background: rgba(225,112,85,0.1); }
  .track-alloc-remaining { font-size: 11px; text-align: center; }
  .track-alloc-remaining.ok { color: #00b894; }
  .track-alloc-remaining.warn { color: #fdcb6e; }
  .track-alloc-remaining.over { color: #e17055; font-weight: 700; }
  .track-cap-bar { margin-top: 2px; height: 4px; background: var(--bg); border-radius: 2px; overflow: hidden; }
  .track-cap-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }

  /* â”€â”€ Total Demand â”€â”€ */
  .demand-section {
    display: flex; gap: 16px; flex-wrap: wrap; align-items: stretch;
  }
  .demand-card {
    flex: 1; min-width: 150px; background: var(--surface2); border-radius: 8px;
    padding: 10px 14px; border: 1px solid var(--border); display: flex; flex-direction: column; gap: 6px;
  }
  .demand-card-title { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); font-weight: 600; }
  .demand-card-value { font-size: 20px; font-weight: 700; color: var(--text); }
  .demand-card-buffered { font-size: 11px; color: var(--accent); font-weight: 500; }
  .demand-buffer-row { display: flex; align-items: center; gap: 6px; margin-top: 2px; }
  .demand-buffer-btn {
    width: 22px; height: 22px; border-radius: 4px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text); font-size: 13px; font-weight: 700;
    cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s;
    padding: 0; line-height: 1;
  }
  .demand-buffer-btn:hover { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .demand-buffer-pct { font-size: 11px; color: var(--muted); min-width: 36px; text-align: center; }

  /* â”€â”€ Filters â”€â”€ */
  .filters-bar {
    padding: 10px 28px; display: flex; gap: 8px; flex-wrap: wrap;
    align-items: center; background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .filter-group { position: relative; }
  .filter-btn {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; cursor: pointer;
    display: flex; align-items: center; gap: 5px; transition: all 0.15s;
  }
  .filter-btn:hover { border-color: var(--accent); }
  .filter-btn.active { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .filter-btn .count {
    background: var(--accent); color: white; font-size: 9px;
    padding: 1px 5px; border-radius: 10px; font-weight: 700;
  }
  .filter-dropdown {
    position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; padding: 6px; z-index: 50; min-width: 150px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
  }
  .filter-dropdown.open { display: block; }
  .filter-option {
    display: flex; align-items: center; gap: 6px; padding: 5px 8px;
    border-radius: 4px; cursor: pointer; font-size: 11px;
  }
  .filter-option:hover { background: rgba(255,255,255,0.05); }
  .filter-option input[type="checkbox"] { accent-color: var(--accent); }
  .search-input {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; outline: none; width: 200px;
  }
  .search-input:focus { border-color: var(--accent); }
  .search-input::placeholder { color: var(--text2); }
  .sort-controls { display: flex; gap: 5px; align-items: center; }
  .sort-controls select {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none; cursor: pointer;
  }

  /* â”€â”€ Btn â”€â”€ */
  .btn {
    padding: 5px 14px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn:hover { border-color: var(--accent); }
  .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-primary:hover { background: var(--accent2); }

  /* â”€â”€ Lane (horizontal) â”€â”€ */
  .lane-section { padding: 0 28px 8px; }
  .lane-header-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 28px 10px; margin: 0 -28px;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .lane-header-row h2 {
    font-size: 16px; font-weight: 700; display: flex; align-items: center; gap: 8px;
  }
  .badge {
    font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 700;
  }
  .roadmap-badge { background: rgba(0,184,148,0.2); color: var(--green); }
  .backlog-badge { background: rgba(139,144,160,0.2); color: var(--text2); }
  .lane-stats {
    display: flex; gap: 8px; align-items: center;
  }
  .stat-chip {
    font-size: 10px; padding: 3px 8px; background: var(--surface);
    border-radius: 6px; color: var(--text2); font-weight: 500;
  }
  .stat-chip strong { color: var(--text); }

  /* â”€â”€ Flow Container â”€â”€ */
  .flow-container {
    display: flex; flex-wrap: wrap; gap: 6px; padding: 10px;
    min-height: 80px; border-radius: 10px;
    background: var(--surface); border: 1px solid var(--border);
    transition: all 0.2s;
    margin-top: 10px;
  }
  .flow-container.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
    box-shadow: inset 0 0 20px rgba(108,92,231,0.08);
  }
  .flow-container.roadmap-flow { border-color: rgba(0,184,148,0.25); }
  .empty-flow {
    width: 100%; display: flex; align-items: center; justify-content: center;
    min-height: 70px; color: var(--text2); font-size: 12px;
    border: 2px dashed var(--border); border-radius: 8px;
  }

  /* â”€â”€ Track (sub-lane within roadmap) â”€â”€ */
  .track-group { margin-top: 10px; }
  .track-capacity-bar {
    display: flex; gap: 12px; padding: 4px 12px 2px 48px;
    font-size: 11px; color: var(--text2);
  }
  .track-cap-chip { white-space: nowrap; }
  .track-cap-chip strong { color: var(--text); }
  .track-cap-chip.over { color: #ff6b6b; }
  .track-cap-chip.over strong { color: #ff6b6b; }
  .track-row {
    display: flex; align-items: stretch; gap: 0;
  }
  .track-label {
    writing-mode: vertical-lr; text-orientation: mixed;
    transform: rotate(180deg);
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; font-weight: 700; letter-spacing: 0.5px;
    padding: 10px 8px; border-radius: 10px 0 0 10px;
    min-width: 36px; text-align: center; white-space: nowrap;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .track-flow {
    display: flex; flex-wrap: wrap; gap: 8px; padding: 12px;
    min-height: 80px; border-radius: 0 10px 10px 0;
    background: var(--surface); border: 1px solid var(--border);
    border-left: none; flex: 1; transition: all 0.2s;
    align-content: flex-start;
  }
  .track-flow.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
  }
  .track-divider {
    height: 1px; background: var(--border); margin: 2px 0 2px 36px; opacity: 0.5;
  }
  .track-empty {
    display: flex; align-items: center; justify-content: center;
    width: 100%; min-height: 50px; color: var(--text2); font-size: 12px;
    border: 1px dashed var(--border); border-radius: 6px;
    font-style: italic;
  }

  /* â”€â”€ Project Block (proportional) â”€â”€ */
  .project-block {
    position: relative; border-radius: 8px; cursor: grab;
    transition: all 0.15s; user-select: none; overflow: hidden;
    display: flex; flex-direction: column; justify-content: space-between;
    border: 1px solid transparent;
  }
  .project-block:hover {
    border-color: rgba(255,255,255,0.3);
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    transform: translateY(-2px);
    z-index: 5;
  }
  .project-block.dragging { opacity: 0.3; transform: scale(0.95); }
  .project-block.in-progress { box-shadow: inset 0 0 0 2px var(--green); }

  /* â”€â”€ Overflow indicator â”€â”€ */
  .project-block.overflow-block {
    border: 2px solid #ff4444 !important;
    box-shadow: 0 0 12px rgba(255,68,68,0.5), inset 0 0 0 1px rgba(255,68,68,0.3);
    animation: overflow-pulse 1.5s ease-in-out infinite alternate;
  }
  @keyframes overflow-pulse {
    from { box-shadow: 0 0 8px rgba(255,68,68,0.4), inset 0 0 0 1px rgba(255,68,68,0.2); }
    to { box-shadow: 0 0 16px rgba(255,68,68,0.7), inset 0 0 0 1px rgba(255,68,68,0.4); }
  }
  .overflow-badge {
    position: absolute; top: 4px; left: 4px; z-index: 10;
    background: #ff4444; color: white; font-size: 9px; font-weight: 800;
    padding: 2px 6px; border-radius: 3px; letter-spacing: 0.3px;
    text-shadow: 0 1px 1px rgba(0,0,0,0.3); line-height: 1.2;
    pointer-events: none;
  }

  .block-content {
    padding: 10px 12px; display: flex; flex-direction: column;
    height: 100%; overflow: hidden;
  }
  .overflow-block .block-content { padding-top: 20px; }
  .ghost-block .block-content { padding-top: 20px; }
  .block-title {
    font-size: 12px; font-weight: 600; line-height: 1.3;
    overflow: hidden; text-overflow: ellipsis;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .block-bottom {
    display: flex; justify-content: space-between; align-items: flex-end;
    margin-top: auto; padding-top: 4px;
  }
  .block-jira {
    font-size: 10px; color: rgba(255,255,255,0.7); font-weight: 600;
  }
  .block-sprints {
    font-size: 11px; font-weight: 800; color: white;
    background: rgba(0,0,0,0.3); padding: 2px 7px; border-radius: 4px;
  }
  .block-pillar-line {
    height: 3px; width: 100%; opacity: 0.8;
  }

  /* â”€â”€ Ghost block (split allocation) â”€â”€ */
  .project-block.ghost-block {
    border: 2px dashed rgba(162,155,254,0.6) !important;
    opacity: 0.75;
    background: repeating-linear-gradient(
      -45deg, transparent, transparent 4px, rgba(0,0,0,0.08) 4px, rgba(0,0,0,0.08) 8px
    ) !important;
  }
  .project-block.ghost-block:hover { opacity: 0.9; }
  .ghost-origin {
    position: absolute; bottom: 3px; left: 6px; font-size: 8px; font-weight: 700;
    color: rgba(162,155,254,0.9); pointer-events: none; letter-spacing: 0.3px;
  }
  .ghost-link-icon {
    position: absolute; top: 3px; right: 22px; font-size: 10px; z-index: 10;
    pointer-events: none;
  }

  /* â”€â”€ Split button on block â”€â”€ */
  .block-split {
    position: absolute; top: 4px; right: 26px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-split { opacity: 1; }
  .block-split:hover { background: var(--accent); }

  /* â”€â”€ Split modal â”€â”€ */
  .split-modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    z-index: 300; display: flex; align-items: center; justify-content: center;
  }
  .split-modal {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 12px; padding: 20px; min-width: 340px;
    box-shadow: 0 16px 48px rgba(0,0,0,0.5);
  }
  .split-modal h3 { font-size: 14px; margin-bottom: 12px; }
  .split-modal-fields { display: flex; flex-direction: column; gap: 8px; margin-bottom: 14px; }
  .split-field-row { display: flex; align-items: center; gap: 10px; }
  .split-field-row label { width: 70px; font-size: 12px; font-weight: 500; }
  .split-field-row select, .split-field-row input {
    flex: 1; padding: 6px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px;
  }
  .split-modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
  .split-modal-actions button {
    padding: 6px 16px; border-radius: 6px; border: 1px solid var(--border);
    font-size: 12px; cursor: pointer; transition: all 0.15s;
  }
  .split-modal-actions .btn-save { background: var(--accent); color: white; border-color: var(--accent); }
  .split-modal-actions .btn-save:hover { opacity: 0.8; }
  .split-modal-actions .btn-cancel { background: var(--surface); color: var(--text); }
  .split-modal-actions .btn-cancel:hover { background: var(--surface2); }
  .split-modal-actions .btn-remove { background: var(--red); color: white; border-color: var(--red); }
  .split-modal-actions .btn-remove:hover { opacity: 0.8; }
  .split-existing { margin-bottom: 12px; padding: 8px; background: var(--bg); border-radius: 6px; }
  .split-existing-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; font-size: 11px;
  }

  /* â”€â”€ Move button on block â”€â”€ */
  .block-move {
    position: absolute; top: 4px; right: 4px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-move { opacity: 1; }
  .block-move:hover { background: var(--accent); }

  /* â”€â”€ Tooltip â”€â”€ */
  .tooltip-overlay {
    position: fixed; z-index: 200; pointer-events: none;
  }
  .tooltip-card {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 10px; padding: 14px 16px; width: 320px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  }
  .tooltip-card .tt-title { font-size: 13px; font-weight: 700; margin-bottom: 8px; }
  .tooltip-card .tt-meta { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 8px; }
  .tooltip-card .tt-efforts { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 6px; }
  .tooltip-card .tt-total {
    font-size: 12px; font-weight: 700; color: var(--accent2); text-align: right;
  }
  .pill {
    font-size: 10px; padding: 2px 8px; border-radius: 10px;
    font-weight: 600; white-space: nowrap;
  }
  .pill-pillar { opacity: 0.9; }
  .pill-market { background: rgba(255,255,255,0.08); color: var(--text2); }
  .pill-kpi { background: rgba(9,132,227,0.15); color: var(--blue); }
  .pill-impact { font-weight: 700; }
  .impact-XS { background: rgba(139,144,160,0.15); color: var(--text2); }
  .impact-S { background: rgba(0,184,148,0.12); color: var(--green); }
  .impact-M { background: rgba(9,132,227,0.15); color: var(--blue); }
  .impact-L { background: rgba(108,92,231,0.15); color: var(--accent2); }
  .impact-XL { background: rgba(230,126,34,0.15); color: var(--orange); }
  .impact-XXL { background: rgba(225,112,85,0.15); color: var(--red); }
  .impact-XXXL { background: rgba(225,112,85,0.25); color: var(--red); }
  .effort-tag {
    font-size: 10px; padding: 2px 6px; border-radius: 4px;
    background: rgba(255,255,255,0.06); color: var(--text2); font-weight: 500;
  }
  .effort-tag .val { font-weight: 700; color: var(--text); }

  /* â”€â”€ Empty Vertical â”€â”€ */
  .empty-vertical {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; padding: 80px 40px; text-align: center; gap: 16px;
  }
  .empty-vertical-icon {
    width: 80px; height: 80px; border-radius: 20px; background: var(--surface2);
    border: 2px dashed var(--border); display: flex; align-items: center;
    justify-content: center; font-size: 32px;
  }
  .empty-vertical h2 { font-size: 18px; font-weight: 700; }
  .empty-vertical p { font-size: 13px; color: var(--text2); max-width: 400px; line-height: 1.5; }
  .empty-vertical code {
    background: var(--surface2); padding: 2px 8px; border-radius: 4px;
    font-size: 12px; color: var(--accent2);
  }

  /* â”€â”€ Scroll â”€â”€ */
  .main-scroll { overflow-y: auto; padding-bottom: 40px; }
  .main-scroll::-webkit-scrollbar { width: 6px; }
  .main-scroll::-webkit-scrollbar-track { background: transparent; }
  .main-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* â”€â”€ Color-by legend â”€â”€ */
  .color-legend {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
  }
  .legend-item {
    display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text2);
  }
  .legend-dot {
    width: 10px; height: 10px; border-radius: 3px;
  }

  /* â”€â”€ Tab Switcher â”€â”€ */
  .tab-switcher { display: flex; gap: 4px; background: var(--bg); border-radius: 8px; padding: 3px; }
  .tab-btn {
    padding: 6px 16px; border: none; border-radius: 6px; cursor: pointer;
    font-size: 12px; font-weight: 600; transition: all 0.15s;
    background: transparent; color: var(--text2);
  }
  .tab-btn:hover { color: var(--text); }
  .tab-btn.active { background: var(--accent); color: white; }

  /* â”€â”€ Projects Table â”€â”€ */
  .projects-container {
    padding: 20px 28px; overflow-y: auto;
    max-height: calc(100vh - 70px);
  }
  .projects-toolbar {
    display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;
  }
  .projects-table {
    width: 100%; border-collapse: collapse; font-size: 12px;
  }
  .projects-table th {
    text-align: left; padding: 8px 6px; border-bottom: 2px solid var(--border);
    background: var(--surface); font-size: 10px; text-transform: uppercase;
    font-weight: 700; letter-spacing: 0.5px; color: var(--text2);
    position: sticky; top: 0; z-index: 10;
  }
  .projects-table td {
    padding: 2px 3px; border-bottom: 1px solid var(--border);
    max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .projects-table tbody tr:hover { background: var(--surface2); }
  .projects-table tbody tr.editing-row { background: rgba(108,92,231,0.08); }

  .cell-view {
    padding: 4px 6px; cursor: pointer; border-radius: 4px;
    min-height: 28px; display: flex; align-items: center;
  }
  .cell-view:hover { background: rgba(108,92,231,0.1); }
  .cell-input {
    width: 100%; padding: 4px 6px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none;
    font-family: inherit;
  }
  .cell-select {
    width: 100%; padding: 4px 4px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none; cursor: pointer;
  }
  .btn-icon {
    width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text2); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; transition: all 0.15s;
  }
  .btn-icon:hover { border-color: var(--accent); color: var(--text); }
  .btn-icon.danger:hover { border-color: var(--red); color: var(--red); background: rgba(225,112,85,0.1); }

  .project-count-badge {
    font-size: 11px; color: var(--text2); padding: 4px 10px;
    background: var(--surface); border-radius: 6px;
  }

  /* â”€â”€ Bulk Actions â”€â”€ */
  .bulk-bar {
    display: flex; gap: 10px; align-items: center; padding: 10px 16px;
    background: rgba(108,92,231,0.12); border: 1px solid var(--accent);
    border-radius: 8px; margin-bottom: 12px;
  }
  .bulk-bar .bulk-count {
    font-size: 12px; font-weight: 700; color: var(--accent2);
  }
  .bulk-bar .bulk-sep {
    width: 1px; height: 20px; background: var(--border);
  }
  .bulk-edit-group {
    display: flex; gap: 6px; align-items: center;
  }
  .bulk-edit-group select, .bulk-edit-group input {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none;
  }
  .bulk-edit-group select:focus, .bulk-edit-group input:focus { border-color: var(--accent); }
  .btn-sm {
    padding: 4px 10px; border-radius: 5px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn-sm:hover { border-color: var(--accent); }
  .btn-sm.danger { border-color: var(--red); color: var(--red); }
  .btn-sm.danger:hover { background: rgba(225,112,85,0.15); }
  .btn-sm.apply { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-sm.apply:hover { background: var(--accent2); }

  .row-checkbox {
    accent-color: var(--accent); cursor: pointer; width: 14px; height: 14px;
  }
  .projects-table th.check-col, .projects-table td.check-col {
    width: 30px; text-align: center; padding: 4px;
  }

  /* â”€â”€ Drop Indicator â”€â”€ */
  .drop-indicator {
    width: 3px; min-height: 70px; background: var(--accent);
    border-radius: 2px; flex-shrink: 0;
    box-shadow: 0 0 8px rgba(108,92,231,0.6);
    animation: pulse-indicator 0.8s ease-in-out infinite alternate;
  }
  @keyframes pulse-indicator {
    from { opacity: 0.6; }
    to { opacity: 1; }
  }

  /* â”€â”€ Timeline / Gantt Overlay â”€â”€ */
  .timeline-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    z-index: 500; display: flex; align-items: center; justify-content: center;
    animation: tl-fade-in 0.2s ease-out;
  }
  @keyframes tl-fade-in { from { opacity: 0; } to { opacity: 1; } }
  @keyframes tl-slide-up { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

  .timeline-modal {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 14px; width: 96vw; height: 92vh;
    display: flex; flex-direction: column; overflow: hidden;
    box-shadow: 0 24px 80px rgba(0,0,0,0.7);
    animation: tl-slide-up 0.3s ease-out;
  }

  /* Header */
  .tl-header {
    display: flex; align-items: center; gap: 16px; padding: 12px 20px;
    background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  .tl-header h2 { font-size: 16px; font-weight: 700; white-space: nowrap; }
  .tl-controls { display: flex; gap: 12px; align-items: center; flex: 1; flex-wrap: wrap; }
  .tl-ctrl-group { display: flex; align-items: center; gap: 4px; }
  .tl-ctrl-group label { font-size: 11px; color: var(--text2); font-weight: 600; }
  .tl-ctrl-group input, .tl-ctrl-group select {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 5px; color: var(--text); font-size: 12px; outline: none;
  }
  .tl-ctrl-group input:focus, .tl-ctrl-group select:focus { border-color: var(--accent); }
  .tl-close {
    background: none; border: none; font-size: 22px; color: var(--text2);
    cursor: pointer; padding: 4px 8px; border-radius: 6px; margin-left: auto;
  }
  .tl-close:hover { color: var(--text); background: var(--surface2); }
  .tl-btn {
    padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--accent); color: white; font-size: 11px; font-weight: 600;
    cursor: pointer; white-space: nowrap;
  }
  .tl-btn:hover { opacity: 0.85; }
  .tl-btn-outline { background: var(--surface2); color: var(--text); }

  /* Body layout */
  .tl-body { display: flex; flex: 1; overflow: hidden; }
  .tl-sidebar {
    width: 220px; background: var(--surface); border-right: 1px solid var(--border);
    display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0;
  }
  .tl-sidebar-header {
    padding: 12px 14px; font-size: 13px; font-weight: 700; color: var(--text);
    border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;
  }
  .tl-sidebar-content { padding: 8px; flex: 1; overflow-y: auto; }
  .tl-ms-item {
    display: flex; gap: 8px; padding: 8px 10px; margin-bottom: 4px;
    background: var(--surface2); border-radius: 8px; align-items: flex-start;
    border: 1px solid transparent; transition: border-color 0.15s;
  }
  .tl-ms-item:hover { border-color: var(--border); }
  .tl-ms-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; margin-top: 3px; }
  .tl-ms-name { font-size: 12px; font-weight: 600; color: var(--text); }
  .tl-ms-date { font-size: 10px; color: var(--text2); margin-top: 1px; }
  .tl-ms-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s; margin-left: auto; }
  .tl-ms-item:hover .tl-ms-actions { opacity: 1; }
  .tl-ms-btn {
    padding: 2px 6px; background: var(--surface); color: var(--text2);
    border: 1px solid var(--border); border-radius: 3px; font-size: 10px; cursor: pointer;
  }
  .tl-ms-btn:hover { color: var(--text); border-color: var(--text2); }
  .tl-ms-btn.del:hover { color: var(--red); border-color: var(--red); }
  .tl-ms-empty { font-size: 11px; color: var(--text2); padding: 16px; text-align: center; }

  /* Grid area */
  .tl-grid-wrapper { flex: 1; overflow: auto; position: relative; }
  .tl-grid { display: flex; flex-direction: column; min-width: 100%; }

  /* Ruler */
  .tl-ruler {
    display: flex; position: sticky; top: 0; z-index: 10;
    background: var(--surface); border-bottom: 1px solid var(--border);
    padding-top: 20px; /* space for milestone flags */
  }
  .tl-ruler-label {
    width: 110px; min-width: 110px; padding: 8px 10px; font-size: 10px;
    font-weight: 600; color: var(--text2); text-transform: uppercase;
    border-right: 1px solid var(--border); display: flex; align-items: flex-end;
  }
  .tl-ruler-bar { display: flex; position: relative; flex: 1; }
  .tl-ruler-mark {
    font-size: 10px; color: var(--text2); padding: 4px 6px; text-align: center;
    border-right: 1px solid var(--border); display: flex; align-items: flex-end;
    justify-content: center; font-weight: 500; box-sizing: border-box; flex-shrink: 0;
  }

  /* Track rows */
  .tl-track {
    display: flex; border-bottom: 1px solid var(--border); min-height: 80px;
  }
  .tl-track-label {
    width: 110px; min-width: 110px; padding: 8px 10px;
    font-size: 12px; font-weight: 700; color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    border-right: 1px solid var(--border);
    display: flex; flex-direction: column; justify-content: center; align-items: flex-start;
  }
  .tl-track-bars {
    position: relative; flex: 1; padding: 6px 0; min-height: 72px;
  }

  /* Project bars â€” tall with room for info */
  .tl-bar {
    position: absolute; height: 60px; border-radius: 8px;
    display: flex; flex-direction: column; justify-content: center;
    padding: 6px 14px; cursor: grab;
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 2px 6px rgba(0,0,0,0.2); overflow: hidden;
    transition: box-shadow 0.15s, border-color 0.15s;
    user-select: none;
  }
  .tl-bar:active { cursor: grabbing; }
  .tl-bar:hover {
    box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    border-color: rgba(255,255,255,0.3); z-index: 5;
  }
  .tl-bar-row1 {
    display: flex; align-items: center; gap: 6px;
  }
  .tl-bar-label {
    font-size: 12px; font-weight: 600; color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    flex: 1; min-width: 0;
  }
  .tl-bar-sp {
    font-size: 9px; font-weight: 800; color: rgba(255,255,255,0.9);
    background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; flex-shrink: 0;
  }
  .tl-bar-row2 {
    display: flex; gap: 6px; align-items: center; margin-top: 3px;
  }
  .tl-bar-jira {
    font-size: 9px; color: rgba(255,255,255,0.6); font-weight: 600;
  }
  .tl-bar-disciplines {
    display: flex; gap: 4px; font-size: 8px; font-weight: 700;
    color: rgba(255,255,255,0.7);
  }
  .tl-bar-disciplines span {
    background: rgba(0,0,0,0.2); padding: 1px 4px; border-radius: 2px;
  }
  .tl-bar.ghost {
    border-style: dashed; opacity: 0.6;
  }
  .tl-bar.in-progress {
    box-shadow: 0 2px 6px rgba(0,0,0,0.2), inset 0 0 0 2px var(--green);
  }
  .tl-bar.has-override {
    border-color: var(--yellow); border-width: 2px;
  }

  /* Track capacity stats in timeline */
  .tl-track-stats {
    display: flex; flex-direction: column; gap: 1px; margin-top: 6px; width: 100%;
  }
  .tl-stat-row {
    display: flex; justify-content: space-between; align-items: center;
    font-size: 9px; font-weight: 600; line-height: 1.4;
  }
  .tl-stat-label { color: rgba(255,255,255,0.6); }
  .tl-stat-val { color: rgba(255,255,255,0.9); }
  .tl-stat-val.over { color: #ff6b6b; }

  /* Sub-lane controls */
  .sub-lane-controls { display: flex; gap: 3px; align-items: center; margin-top: 6px; }
  .sub-lane-btn {
    padding: 1px 5px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2);
    border-radius: 3px; color: white; font-size: 10px; font-weight: 600; cursor: pointer;
    transition: all 0.15s; line-height: 1.3;
  }
  .sub-lane-btn:hover { background: rgba(255,255,255,0.25); border-color: rgba(255,255,255,0.35); }

  /* Sub-lane separator lines */
  .tl-sublane-separator {
    position: absolute; left: 0; right: 0; height: 1px;
    background: rgba(255,255,255,0.08); pointer-events: none;
  }

  /* Drag handles for resizing */
  .tl-bar-handle {
    position: absolute; top: 0; width: 8px; height: 100%; cursor: col-resize;
    z-index: 6; opacity: 0; transition: opacity 0.15s;
  }
  .tl-bar:hover .tl-bar-handle { opacity: 1; }
  .tl-bar-handle.left { left: 0; border-radius: 8px 0 0 8px; background: linear-gradient(90deg, rgba(255,255,255,0.3), transparent); }
  .tl-bar-handle.right { right: 0; border-radius: 0 8px 8px 0; background: linear-gradient(-90deg, rgba(255,255,255,0.3), transparent); }

  /* Milestone lines */
  .tl-milestone-line {
    position: absolute; top: 0; bottom: 0; width: 2px; z-index: 4;
    pointer-events: none;
  }
  .tl-milestone-flag {
    position: absolute; top: -14px; transform: translateX(-50%);
    font-size: 9px; font-weight: 700; color: white; padding: 2px 6px;
    border-radius: 3px; white-space: nowrap; pointer-events: auto; cursor: default;
    z-index: 11;
  }

  /* Timeline trigger button */
  .btn-timeline {
    padding: 6px 14px; background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600;
    cursor: pointer; white-space: nowrap; transition: all 0.15s;
    box-shadow: 0 2px 8px rgba(108,92,231,0.3);
  }
  .btn-timeline:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(108,92,231,0.4); }

  /* Error Boundary */
  .error-boundary {
    display: flex; align-items: center; justify-content: center;
    min-height: 100vh; background: var(--bg);
  }
  .error-boundary-box {
    background: var(--surface); border-radius: 16px; padding: 40px;
    text-align: center; max-width: 440px; width: 90%;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
  .error-boundary-box h2 { margin: 8px 0 12px; color: var(--text); }
  .error-boundary-box p { color: var(--muted); font-size: 14px; margin-bottom: 16px; }
  .error-boundary-box pre {
    background: var(--surface2); color: var(--red); border-radius: 8px;
    padding: 12px; font-size: 12px; text-align: left;
    max-height: 200px; overflow: auto; margin-bottom: 20px;
    white-space: pre-wrap; word-break: break-word;
  }
  .error-boundary-box button {
    padding: 10px 24px; background: var(--accent); color: white;
    border: none; border-radius: 8px; font-size: 14px; font-weight: 600;
    cursor: pointer; transition: all 0.15s;
  }
  .error-boundary-box button:hover { opacity: 0.9; transform: translateY(-1px); }

  /* Auth Gate */
  .auth-gate {
    display: flex; align-items: center; justify-content: center;
    min-height: 100vh; background: var(--bg);
  }
  .auth-box {
    background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
    padding: 40px; text-align: center; width: 380px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }
  .auth-icon { font-size: 40px; margin-bottom: 12px; }
  .auth-box h2 { font-size: 20px; font-weight: 700; margin-bottom: 4px; color: var(--text); }
  .auth-box p { font-size: 13px; color: var(--text2); margin-bottom: 20px; }
  .auth-google-wrap {
    display: flex; justify-content: center; margin-bottom: 16px;
  }
  .auth-msg { margin-top: 10px; font-size: 12px; color: var(--red); font-weight: 600; }
  .auth-user {
    display: flex; align-items: center; gap: 10px; justify-content: center;
    margin-bottom: 14px; padding: 8px 14px; background: var(--surface2);
    border-radius: 8px; border: 1px solid var(--border);
  }
  .auth-user img { width: 28px; height: 28px; border-radius: 50%; }
  .auth-user-info { text-align: left; }
  .auth-user-name { font-size: 13px; font-weight: 600; color: var(--text); }
  .auth-user-email { font-size: 11px; color: var(--text2); }
  .auth-logout {
    font-size: 11px; color: var(--text2); background: none; border: none;
    cursor: pointer; text-decoration: underline; margin-top: 8px;
  }
  .auth-logout:hover { color: var(--red); }
  .auth-domain { font-size: 11px; color: var(--text2); margin-bottom: 8px; }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="shared/computations.js"></script>
<script type="text/babel">
const { useState, useMemo, useCallback, useRef, useEffect } = React;

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error('[ErrorBoundary]', error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <div className="error-boundary-box">
            <div style={{ fontSize: 40, marginBottom: 12 }}>&#9888;&#65039;</div>
            <h2>Something went wrong</h2>
            <p>The application encountered an unexpected error. Try reloading the page.</p>
            {this.state.error && (
              <pre>{this.state.error.message || String(this.state.error)}</pre>
            )}
            <button onClick={() => window.location.reload()}>Reload Page</button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

const VERTICALS = [
  { key: 'growth', label: 'Growth', color: '#6c5ce7', icon: 'ðŸ“ˆ' },
  { key: 'sportsbook', label: 'Sportsbook', color: '#00b894', icon: 'âš½' },
  { key: 'casino', label: 'Casino', color: '#e84393', icon: 'ðŸŽ°' },
  { key: 'account', label: 'Account', color: '#0984e3', icon: 'ðŸ‘¤' },
  { key: 'payments', label: 'Payments', color: '#fdcb6e', icon: 'ðŸ’³' },
];

// â”€â”€ API Configuration â”€â”€
// Set this to your Railway API URL after deploying, e.g. 'https://your-app.railway.app'
const API_URL = window.API_URL || 'https://capacity-planner-production-1cf7.up.railway.app';

// DEFAULT_SIZE_MAP, PILLAR_PALETTE, DEFAULT_TRACK_CONFIG from shared/computations.js (CP.*)
function buildDefaultTrackCapacity(trackConfig) {
  const tc = {};
  const keys = trackConfig ? trackConfig.map(t => t.key) : CP.TRACK_KEYS;
  for (const k of keys) tc[k] = { backend: 0, frontend: 0, natives: 0, qa: 0 };
  return tc;
}
const DEFAULT_CAPACITY = { backend: 40, frontend: 30, natives: 25, qa: 20 };

// getCapColor, getBlockBg, migrateTracks, migrateTrackCapacity â€” from shared/computations.js
const { getCapColor, getBlockBg, migrateTracks, migrateTrackCapacity } = CP;

function isLightColor(hex) {
  const r = parseInt(hex.slice(1,3), 16), g = parseInt(hex.slice(3,5), 16), b = parseInt(hex.slice(5,7), 16);
  return (r * 299 + g * 587 + b * 114) / 1000 > 160;
}

const BLOCK_HEIGHT = 94;
const MIN_WIDTH = 100;
const MAX_WIDTH = 360;
const PX_PER_SPRINT_WEEK = 50;
const DEFAULT_TIMELINE_CONFIG = {
  sprintStartDate: new Date().toISOString().split('T')[0],
  sprintDurationWeeks: 2,
  timeScale: 'months',
};
const MILESTONE_COLORS = ['#e84393','#fdcb6e','#00b894','#0984e3','#e67e22','#a29bfe','#e17055'];
const PX_PER_SPRINT = 20;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Dashboard View Component
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function DashboardView({ capacity, buffer, usedCapacity, bufferedUsed, totalDemand, bufferedDemand, trackCapacity, trackUsed, unallocated, tracks, currentData, roadmapIds, projectSprints, sizeMap, pillarColorMap }) {
  const DISCIPLINES = ['backend', 'frontend', 'natives', 'qa'];
  const DISC_COLORS = { backend: '#0984e3', frontend: '#00b894', natives: '#e84393', qa: '#fdcb6e' };
  const DISC_LABELS = { backend: 'Backend', frontend: 'Frontend', natives: 'Natives', qa: 'QA' };

  // Projects by pillar
  const byPillar = useMemo(() => {
    const m = {};
    currentData.forEach(p => { const k = p.pillar || 'Unassigned'; m[k] = (m[k] || 0) + 1; });
    return Object.entries(m).sort((a, b) => b[1] - a[1]);
  }, [currentData]);

  // Projects by impact
  const byImpact = useMemo(() => {
    const order = ['XS','S','M','L','XL','XXL','XXXL'];
    const m = {};
    currentData.forEach(p => { const k = p.impact || 'None'; m[k] = (m[k] || 0) + 1; });
    return order.map(s => [s, m[s] || 0]).concat(m['None'] ? [['None', m['None']]] : []);
  }, [currentData]);

  // Projects by status (in roadmap vs backlog, in-progress vs not)
  const statusCounts = useMemo(() => {
    let inRoadmap = 0, inBacklog = 0, inProgress = 0;
    currentData.forEach(p => {
      if (roadmapIds.has(p.id)) { inRoadmap++; if (p.inProgress) inProgress++; }
      else inBacklog++;
    });
    return { inRoadmap, inBacklog, inProgress, total: currentData.length };
  }, [currentData, roadmapIds]);

  const barStyle = (used, total, color) => {
    const pct = total > 0 ? Math.min(100, (used / total) * 100) : 0;
    const over = used > total;
    return {
      height: 22, borderRadius: 4, background: 'var(--surface2)', position: 'relative', overflow: 'hidden',
      border: over ? '1px solid #e74c3c' : '1px solid var(--border)',
    };
  };
  const barFill = (used, total, color) => {
    const pct = total > 0 ? Math.min(100, (used / total) * 100) : 0;
    const over = used > total;
    return {
      position: 'absolute', top: 0, left: 0, bottom: 0,
      width: `${pct}%`, background: over ? '#e74c3c99' : color + '88',
      borderRadius: 4, transition: 'width 0.3s ease',
    };
  };
  const barText = { position: 'absolute', top: 0, left: 8, right: 8, bottom: 0, display: 'flex', alignItems: 'center', fontSize: 11, color: 'var(--text1)', fontWeight: 500, whiteSpace: 'nowrap' };

  const cardStyle = { background: 'var(--surface1)', border: '1px solid var(--border)', borderRadius: 8, padding: '16px 20px' };
  const headerStyle = { fontSize: 13, fontWeight: 600, color: 'var(--text1)', marginBottom: 12, textTransform: 'uppercase', letterSpacing: '0.5px' };

  return (
    <div style={{padding: '20px 24px', maxWidth: 1200, margin: '0 auto'}}>
      {/* Summary Cards */}
      <div style={{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:12,marginBottom:20}}>
        <div style={{...cardStyle,textAlign:'center'}}>
          <div style={{fontSize:28,fontWeight:700,color:'var(--accent1)'}}>{statusCounts.total}</div>
          <div style={{fontSize:11,color:'var(--text2)'}}>Total Projects</div>
        </div>
        <div style={{...cardStyle,textAlign:'center'}}>
          <div style={{fontSize:28,fontWeight:700,color:'#00b894'}}>{statusCounts.inRoadmap}</div>
          <div style={{fontSize:11,color:'var(--text2)'}}>In Roadmap</div>
        </div>
        <div style={{...cardStyle,textAlign:'center'}}>
          <div style={{fontSize:28,fontWeight:700,color:'#0984e3'}}>{statusCounts.inProgress}</div>
          <div style={{fontSize:11,color:'var(--text2)'}}>In Progress</div>
        </div>
        <div style={{...cardStyle,textAlign:'center'}}>
          <div style={{fontSize:28,fontWeight:700,color:'#e67e22'}}>{statusCounts.inBacklog}</div>
          <div style={{fontSize:11,color:'var(--text2)'}}>In Backlog</div>
        </div>
      </div>

      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:16}}>
        {/* Capacity Utilization */}
        <div style={cardStyle}>
          <div style={headerStyle}>Capacity Utilization</div>
          <div style={{display:'flex',flexDirection:'column',gap:10}}>
            {DISCIPLINES.map(d => {
              const cap = capacity[d] || 0;
              const used = Math.round(bufferedUsed[d] * 10) / 10;
              const pct = cap > 0 ? Math.round((used / cap) * 100) : 0;
              return (
                <div key={d}>
                  <div style={{display:'flex',justifyContent:'space-between',marginBottom:3}}>
                    <span style={{fontSize:11,color:DISC_COLORS[d],fontWeight:600}}>{DISC_LABELS[d]}</span>
                    <span style={{fontSize:11,color:'var(--text2)'}}>{used} / {cap} SP ({pct}%)</span>
                  </div>
                  <div style={barStyle(used, cap, DISC_COLORS[d])}>
                    <div style={barFill(used, cap, DISC_COLORS[d])} />
                    <div style={barText}></div>
                  </div>
                </div>
              );
            })}
          </div>
          <div style={{marginTop:10,fontSize:10,color:'var(--text2)'}}>
            Buffer applied: {DISCIPLINES.map(d => `${DISC_LABELS[d]} ${buffer[d]}%`).join(', ')}
          </div>
        </div>

        {/* Demand vs Supply */}
        <div style={cardStyle}>
          <div style={headerStyle}>Demand vs Supply</div>
          <div style={{display:'flex',flexDirection:'column',gap:10}}>
            {DISCIPLINES.map(d => {
              const supply = capacity[d] || 0;
              const demand = Math.round(bufferedDemand[d] * 10) / 10;
              const gap = Math.round((supply - demand) * 10) / 10;
              const isOver = demand > supply;
              return (
                <div key={d}>
                  <div style={{display:'flex',justifyContent:'space-between',marginBottom:3}}>
                    <span style={{fontSize:11,color:DISC_COLORS[d],fontWeight:600}}>{DISC_LABELS[d]}</span>
                    <span style={{fontSize:11,color:isOver?'#e74c3c':'#00b894',fontWeight:600}}>
                      {isOver ? `Over by ${Math.abs(gap)} SP` : `${gap} SP available`}
                    </span>
                  </div>
                  <div style={{display:'flex',gap:4,alignItems:'center'}}>
                    <div style={{flex:1,...barStyle(demand, supply, DISC_COLORS[d])}}>
                      <div style={barFill(demand, supply, DISC_COLORS[d])} />
                    </div>
                    <span style={{fontSize:10,color:'var(--text2)',minWidth:60,textAlign:'right'}}>
                      {demand} / {supply}
                    </span>
                  </div>
                </div>
              );
            })}
          </div>
          <div style={{marginTop:10,fontSize:10,color:'var(--text2)'}}>
            Demand includes all projects (roadmap + backlog) with buffer
          </div>
        </div>

        {/* Per-Track Breakdown */}
        <div style={cardStyle}>
          <div style={headerStyle}>Per-Track Breakdown</div>
          <table style={{width:'100%',borderCollapse:'collapse',fontSize:11}}>
            <thead>
              <tr style={{borderBottom:'1px solid var(--border)'}}>
                <th style={{textAlign:'left',padding:'4px 8px',color:'var(--text2)'}}>Track</th>
                {DISCIPLINES.map(d => (
                  <th key={d} style={{textAlign:'center',padding:'4px 6px',color:DISC_COLORS[d]}}>{DISC_LABELS[d]}</th>
                ))}
                <th style={{textAlign:'center',padding:'4px 6px',color:'var(--text2)'}}>Util %</th>
              </tr>
            </thead>
            <tbody>
              {tracks.map(t => {
                const tc = trackCapacity[t.key] || {};
                const tu = trackUsed[t.key] || {};
                const totalCap = DISCIPLINES.reduce((s, d) => s + (tc[d] || 0), 0);
                const totalUsed = DISCIPLINES.reduce((s, d) => s + (tu[d] || 0), 0);
                const utilPct = totalCap > 0 ? Math.round((totalUsed / totalCap) * 100) : 0;
                return (
                  <tr key={t.key} style={{borderBottom:'1px solid var(--border)'}}>
                    <td style={{padding:'6px 8px',color:'var(--text1)',fontWeight:500}}>{t.label}</td>
                    {DISCIPLINES.map(d => (
                      <td key={d} style={{textAlign:'center',padding:'6px 6px',color: (tu[d]||0)>(tc[d]||0) ? '#e74c3c' : 'var(--text1)'}}>
                        {Math.round((tu[d]||0)*10)/10} / {tc[d]||0}
                      </td>
                    ))}
                    <td style={{textAlign:'center',padding:'6px 6px',fontWeight:600,color:utilPct>100?'#e74c3c':utilPct>80?'#e67e22':'#00b894'}}>
                      {utilPct}%
                    </td>
                  </tr>
                );
              })}
              <tr style={{fontWeight:600}}>
                <td style={{padding:'6px 8px',color:'var(--text2)'}}>Unallocated</td>
                {DISCIPLINES.map(d => (
                  <td key={d} style={{textAlign:'center',padding:'6px 6px',color:unallocated[d]<0?'#e74c3c':'var(--text2)'}}>
                    {unallocated[d]} SP
                  </td>
                ))}
                <td></td>
              </tr>
            </tbody>
          </table>
        </div>

        {/* Projects by Pillar */}
        <div style={cardStyle}>
          <div style={headerStyle}>Projects by Pillar</div>
          <div style={{display:'flex',flexDirection:'column',gap:6}}>
            {byPillar.map(([pillar, count]) => {
              const pct = currentData.length > 0 ? Math.round((count / currentData.length) * 100) : 0;
              const pColor = pillarColorMap[pillar] || 'var(--accent1)';
              return (
                <div key={pillar}>
                  <div style={{display:'flex',justifyContent:'space-between',marginBottom:2}}>
                    <span style={{fontSize:11,color:'var(--text1)'}}>{pillar}</span>
                    <span style={{fontSize:11,color:'var(--text2)'}}>{count} ({pct}%)</span>
                  </div>
                  <div style={{height:16,borderRadius:3,background:'var(--surface2)',overflow:'hidden'}}>
                    <div style={{height:'100%',width:`${pct}%`,background:pColor,borderRadius:3,transition:'width 0.3s ease'}} />
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {/* Projects by Impact */}
        <div style={cardStyle}>
          <div style={headerStyle}>Projects by Impact Size</div>
          <div style={{display:'flex',gap:8,alignItems:'flex-end',height:120}}>
            {byImpact.filter(([,c]) => c > 0).map(([size, count]) => {
              const maxCount = Math.max(...byImpact.map(([,c]) => c), 1);
              const heightPct = (count / maxCount) * 100;
              return (
                <div key={size} style={{flex:1,display:'flex',flexDirection:'column',alignItems:'center',gap:2}}>
                  <span style={{fontSize:10,color:'var(--text2)'}}>{count}</span>
                  <div style={{width:'100%',height:`${heightPct}%`,minHeight:4,background:'var(--accent1)',borderRadius:'3px 3px 0 0',transition:'height 0.3s ease'}} />
                  <span style={{fontSize:9,color:'var(--text2)'}}>{size}</span>
                </div>
              );
            })}
          </div>
        </div>

        {/* Size Map Reference */}
        <div style={cardStyle}>
          <div style={headerStyle}>Size Map (SP per Size)</div>
          <div style={{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:8}}>
            {Object.entries(sizeMap).map(([size, sp]) => (
              <div key={size} style={{textAlign:'center',padding:'8px 4px',background:'var(--surface2)',borderRadius:6}}>
                <div style={{fontSize:16,fontWeight:700,color:'var(--accent1)'}}>{sp}</div>
                <div style={{fontSize:10,color:'var(--text2)'}}>{size}</div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

function App({ onLogout, user: authUser }) {
  // Auth headers for API requests (audit logging) â€” reads from localStorage to avoid dependency issues
  // Unique ID for this browser tab â€” used to skip own WS broadcasts
  const wsIdRef = useRef(Math.random().toString(36).slice(2, 10));

  const getAuthHeaders = () => {
    const h = { 'Content-Type': 'application/json', 'X-WS-ID': wsIdRef.current };
    try {
      const stored = localStorage.getItem('cp_google_auth');
      if (stored) {
        const data = JSON.parse(stored);
        if (data.email) h['X-User-Email'] = data.email;
        if (data.name) h['X-User-Name'] = encodeURIComponent(data.name);
      }
    } catch {}
    return h;
  };

  const [activeVertical, setActiveVertical] = useState('growth');
  const [sizeMap, setSizeMap] = useState({...CP.DEFAULT_SIZE_MAP});
  const sizeMapRef = useRef(sizeMap);
  useEffect(() => { sizeMapRef.current = sizeMap; }, [sizeMap]);
  const [tooltip, setTooltip] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [activeTab, setActiveTab] = useState('planner');
  const [settingsTab, setSettingsTab] = useState(() => localStorage.getItem('cp_settings_tab') || 'none');
  const toggleSettingsTab = (tab) => {
    const next = settingsTab === tab ? 'none' : tab;
    setSettingsTab(next);
    localStorage.setItem('cp_settings_tab', next);
  };
  const [editingCell, setEditingCell] = useState(null);
  const [editValue, setEditValue] = useState('');
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [bulkField, setBulkField] = useState('pillar');
  const [bulkValue, setBulkValue] = useState('');
  const [saveStatus, setSaveStatus] = useState(null); // {type: 'ok'|'error', msg: '...'}
  // buffer is now stored inside verticalStates and persisted to the server
  const [splitModal, setSplitModal] = useState(null); // { projectId, projectName, existing: {...} }
  const [showTimeline, setShowTimeline] = useState(false);
  const [showSnapshots, setShowSnapshots] = useState(false);
  const [snapshots, setSnapshots] = useState([]);
  const [snapshotLoading, setSnapshotLoading] = useState(false);
  const [snapshotName, setSnapshotName] = useState('');
  const [snapshotDesc, setSnapshotDesc] = useState('');

  // Data loaded from API
  const [verticalData, setVerticalData] = useState({});
  const [verticalStates, setVerticalStates] = useState(() => {
    const state = {};
    const defaultTracks = {};
    for (const t of CP.DEFAULT_TRACK_CONFIG) defaultTracks[t.key] = [];
    for (const v of VERTICALS) state[v.key] = { capacity: {...DEFAULT_CAPACITY}, tracks: JSON.parse(JSON.stringify(defaultTracks)), trackCapacity: buildDefaultTrackCapacity(), splits: {}, timelineConfig: {...DEFAULT_TIMELINE_CONFIG}, milestones: [], timelineOverrides: {}, trackSubLaneCounts: {}, timelineLaneAssignments: {}, trackBlockOrder: {}, buffer: { backend: 0, frontend: 0, natives: 0, qa: 0 } };
    return state;
  });

  // â”€â”€ Undo / Redo â”€â”€
  const UNDO_MAX = 50;
  const undoStackRef = useRef([]); // [{ vertical, state }]
  const redoStackRef = useRef([]);
  const [undoLen, setUndoLen] = useState(0); // trigger re-render for button states
  const [redoLen, setRedoLen] = useState(0);
  const skipUndoRef = useRef(false); // skip undo capture during undo/redo ops

  const pushUndo = useCallback((vertical, stateBefore) => {
    if (skipUndoRef.current) return;
    undoStackRef.current = [...undoStackRef.current.slice(-(UNDO_MAX - 1)), { vertical, state: JSON.parse(JSON.stringify(stateBefore)) }];
    redoStackRef.current = []; // any new action clears redo
    setUndoLen(undoStackRef.current.length);
    setRedoLen(0);
  }, []);

  // Wrapper: captures undo snapshot before applying state mutation
  const setVerticalStatesWithUndo = useCallback((updater) => {
    setVerticalStates(prev => {
      const result = typeof updater === 'function' ? updater(prev) : updater;
      // Only push undo if the state actually changed and we're not in an undo/redo operation
      if (!skipUndoRef.current && result !== prev) {
        // Push the PREVIOUS state of the active vertical to undo stack
        const changedVertical = activeVertical;
        undoStackRef.current = [...undoStackRef.current.slice(-(UNDO_MAX - 1)), { vertical: changedVertical, state: JSON.parse(JSON.stringify(prev[changedVertical])) }];
        redoStackRef.current = [];
        setUndoLen(undoStackRef.current.length);
        setRedoLen(0);
      }
      return result;
    });
  }, [activeVertical]);

  // Load data from API
  // Track server timestamp per vertical for conflict-free merging
  const loadedAtRef = useRef({});
  // Track the last updatedAt we applied â€” used by poll to skip redundant fetches
  const lastAppliedUpdatedAt = useRef(null);

  // Track the last sizeMap received from server â€” used to distinguish user vs server changes
  const serverSizeMapRef = useRef(JSON.stringify(sizeMap));

  // Track the last state snapshot received from the server per vertical
  // Used by saveState to only send fields that actually changed locally
  const serverSnapshotRef = useRef({});

  const STATE_FIELD_NAMES = ['capacity', 'tracks', 'trackCapacity', 'splits', 'timelineConfig', 'milestones', 'timelineOverrides', 'trackSubLaneCounts', 'timelineLaneAssignments', 'trackBlockOrder', 'buffer', 'trackConfig'];

  const loadVerticalRef = useRef(null); // stable ref to avoid circular deps

  const applyStateFromServer = useCallback((key, stateRes) => {
    if (stateRes.sizeMap) {
      serverSizeMapRef.current = JSON.stringify(stateRes.sizeMap);
      if (JSON.stringify(stateRes.sizeMap) !== JSON.stringify(sizeMapRef.current)) {
        setSizeMap(stateRes.sizeMap);
      }
    }
    loadedAtRef.current[key] = stateRes._loadedAt || Date.now();

    // Build final state WITH defaults and migrations applied
    const tc = stateRes.trackConfig || undefined;
    const defaultTracks = {};
    for (const t of (tc || CP.DEFAULT_TRACK_CONFIG)) defaultTracks[t.key] = [];
    const newState = {
      capacity: stateRes.capacity || {...DEFAULT_CAPACITY},
      trackConfig: tc,
      tracks: migrateTracks(stateRes.tracks || defaultTracks, tc),
      trackCapacity: migrateTrackCapacity(stateRes.trackCapacity, tc),
      splits: stateRes.splits || {},
      timelineConfig: stateRes.timelineConfig || {...DEFAULT_TIMELINE_CONFIG},
      milestones: stateRes.milestones || [],
      timelineOverrides: stateRes.timelineOverrides || {},
      trackSubLaneCounts: stateRes.trackSubLaneCounts || {},
      timelineLaneAssignments: stateRes.timelineLaneAssignments || {},
      trackBlockOrder: stateRes.trackBlockOrder || {},
      buffer: stateRes.buffer || { backend: 0, frontend: 0, natives: 0, qa: 0 },
    };

    // Snapshot the FINAL migrated state (not raw server response) so diffs
    // only detect fields the user actually changed â€” not migration artifacts
    const snapshot = {};
    for (const f of STATE_FIELD_NAMES) {
      if (newState[f] !== undefined) snapshot[f] = JSON.stringify(newState[f]);
    }
    if (stateRes.sizeMap !== undefined) snapshot.sizeMap = JSON.stringify(stateRes.sizeMap);
    serverSnapshotRef.current[key] = snapshot;

    setVerticalStates(prev => ({ ...prev, [key]: newState }));
  }, []);

  const loadVertical = useCallback(async (key) => {
    try {
      // Use timestamp query param for bulletproof cache busting (Safari ignores cache:'no-store')
      const _t = Date.now();
      const [projRes, stateRes] = await Promise.all([
        fetch(`${API_URL}/api/verticals/${key}/projects?_t=${_t}`, { cache: 'no-store' }).then(r => r.json()),
        fetch(`${API_URL}/api/verticals/${key}/state?_t=${_t}`, { cache: 'no-store' }).then(r => r.json()),
      ]);
      setVerticalData(prev => ({ ...prev, [key]: projRes.projects || [] }));
      applyStateFromServer(key, stateRes);
    } catch (e) {
      console.error('Failed to load vertical:', key, e);
    }
  }, [applyStateFromServer]);
  loadVerticalRef.current = loadVertical;

  useEffect(() => {
    (async () => {
      setLoading(true);
      await loadVertical(activeVertical);
      setLoading(false);
    })();
  }, [activeVertical, loadVertical]);

  // Auto-save state to API (debounced)
  const saveTimer = useRef(null);
  const savingRef = useRef(false); // ref mirror of saving state for poll guard
  const deferredSyncRef = useRef(null); // tracks deferred sync requests while save is in-flight
  // For object fields (tracks, trackBlockOrder, etc.), deep-merge local changes
  // with the LATEST server state so we only overwrite sub-keys the user changed
  const deepMergeField = useCallback((key, fieldName, localValue, capturedSnapshotJson) => {
    if (typeof localValue !== 'object' || localValue === null || Array.isArray(localValue)) return localValue;
    const latestSnapshot = serverSnapshotRef.current[key] || {};
    const latestServerJson = latestSnapshot[fieldName];
    if (!latestServerJson) return localValue;
    const latestServer = JSON.parse(latestServerJson);
    const capturedServer = capturedSnapshotJson ? JSON.parse(capturedSnapshotJson) : latestServer;
    const { merged, overlaid, deleted } = CP.deepMergeObject(localValue, latestServer, capturedServer);
    if (overlaid.length > 0 || deleted.length > 0) {
      console.log('[deepMerge] ' + fieldName + ': overlaid=[' + overlaid.join(',') + '] deleted=[' + deleted.join(',') + ']');
    }
    return merged;
  }, []);

  const saveState = useCallback(async (key, state, capturedLoadedAt, capturedSnapshot) => {
    try {
      setSaving(true);
      savingRef.current = true;
      // Use capturedLoadedAt if provided (from debouncedSave), otherwise read current
      const loadedAt = capturedLoadedAt !== undefined ? capturedLoadedAt : (loadedAtRef.current[key] || 0);
      // Diff against the snapshot from CHANGE TIME (not current) to correctly identify
      // what the user actually changed, even if polls updated the snapshot since then.
      const snapshot = capturedSnapshot || serverSnapshotRef.current[key] || {};
      const fullState = { capacity: state.capacity, tracks: state.tracks, trackCapacity: state.trackCapacity, splits: state.splits, timelineConfig: state.timelineConfig, milestones: state.milestones, timelineOverrides: state.timelineOverrides, trackSubLaneCounts: state.trackSubLaneCounts, timelineLaneAssignments: state.timelineLaneAssignments, trackBlockOrder: state.trackBlockOrder, buffer: state.buffer, trackConfig: state.trackConfig };
      const payload = { _loadedAt: loadedAt };
      const changedFields = [];
      for (const f of STATE_FIELD_NAMES) {
        if (fullState[f] !== undefined && JSON.stringify(fullState[f]) !== snapshot[f]) {
          // Deep-merge object fields to only overwrite the sub-keys the user changed
          payload[f] = deepMergeField(key, f, fullState[f], snapshot[f]);
          changedFields.push(f);
        }
      }
      // Always include sizeMap if it changed
      const currentSizeMap = sizeMapRef.current;
      if (JSON.stringify(currentSizeMap) !== snapshot.sizeMap) {
        payload.sizeMap = currentSizeMap;
        changedFields.push('sizeMap');
      }
      if (changedFields.length === 0) {
        console.log('[save] no fields changed, skipping');
        return;
      }
      console.log('[save] saving changed fields:', changedFields.join(', '));
      const resp = await fetch(`${API_URL}/api/verticals/${key}/state`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify(payload),
      });
      if (!resp.ok) {
        console.error('[save] server error:', resp.status, await resp.text());
      } else {
        const result = await resp.json();
        if (result.mergedState) {
          loadedAtRef.current[key] = result.mergedState._loadedAt || Date.now();
          // Update lastAppliedUpdatedAt so poll doesn't re-fetch what we just saved
          if (result.mergedState.updatedAt) lastAppliedUpdatedAt.current = result.mergedState.updatedAt;
          // Always update serverSnapshotRef with MIGRATED values so subsequent
          // saves diff correctly (matching what local state actually stores)
          const ms = result.mergedState;
          const snapshot = {};
          const msTc = ms.trackConfig || undefined;
          const msDefaultTracks = {};
          for (const t of (msTc || CP.DEFAULT_TRACK_CONFIG)) msDefaultTracks[t.key] = [];
          const migratedForSnapshot = {
            capacity: ms.capacity || {...DEFAULT_CAPACITY},
            trackConfig: msTc,
            tracks: migrateTracks(ms.tracks || msDefaultTracks, msTc),
            trackCapacity: migrateTrackCapacity(ms.trackCapacity, msTc),
            splits: ms.splits || {},
            timelineConfig: ms.timelineConfig || {...DEFAULT_TIMELINE_CONFIG},
            milestones: ms.milestones || [],
            timelineOverrides: ms.timelineOverrides || {},
            trackSubLaneCounts: ms.trackSubLaneCounts || {},
            timelineLaneAssignments: ms.timelineLaneAssignments || {},
            trackBlockOrder: ms.trackBlockOrder || {},
            buffer: ms.buffer || { backend: 0, frontend: 0, natives: 0, qa: 0 },
          };
          for (const f of STATE_FIELD_NAMES) {
            if (migratedForSnapshot[f] !== undefined) snapshot[f] = JSON.stringify(migratedForSnapshot[f]);
          }
          if (ms.sizeMap !== undefined) snapshot.sizeMap = JSON.stringify(ms.sizeMap);
          serverSnapshotRef.current[key] = snapshot;
          if (result.conflicts && result.conflicts.length > 0) {
            console.log('[merge] Server resolved conflicts on:', result.conflicts.join(', '));
            applyStateFromServer(key, result.mergedState);
          }
        }
      }
    } catch (e) {
      console.error('Failed to save state:', e);
    } finally {
      setSaving(false);
      savingRef.current = false;
      // If a sync was deferred while we were saving, run it now
      if (deferredSyncRef.current) {
        const reason = deferredSyncRef.current;
        deferredSyncRef.current = null;
        console.log('[sync] running deferred sync:', reason);
        if (loadVerticalRef.current) loadVerticalRef.current(key).catch(e => console.log('[sync] deferred sync error:', e.message));
      }
    }
  }, [applyStateFromServer, deepMergeField]);

  const pendingSave = useRef(null);
  const debouncedSave = useCallback((key, state) => {
    if (saveTimer.current) clearTimeout(saveTimer.current);
    // Capture _loadedAt and server snapshot NOW so the diff is against
    // what the server had at change time, not what polls might update it to later
    const capturedLoadedAt = loadedAtRef.current[key] || 0;
    const capturedSnapshot = { ...(serverSnapshotRef.current[key] || {}) };
    pendingSave.current = { key, state };
    saveTimer.current = setTimeout(() => {
      saveTimer.current = null;
      pendingSave.current = null;
      saveState(key, state, capturedLoadedAt, capturedSnapshot);
    }, 800);
  }, [saveState]);

  // â”€â”€ Undo / Redo handlers â”€â”€
  const handleUndo = useCallback(() => {
    if (undoStackRef.current.length === 0) return;
    const entry = undoStackRef.current.pop();
    // Push current state to redo stack
    setVerticalStates(prev => {
      redoStackRef.current.push({ vertical: entry.vertical, state: JSON.parse(JSON.stringify(prev[entry.vertical])) });
      setRedoLen(redoStackRef.current.length);
      setUndoLen(undoStackRef.current.length);
      const newState = { ...prev, [entry.vertical]: entry.state };
      // Save immediately (skip undo capture)
      skipUndoRef.current = true;
      saveState(entry.vertical, entry.state);
      setTimeout(() => { skipUndoRef.current = false; }, 0);
      return newState;
    });
  }, [saveState]);

  const handleRedo = useCallback(() => {
    if (redoStackRef.current.length === 0) return;
    const entry = redoStackRef.current.pop();
    setVerticalStates(prev => {
      undoStackRef.current.push({ vertical: entry.vertical, state: JSON.parse(JSON.stringify(prev[entry.vertical])) });
      setUndoLen(undoStackRef.current.length);
      setRedoLen(redoStackRef.current.length);
      const newState = { ...prev, [entry.vertical]: entry.state };
      skipUndoRef.current = true;
      saveState(entry.vertical, entry.state);
      setTimeout(() => { skipUndoRef.current = false; }, 0);
      return newState;
    });
  }, [saveState]);

  // Keyboard shortcuts for undo/redo
  useEffect(() => {
    const onKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
        e.preventDefault();
        handleRedo();
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        handleRedo();
      }
    };
    window.addEventListener('keydown', onKeyDown);
    return () => window.removeEventListener('keydown', onKeyDown);
  }, [handleUndo, handleRedo]);

  // Flush pending saves before page unload
  useEffect(() => {
    const onBeforeUnload = () => {
      if (pendingSave.current) {
        const { key, state } = pendingSave.current;
        const beaconPayload = { capacity: state.capacity, tracks: state.tracks, trackCapacity: state.trackCapacity, splits: state.splits, timelineConfig: state.timelineConfig, milestones: state.milestones, timelineOverrides: state.timelineOverrides, trackSubLaneCounts: state.trackSubLaneCounts, timelineLaneAssignments: state.timelineLaneAssignments, trackBlockOrder: state.trackBlockOrder, sizeMap: sizeMapRef.current, buffer: state.buffer, _loadedAt: loadedAtRef.current[key] || 0 };
        try { const u = JSON.parse(localStorage.getItem('cp_google_auth') || '{}'); if (u.email) { beaconPayload._userEmail = u.email; beaconPayload._userName = u.name; } } catch {}
        navigator.sendBeacon(`${API_URL}/api/verticals/${key}/state`, new Blob([JSON.stringify(beaconPayload)], { type: 'application/json' }));
        pendingSave.current = null;
      }
    };
    window.addEventListener('beforeunload', onBeforeUnload);
    return () => window.removeEventListener('beforeunload', onBeforeUnload);
  }, []);

  // â”€â”€ WebSocket + fallback poll for live multi-user sync â”€â”€
  const wsRef = useRef(null);
  const FALLBACK_POLL_INTERVAL = 30000; // Slow fallback only

  useEffect(() => {
    if (activeTab !== 'planner') return;
    let cancelled = false;

    // â”€â”€ Fetch helper (used by both WS and poll) â”€â”€
    const fetchAndApply = async (reason) => {
      if (dragItem.current) return;
      // Cancel any pending debounced save â€” the server has newer data
      if (saveTimer.current) {
        clearTimeout(saveTimer.current);
        saveTimer.current = null;
        pendingSave.current = null;
        console.log('[sync] cancelled pending debounced save (server has newer data)');
      }
      if (savingRef.current) {
        console.log('[sync] ' + reason + ' but save in-flight, deferring');
        deferredSyncRef.current = reason;
        return;
      }
      try {
        console.log('[sync] ' + reason + ' â€” refreshing');
        await loadVertical(activeVertical);
      } catch (e) {
        console.log('[sync] error:', e.message);
      }
    };

    // â”€â”€ WebSocket connection â”€â”€
    const wsUrl = API_URL.replace(/^http/, 'ws') + '/ws';
    let ws = null;
    let reconnectTimer = null;

    const connectWs = () => {
      if (cancelled) return;
      try {
        ws = new WebSocket(wsUrl);
        wsRef.current = ws;

        ws.onopen = () => {
          console.log('[ws] Connected');
          ws.send(JSON.stringify({ type: 'subscribe', vertical: activeVertical }));
        };

        ws.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            // Keepalive â€” respond to server pings to keep connection alive
            if (msg.type === 'ping') {
              if (ws.readyState === 1) ws.send(JSON.stringify({ type: 'pong' }));
              return;
            }
            if (msg.type === 'update' && msg.vertical === activeVertical) {
              // Skip updates we triggered ourselves
              if (msg.senderId === wsIdRef.current) return;
              console.log('[ws] Received full state update from another user');
              // Cancel any pending debounced save â€” server has newer data
              if (saveTimer.current) {
                clearTimeout(saveTimer.current);
                saveTimer.current = null;
                pendingSave.current = null;
                console.log('[ws] cancelled pending debounced save');
              }
              if (savingRef.current) {
                console.log('[ws] save in-flight, deferring sync');
                deferredSyncRef.current = 'ws update (deferred)';
                return;
              }
              // Apply state DIRECTLY from the WS message â€” no HTTP fetch needed!
              if (msg.state) {
                applyStateFromServer(activeVertical, msg.state);
                if (msg.state.updatedAt) lastAppliedUpdatedAt.current = msg.state.updatedAt;
              }
              if (msg.projects) {
                setVerticalData(prev => ({ ...prev, [activeVertical]: msg.projects }));
              }
            }
          } catch (e) {
            console.log('[ws] message parse error:', e.message);
          }
        };

        ws.onclose = () => {
          console.log('[ws] Disconnected, reconnecting in 3s');
          wsRef.current = null;
          if (!cancelled) reconnectTimer = setTimeout(connectWs, 3000);
        };

        ws.onerror = () => {
          // onclose will fire after this
        };
      } catch (e) {
        console.log('[ws] Connection failed:', e.message);
        if (!cancelled) reconnectTimer = setTimeout(connectWs, 5000);
      }
    };

    connectWs();

    // â”€â”€ Slow fallback poll (in case WS is down) â”€â”€
    const fallbackPoll = async () => {
      if (cancelled || dragItem.current || savingRef.current) return;
      try {
        const _t = Date.now();
        const pollRes = await fetch(`${API_URL}/api/verticals/${activeVertical}/poll?_t=${_t}`, { cache: 'no-store' }).then(r => r.json());
        if (pollRes.updatedAt && pollRes.updatedAt !== lastAppliedUpdatedAt.current) {
          await loadVertical(activeVertical);
          lastAppliedUpdatedAt.current = pollRes.updatedAt;
        }
      } catch (e) {}
    };
    const fallbackInterval = setInterval(fallbackPoll, FALLBACK_POLL_INTERVAL);

    // Immediately sync when tab becomes visible
    const onVisibilityChange = () => {
      if (!document.hidden && !cancelled) {
        fetchAndApply('tab visible');
        // Re-subscribe in case WS reconnected to a different vertical
        if (wsRef.current && wsRef.current.readyState === 1) {
          wsRef.current.send(JSON.stringify({ type: 'subscribe', vertical: activeVertical }));
        }
      }
    };
    document.addEventListener('visibilitychange', onVisibilityChange);

    // Initial load
    fetchAndApply('initial');

    return () => {
      cancelled = true;
      clearInterval(fallbackInterval);
      clearTimeout(reconnectTimer);
      if (ws) ws.close();
      wsRef.current = null;
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, [activeTab, activeVertical, loadVertical]);

  // Save sizeMap when USER changes it (skip if value matches what server sent)
  const sizeMapInitialized = useRef(false);
  useEffect(() => {
    if (!sizeMapInitialized.current) { sizeMapInitialized.current = true; return; }
    // If sizeMap matches what the server last sent, this was a poll/merge update â€” don't save
    if (JSON.stringify(sizeMap) === serverSizeMapRef.current) return;
    if (activeVertical && verticalStates[activeVertical]) {
      debouncedSave(activeVertical, verticalStates[activeVertical]);
    }
  }, [sizeMap]);

  // Save projects to API
  const projectSaveTimer = useRef(null);
  const saveStatusTimer = useRef(null);
  const saveProjects = useCallback(async (key, projects) => {
    try {
      setSaving(true);
      setSaveStatus(null);
      const url = `${API_URL}/api/verticals/${encodeURIComponent(key)}/projects`;
      const res = await fetch(url, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ projects }),
      });
      let data;
      try { data = await res.json(); } catch (jsonErr) {
        const text = await res.text().catch(() => '');
        setSaveStatus({ type: 'error', msg: `Save failed (${res.status}): not JSON - ${text.slice(0,100)}` });
        return;
      }
      if (!res.ok) {
        setSaveStatus({ type: 'error', msg: `Save failed: ${data.error || res.status}` });
        console.error('Save projects failed:', data);
      } else {
        setSaveStatus({ type: 'ok', msg: `Saved ${data.projectCount} projects` });
        if (saveStatusTimer.current) clearTimeout(saveStatusTimer.current);
        saveStatusTimer.current = setTimeout(() => setSaveStatus(null), 3000);
      }
    } catch (e) {
      setSaveStatus({ type: 'error', msg: `Save error: ${e.message}` });
      console.error('Save projects error:', e);
    } finally {
      setSaving(false);
    }
  }, []);

  const debouncedSaveProjects = useCallback((key, projects) => {
    if (projectSaveTimer.current) clearTimeout(projectSaveTimer.current);
    projectSaveTimer.current = setTimeout(() => saveProjects(key, projects), 800);
  }, [saveProjects]);

  // â”€â”€ Snapshot handlers â”€â”€
  const loadSnapshots = useCallback(async () => {
    try {
      setSnapshotLoading(true);
      const res = await fetch(`${API_URL}/api/verticals/${activeVertical}/snapshots`, { headers: getAuthHeaders() });
      const data = await res.json();
      setSnapshots(data.snapshots || []);
    } catch (e) { console.error('Load snapshots error:', e); }
    finally { setSnapshotLoading(false); }
  }, [activeVertical]);

  const saveSnapshot = useCallback(async () => {
    if (!snapshotName.trim()) return;
    try {
      setSnapshotLoading(true);
      const res = await fetch(`${API_URL}/api/verticals/${activeVertical}/snapshots`, {
        method: 'POST', headers: getAuthHeaders(),
        body: JSON.stringify({ name: snapshotName.trim(), description: snapshotDesc.trim() }),
      });
      if (res.ok) {
        setSnapshotName(''); setSnapshotDesc('');
        await loadSnapshots();
      }
    } catch (e) { console.error('Save snapshot error:', e); }
    finally { setSnapshotLoading(false); }
  }, [activeVertical, snapshotName, snapshotDesc, loadSnapshots]);

  const restoreSnapshot = useCallback(async (id, name) => {
    if (!confirm(`Restore snapshot "${name}"? This will overwrite the current state and projects.`)) return;
    try {
      setSnapshotLoading(true);
      const res = await fetch(`${API_URL}/api/verticals/${activeVertical}/snapshots/${id}/restore`, {
        method: 'POST', headers: getAuthHeaders(),
      });
      if (res.ok) {
        const data = await res.json();
        // Apply restored state
        if (data.state) applyStateFromServer(activeVertical, data.state);
        if (data.projects) setVerticalData(prev => ({ ...prev, [activeVertical]: data.projects }));
        setShowSnapshots(false);
      }
    } catch (e) { console.error('Restore snapshot error:', e); }
    finally { setSnapshotLoading(false); }
  }, [activeVertical, applyStateFromServer]);

  const deleteSnapshot = useCallback(async (id, name) => {
    if (!confirm(`Delete snapshot "${name}"?`)) return;
    try {
      setSnapshotLoading(true);
      await fetch(`${API_URL}/api/verticals/${activeVertical}/snapshots/${id}`, {
        method: 'DELETE', headers: getAuthHeaders(),
      });
      await loadSnapshots();
    } catch (e) { console.error('Delete snapshot error:', e); }
    finally { setSnapshotLoading(false); }
  }, [activeVertical, loadSnapshots]);

  const currentData = verticalData[activeVertical] || [];
  const currentState = verticalStates[activeVertical] || { capacity: {...DEFAULT_CAPACITY}, tracks: buildDefaultTrackCapacity(), trackCapacity: buildDefaultTrackCapacity(), splits: {}, timelineConfig: {...DEFAULT_TIMELINE_CONFIG}, milestones: [], timelineOverrides: {}, trackSubLaneCounts: {}, timelineLaneAssignments: {}, trackBlockOrder: {}, buffer: { backend: 0, frontend: 0, natives: 0, qa: 0 } };

  // Dynamic pillar colors â€” derived from project data
  const pillarColorMap = useMemo(() => CP.buildPillarColorMap(currentData), [currentData]);

  // Dynamic track configuration â€” derived from state, defaults to 3 legacy tracks
  const currentTrackConfig = currentState.trackConfig || CP.DEFAULT_TRACK_CONFIG;
  const TRACKS = useMemo(() => currentTrackConfig.map(t => ({
    key: t.key, label: t.label,
    gradient: `linear-gradient(180deg, ${t.color}cc, ${t.color}88)`,
    borderColor: (() => { const r = parseInt(t.color.slice(1,3),16), g = parseInt(t.color.slice(3,5),16), b = parseInt(t.color.slice(5,7),16); return `rgba(${r},${g},${b},0.4)`; })(),
  })), [currentTrackConfig]);
  const trackKeys = useMemo(() => TRACKS.map(t => t.key), [TRACKS]);

  const capacity = currentState.capacity;
  const tracks = currentState.tracks;
  const trackCapacity = currentState.trackCapacity || buildDefaultTrackCapacity(currentTrackConfig);
  const splits = currentState.splits || {};
  const timelineConfig = currentState.timelineConfig || {...DEFAULT_TIMELINE_CONFIG};
  const milestones = currentState.milestones || [];
  const timelineOverrides = currentState.timelineOverrides || {};
  const trackSubLaneCounts = currentState.trackSubLaneCounts || {};
  const timelineLaneAssignments = currentState.timelineLaneAssignments || {};
  const trackBlockOrder = currentState.trackBlockOrder || {};
  const buffer = currentState.buffer || { backend: 0, frontend: 0, natives: 0, qa: 0 };

  const updateBuffer = useCallback((discipline, delta) => {
    setVerticalStatesWithUndo(prev => {
      const buf = { ...(prev[activeVertical].buffer || { backend: 0, frontend: 0, natives: 0, qa: 0 }) };
      buf[discipline] = (buf[discipline] || 0) + delta;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], buffer: buf } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const roadmapIds = useMemo(() => {
    const s = new Set();
    for (const arr of Object.values(tracks)) {
      if (Array.isArray(arr)) arr.forEach(id => s.add(id));
    }
    return s;
  }, [tracks]);

  const setCapacity = (updater) => {
    setVerticalStatesWithUndo(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          capacity: typeof updater === 'function' ? updater(prev[activeVertical].capacity) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };
  const updateTrackCapacity = (trackKey, discipline, value) => {
    setVerticalStatesWithUndo(prev => {
      const prevTC = prev[activeVertical].trackCapacity || buildDefaultTrackCapacity(prev[activeVertical].trackConfig);
      const newTC = { ...prevTC, [trackKey]: { ...prevTC[trackKey], [discipline]: value } };
      // Validate: sum across tracks for this discipline can't exceed total capacity
      const sum = Object.values(newTC).reduce((s, tc) => s + (tc[discipline] || 0), 0);
      if (sum > prev[activeVertical].capacity[discipline]) return prev; // block the change
      const newState = {
        ...prev,
        [activeVertical]: { ...prev[activeVertical], trackCapacity: newTC }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  // â”€â”€ Track Management (add/remove/rename/recolor) â”€â”€
  const TRACK_COLOR_PALETTE = ['#6c5ce7','#0984e3','#e17055','#a29bfe','#00cec9','#fd79a8','#ffeaa7','#55efc4','#74b9ff','#b2bec3'];

  const addTrack = useCallback(() => {
    const name = prompt('Track name:');
    if (!name || !name.trim()) return;
    const label = name.trim();
    const key = CP.generateTrackKey(label);
    if (!key) { alert('Invalid track name.'); return; }
    const cfg = currentTrackConfig;
    if (cfg.some(t => t.key === key)) { alert('A track with a similar name already exists.'); return; }
    const usedColors = new Set(cfg.map(t => t.color));
    const newColor = TRACK_COLOR_PALETTE.find(c => !usedColors.has(c)) || '#6c5ce7';
    const newConfig = [...cfg, { key, label, color: newColor }];
    setVerticalStatesWithUndo(prev => {
      const vs = prev[activeVertical];
      const newState = { ...prev, [activeVertical]: {
        ...vs,
        trackConfig: newConfig,
        tracks: { ...vs.tracks, [key]: [] },
        trackCapacity: { ...vs.trackCapacity, [key]: { backend: 0, frontend: 0, natives: 0, qa: 0 } },
        trackBlockOrder: { ...vs.trackBlockOrder, [key]: [] },
      }};
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [currentTrackConfig, activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const removeTrack = useCallback((trackIndex) => {
    const track = currentTrackConfig[trackIndex];
    if (!track) return;
    const projectsInTrack = (currentState.tracks[track.key] || []).length;
    const msg = projectsInTrack > 0
      ? `Remove track "${track.label}"? ${projectsInTrack} project(s) will move to the backlog.`
      : `Remove track "${track.label}"?`;
    if (!confirm(msg)) return;
    const newConfig = currentTrackConfig.filter((_, i) => i !== trackIndex);
    setVerticalStatesWithUndo(prev => {
      const vs = prev[activeVertical];
      const newTracks = { ...vs.tracks }; delete newTracks[track.key];
      const newTC = { ...vs.trackCapacity }; delete newTC[track.key];
      const newTBO = { ...vs.trackBlockOrder }; delete newTBO[track.key];
      const newSLC = { ...vs.trackSubLaneCounts }; delete newSLC[track.key];
      // Clean splits targeting removed track
      const newSplits = {};
      for (const [pid, ts] of Object.entries(vs.splits || {})) {
        const cleaned = { ...ts }; delete cleaned[track.key];
        if (Object.keys(cleaned).length > 0) newSplits[pid] = cleaned;
      }
      // Clean timeline data
      const prefix = track.key + ':';
      const newTO = {}; for (const [k, v] of Object.entries(vs.timelineOverrides || {})) { if (!k.startsWith(prefix)) newTO[k] = v; }
      const newTLA = {}; for (const [k, v] of Object.entries(vs.timelineLaneAssignments || {})) { if (!k.startsWith(prefix)) newTLA[k] = v; }
      const newState = { ...prev, [activeVertical]: {
        ...vs, trackConfig: newConfig, tracks: newTracks, trackCapacity: newTC,
        trackBlockOrder: newTBO, trackSubLaneCounts: newSLC, splits: newSplits,
        timelineOverrides: newTO, timelineLaneAssignments: newTLA,
      }};
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [currentTrackConfig, currentState, activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const updateTrackLabel = useCallback((trackIndex, newLabel) => {
    const newConfig = currentTrackConfig.map((t, i) => i === trackIndex ? { ...t, label: newLabel } : t);
    setVerticalStatesWithUndo(prev => {
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackConfig: newConfig }};
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [currentTrackConfig, activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const updateTrackColor = useCallback((trackIndex, newColor) => {
    const newConfig = currentTrackConfig.map((t, i) => i === trackIndex ? { ...t, color: newColor } : t);
    setVerticalStatesWithUndo(prev => {
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackConfig: newConfig }};
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [currentTrackConfig, activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const saveSplit = (projectId, targetTrack, sizings) => {
    setVerticalStatesWithUndo(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (!prevSplits[projectId]) prevSplits[projectId] = {};
      prevSplits[projectId] = { ...prevSplits[projectId], [targetTrack]: sizings };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const removeSplit = (projectId, targetTrack) => {
    setVerticalStatesWithUndo(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (prevSplits[projectId]) {
        const updated = { ...prevSplits[projectId] };
        delete updated[targetTrack];
        if (Object.keys(updated).length === 0) delete prevSplits[projectId];
        else prevSplits[projectId] = updated;
      }
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const setTracks = (updater) => {
    setVerticalStatesWithUndo(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          tracks: typeof updater === 'function' ? updater(prev[activeVertical].tracks) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const [search, setSearch] = useState('');
  const [filters, setFilters] = useState({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
  const [openFilter, setOpenFilter] = useState(null);
  const [sortBy, setSortBy] = useState('impact');
  const [colorBy, setColorBy] = useState('pillar');
  const [backlogView, setBacklogView] = useState('blocks');
  const dragItem = useRef(null);
  const dragSource = useRef(null);

  const handleVerticalChange = (key) => {
    setActiveVertical(key);
    setSearch('');
    setFilters({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
    setLoading(true);
  };

  const sizeToSprints = useCallback((size) => CP.sizeToSprints(size, sizeMap), [sizeMap]);

  const projectSprints = useCallback((p) => CP.computeProjectSprints(p, sizeMap), [sizeMap]);

  const uniqueValues = useMemo(() => ({
    pillar: [...new Set(currentData.map(p => p.pillar).filter(Boolean))].sort(),
    market: [...new Set(currentData.map(p => p.targetMarket).filter(Boolean))].sort(),
    epic: [...new Set(currentData.map(p => p.masterEpic).filter(Boolean))].sort(),
    kpi: [...new Set(currentData.map(p => p.targetKPI).filter(Boolean))].sort(),
    impact: ['XS','S','M','L','XL','XXL','XXXL'],
  }), [currentData]);

  const filterProjects = useCallback((projects) => CP.filterProjects(projects, search, filters), [search, filters]);

  const sortProjects = useCallback((projects) => CP.sortProjects(projects, sortBy, sizeMap), [sortBy, sizeMap]);

  const roadmapProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);
  const backlogProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => !roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);

  const usedCapacity = useMemo(() => CP.computeUsedCapacity(currentData, roadmapIds, sizeMap), [roadmapIds, sizeMap, currentData]);
  const bufferedUsed = useMemo(() => CP.computeBuffered(usedCapacity, buffer), [usedCapacity, buffer]);

  const totalCapacity = capacity.backend + capacity.frontend + capacity.natives + capacity.qa;
  const totalUsed = bufferedUsed.backend + bufferedUsed.frontend + bufferedUsed.natives + bufferedUsed.qa;

  const totalDemand = useMemo(() => CP.computeTotalDemand(currentData, sizeMap), [currentData, sizeMap]);
  const bufferedDemand = useMemo(() => CP.computeBuffered(totalDemand, buffer), [totalDemand, buffer]);

  const removeFromTracks = (trks, id) => CP.removeFromTracks(trks, id);

  const moveToTrack = (id, trackKey, insertIndex) => setTracks(prev => {
    const n = removeFromTracks(prev, id);
    if (insertIndex !== undefined) n[trackKey].splice(insertIndex, 0, id);
    else n[trackKey].push(id);
    return n;
  });
  const moveToBacklog = (id) => setTracks(prev => removeFromTracks(prev, id));

  const handleDragStart = (e, id, source) => {
    dragItem.current = id; dragSource.current = source;
    e.dataTransfer.effectAllowed = 'move';
    setTimeout(() => e.target.classList.add('dragging'), 0);
  };
  const handleDragEnd = (e) => {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
  };
  const handleDragOver = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
  const handleDragEnter = (e) => { e.currentTarget.classList.add('drag-over'); };
  const handleDragLeave = (e) => { if (!e.currentTarget.contains(e.relatedTarget)) e.currentTarget.classList.remove('drag-over'); };

  const handleDropOnTrack = (e, trackKey) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current) return;
    const draggedId = dragItem.current;
    const isGhostDrag = String(draggedId).startsWith('ghost:');

    // Determine drop position: before first block or after last block
    const blocks = e.currentTarget.querySelectorAll('.project-block');
    let insertIdx;
    if (blocks.length === 0) {
      insertIdx = 0;
    } else {
      const firstRect = blocks[0].getBoundingClientRect();
      if (e.clientX < firstRect.left + firstRect.width / 2) {
        insertIdx = 0; // dropped before the first block
      } else {
        insertIdx = undefined; // append to end
      }
    }

    // Move in tracks array (only for real projects, not ghosts)
    if (!isGhostDrag) {
      moveToTrack(draggedId, trackKey, insertIdx);
    }

    // Update trackBlockOrder so visual order persists (works for both real and ghost blocks)
    const combined = getCombinedOrder(trackKey);
    const dragKey = String(draggedId);
    const filtered = combined.filter(k => k !== dragKey);
    if (insertIdx === 0) {
      filtered.unshift(dragKey); // beginning
    } else {
      filtered.push(dragKey); // end
    }
    saveBlockOrder(trackKey, filtered);
  };

  // Build combined block order for a track (regular + ghosts)
  const getCombinedOrder = useCallback((trackKey) => {
    const realIds = (tracks[trackKey] || []).map(id => String(id));
    const ghostIds = (ghostsByTrack[trackKey] || []).map(g => `ghost:${g.project.id}`);
    const all = [...realIds, ...ghostIds];
    const order = trackBlockOrder[trackKey];
    if (order && order.length > 0) {
      all.sort((a, b) => {
        const aIdx = order.indexOf(a);
        const bIdx = order.indexOf(b);
        if (aIdx === -1 && bIdx === -1) return 0;
        if (aIdx === -1) return 1;
        if (bIdx === -1) return 1;
        return aIdx - bIdx;
      });
    }
    return all;
  }, [tracks, ghostsByTrack, trackBlockOrder]);

  const saveBlockOrder = useCallback((trackKey, newOrder) => {
    setVerticalStatesWithUndo(prev => {
      const orders = { ...(prev[activeVertical].trackBlockOrder || {}) };
      orders[trackKey] = newOrder;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackBlockOrder: orders } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const handleDropOnBlock = (e, trackKey, blockId, blockIndex) => {
    e.preventDefault(); e.stopPropagation();
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current || dragItem.current === blockId) return;
    const draggedId = dragItem.current;
    const isGhostDrag = String(draggedId).startsWith('ghost:');

    if (!isGhostDrag) {
      // Regular project drag â€” still use moveToTrack for cross-track moves
      const rect = e.currentTarget.getBoundingClientRect();
      const dropAfter = (e.clientX - rect.left) > rect.width / 2;
      const insertIdx = dropAfter ? blockIndex + 1 : blockIndex;
      const currentTrackIds = tracks[trackKey] || [];
      const currentIdx = currentTrackIds.indexOf(draggedId);
      let adjustedIdx = insertIdx;
      if (currentIdx !== -1 && currentIdx < insertIdx) adjustedIdx = insertIdx - 1;
      moveToTrack(draggedId, trackKey, adjustedIdx);
    }

    // Update combined block order for visual ordering
    const combined = getCombinedOrder(trackKey);
    const dragKey = isGhostDrag ? String(draggedId) : String(draggedId);
    const filtered = combined.filter(k => k !== dragKey);
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    const targetKey = String(blockId).startsWith('ghost:') ? String(blockId) : String(blockId);
    const targetIdx = filtered.indexOf(targetKey);
    const insertAt = targetIdx === -1 ? filtered.length : (dropAfter ? targetIdx + 1 : targetIdx);
    filtered.splice(insertAt, 0, dragKey);
    saveBlockOrder(trackKey, filtered);
  };

  const handleDragOverBlock = (e, trackKey, blockId) => {
    e.preventDefault(); e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    if (!dragItem.current || dragItem.current === blockId) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    // Show drop indicator
    const existing = e.currentTarget.parentElement.querySelectorAll('.drop-indicator');
    existing.forEach(el => el.remove());
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    if (dropAfter) {
      e.currentTarget.after(indicator);
    } else {
      e.currentTarget.before(indicator);
    }
  };

  const handleDropOnBacklog = (e) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    if (dragItem.current && dragSource.current !== 'backlog') moveToBacklog(dragItem.current);
  };

  const toggleFilter = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: prev[key].includes(value) ? prev[key].filter(v => v !== value) : [...prev[key], value] }));
  };
  const activeFilterCount = Object.values(filters).reduce((s, a) => s + a.length, 0);

  useEffect(() => {
    const handler = (e) => { if (!e.target.closest('.filter-group')) setOpenFilter(null); };
    document.addEventListener('click', handler);
    return () => document.removeEventListener('click', handler);
  }, []);

  const getBlockWidth = (p) => {
    const sprints = projectSprints(p).total;
    return Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, sprints * PX_PER_SPRINT));
  };

  const handleMouseEnter = (e, p) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setTooltip({ p, x: rect.right + 8, y: rect.top });
  };
  const handleMouseLeave = () => setTooltip(null);

  const renderCapBar = (label, used, total) => {
    const pct = total > 0 ? Math.round((used / total) * 100) : 0;
    const barColor = getCapColor(pct);
    return (
      <div className="cap-bar-container">
        <div className="cap-bar-label">
          <span>{label}</span>
          <span style={{color: barColor, fontWeight:700}}>{used}/{total} ({pct}%)</span>
        </div>
        <div className="cap-bar-track">
          <div className="cap-bar-fill" style={{ width: `${Math.min(pct,100)}%`, background: barColor }}>
            {pct > 15 ? `${pct}%` : ''}
          </div>
        </div>
      </div>
    );
  };

  // Project lookup by ID â€” must be before ghostsByTrack which depends on it
  const projectById = useMemo(() => {
    const m = {};
    for (const p of currentData) m[p.id] = p;
    return m;
  }, [currentData]);

  const effectiveSprints = useCallback((p) => CP.computeEffectiveSprints(p, splits, sizeMap), [splits, sizeMap]);

  // Find which track a project primarily lives in
  const getProjectHomeTrack = useCallback((projectId) => {
    for (const t of TRACKS) {
      if ((tracks[t.key] || []).includes(projectId)) return t;
    }
    return null;
  }, [tracks]);

  const renderBlock = (p, lane, trackKey, blockIndex) => {
    const s = projectSprints(p);
    const eff = effectiveSprints(p);
    const hasSplits = splits[p.id] && Object.keys(splits[p.id]).length > 0;
    const isTrack = lane === 'roadmap' && trackKey;
    // Use effective width for blocks in tracks that have splits
    const displaySprints = (isTrack && hasSplits) ? eff : s;
    const w = (isTrack && hasSplits)
      ? Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, eff.total * PX_PER_SPRINT))
      : getBlockWidth(p);
    const overflowDisciplines = (isTrack && trackOverflow[trackKey] && trackOverflow[trackKey][p.id]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    return (
      <div key={p.id}
        className={`project-block ${p.inProgress ? 'in-progress' : ''} ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar, pillarColorMap) }}
        draggable
        onDragStart={(e) => handleDragStart(e, p.id, lane)}
        onDragEnd={handleDragEnd}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
        {...(isTrack ? {
          onDragOver: (e) => handleDragOverBlock(e, trackKey, p.id),
          onDrop: (e) => handleDropOnBlock(e, trackKey, p.id, blockIndex),
        } : {})}
      >
        {isOverflow && (
          <div className="overflow-badge" title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        {hasSplits && <div className="ghost-link-icon" title="Has split allocations">ðŸ”—</div>}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{hasSplits && isTrack ? `${eff.total}/${s.total}sp` : `${s.total}sp`}</span>
          </div>
        </div>
        {isTrack && (
          <button className="block-split"
            onClick={(e) => { e.stopPropagation(); setSplitModal({ projectId: p.id, projectName: p.subTask, homeTrack: trackKey }); }}
            title="Split to another swimlane">
            â‘‚
          </button>
        )}
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); lane === 'backlog' ? moveToTrack(p.id, 'core-bonus') : moveToBacklog(p.id); }}
          title={lane === 'backlog' ? 'Add to Roadmap' : 'Remove from Roadmap'}>
          {lane === 'backlog' ? 'ï¼‹' : 'âœ•'}
        </button>
      </div>
    );
  };

  const renderGhostBlock = (p, splitSizing, trackKey, homeTrack, blockIndex) => {
    if (!p || !splitSizing) return null;
    const totalSp = (splitSizing.backend || 0) + (splitSizing.frontend || 0) + (splitSizing.natives || 0) + (splitSizing.qa || 0);
    const w = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, totalSp * PX_PER_SPRINT));
    const homeLabel = TRACKS.find(t => t.key === homeTrack)?.label || homeTrack;
    // Check overflow for ghost blocks too
    const overflowDisciplines = (trackOverflow[trackKey] && trackOverflow[trackKey][`ghost-${p.id}`]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    return (
      <div key={`ghost-${p.id}`}
        className={`project-block ghost-block ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar, pillarColorMap) }}
        draggable
        onDragStart={(e) => { dragItem.current = `ghost:${p.id}`; dragSource.current = 'roadmap'; e.dataTransfer.effectAllowed = 'move'; setTimeout(() => e.target.classList.add('dragging'), 0); }}
        onDragEnd={handleDragEnd}
        onDragOver={(e) => handleDragOverBlock(e, trackKey, `ghost:${p.id}`)}
        onDrop={(e) => handleDropOnBlock(e, trackKey, `ghost:${p.id}`, blockIndex)}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
      >
        <div className="ghost-link-icon">ðŸ”—</div>
        {isOverflow && (
          <div className="overflow-badge" style={{left:'auto',right:3}} title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{totalSp}sp</span>
          </div>
        </div>
        <div className="ghost-origin">â†— {homeLabel}</div>
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); removeSplit(p.id, trackKey); }}
          title="Remove split">
          âœ•
        </button>
      </div>
    );
  };

  const ghostsByTrack = useMemo(() => {
    try {
      return CP.computeGhostsByTrack(splits, projectById, tracks, trackKeys);
    } catch (err) {
      console.error('ghostsByTrack error:', err, 'splits:', JSON.stringify(splits));
      const result = {};
      for (const t of TRACKS) result[t.key] = [];
      return result;
    }
  }, [splits, projectById, tracks, trackKeys]);

  const FilterDropdown = ({ filterKey, label }) => {
    const values = uniqueValues[filterKey];
    const selected = filters[filterKey];
    const isOpen = openFilter === filterKey;
    return (
      <div className="filter-group">
        <button className={`filter-btn ${selected.length ? 'active' : ''}`}
          onClick={(e) => { e.stopPropagation(); setOpenFilter(isOpen ? null : filterKey); }}>
          {label}
          {selected.length > 0 && <span className="count">{selected.length}</span>}
          <span style={{fontSize:10}}>â–¾</span>
        </button>
        <div className={`filter-dropdown ${isOpen ? 'open' : ''}`}>
          {values.map(v => (
            <label key={v} className="filter-option">
              <input type="checkbox" checked={selected.includes(v)} onChange={() => toggleFilter(filterKey, v)} />
              {v}
            </label>
          ))}
        </div>
      </div>
    );
  };

  const trackProjects = useMemo(() => {
    const result = {};
    const filtered = new Set(filterProjects(currentData).map(p => p.id));
    for (const t of TRACKS) {
      result[t.key] = (tracks[t.key] || []).map(id => projectById[id]).filter(p => p && filtered.has(p.id));
    }
    return result;
  }, [tracks, projectById, filterProjects, currentData]);

  const trackUsed = useMemo(() => CP.computeTrackUsed(trackProjects, ghostsByTrack, splits, sizeMap, trackKeys), [trackProjects, ghostsByTrack, splits, sizeMap, trackKeys]);

  const unallocated = useMemo(() => CP.computeUnallocated(capacity, trackCapacity), [capacity, trackCapacity]);

  const trackOverflow = useMemo(() => CP.computeTrackOverflow(trackProjects, trackCapacity, ghostsByTrack, trackBlockOrder, splits, sizeMap, trackKeys), [trackProjects, trackCapacity, ghostsByTrack, trackBlockOrder, splits, sizeMap, trackKeys]);

  // â”€â”€ Timeline helpers â”€â”€
  const updateTimelineConfig = useCallback((updates) => {
    setVerticalStatesWithUndo(prev => {
      const tc = { ...(prev[activeVertical].timelineConfig || DEFAULT_TIMELINE_CONFIG), ...updates };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineConfig: tc } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const addMilestone = useCallback((name, date, color) => {
    setVerticalStatesWithUndo(prev => {
      const ms = [...(prev[activeVertical].milestones || [])];
      const id = ms.length > 0 ? Math.max(...ms.map(m => m.id)) + 1 : 1;
      ms.push({ id, name, date, color: color || MILESTONE_COLORS[ms.length % MILESTONE_COLORS.length] });
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const updateMilestone = useCallback((id, updates) => {
    setVerticalStatesWithUndo(prev => {
      const ms = (prev[activeVertical].milestones || []).map(m => m.id === id ? { ...m, ...updates } : m);
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const removeMilestone = useCallback((id) => {
    setVerticalStatesWithUndo(prev => {
      const ms = (prev[activeVertical].milestones || []).filter(m => m.id !== id);
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave, setVerticalStatesWithUndo]);

  const updateTimelineOverride = useCallback((projectId, trackKey, updates) => {
    setVerticalStatesWithUndo(prev => {
      const overrides = { ...(prev[activeVertical].timelineOverrides || {}) };
      const key = `${trackKey}:${projectId}`;
      overrides[key] = { ...(overrides[key] || {}), ...updates };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineOverrides: overrides } };
      // Save immediately (not debounced) â€” only fires on mouseup so no rapid-fire risk
      if (saveTimer.current) { clearTimeout(saveTimer.current); saveTimer.current = null; pendingSave.current = null; }
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState, setVerticalStatesWithUndo]);

  const clearTimelineOverride = useCallback((projectId, trackKey) => {
    setVerticalStatesWithUndo(prev => {
      const overrides = { ...(prev[activeVertical].timelineOverrides || {}) };
      delete overrides[`${trackKey}:${projectId}`];
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineOverrides: overrides } };
      if (saveTimer.current) { clearTimeout(saveTimer.current); saveTimer.current = null; pendingSave.current = null; }
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState, setVerticalStatesWithUndo]);

  // Sub-lane management
  const addSubLane = useCallback((trackKey) => {
    setVerticalStatesWithUndo(prev => {
      const counts = { ...(prev[activeVertical].trackSubLaneCounts || {}) };
      counts[trackKey] = (counts[trackKey] || 1) + 1;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackSubLaneCounts: counts } };
      if (saveTimer.current) { clearTimeout(saveTimer.current); saveTimer.current = null; pendingSave.current = null; }
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState, setVerticalStatesWithUndo]);

  const removeSubLane = useCallback((trackKey) => {
    setVerticalStatesWithUndo(prev => {
      const counts = { ...(prev[activeVertical].trackSubLaneCounts || {}) };
      if ((counts[trackKey] || 1) <= 1) return prev;
      counts[trackKey] = counts[trackKey] - 1;
      // Move projects from removed lane to last valid lane
      const assignments = { ...(prev[activeVertical].timelineLaneAssignments || {}) };
      for (const key in assignments) {
        if (key.startsWith(trackKey + ':') && assignments[key] >= counts[trackKey]) {
          assignments[key] = counts[trackKey] - 1;
        }
      }
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackSubLaneCounts: counts, timelineLaneAssignments: assignments } };
      if (saveTimer.current) { clearTimeout(saveTimer.current); saveTimer.current = null; pendingSave.current = null; }
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState, setVerticalStatesWithUndo]);

  const updateLaneAssignment = useCallback((projectId, trackKey, laneIndex) => {
    setVerticalStatesWithUndo(prev => {
      const assignments = { ...(prev[activeVertical].timelineLaneAssignments || {}) };
      const key = `${trackKey}:${projectId}`;
      if (laneIndex === 0) delete assignments[key];
      else assignments[key] = laneIndex;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineLaneAssignments: assignments } };
      if (saveTimer.current) { clearTimeout(saveTimer.current); saveTimer.current = null; pendingSave.current = null; }
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState, setVerticalStatesWithUndo]);

  // Drag-to-resize state ref
  const dragRef = useRef(null);

  // Compute timeline layout data
  const timelineData = useMemo(() => {
    const sprintWeeks = timelineConfig.sprintDurationWeeks || 2;
    const scale = timelineConfig.timeScale || 'months';
    const startDate = new Date(timelineConfig.sprintStartDate || Date.now());

    // Pixel width per sprint based on scale
    const pxPerSprint = scale === 'weeks' ? PX_PER_SPRINT_WEEK * sprintWeeks
      : scale === 'months' ? PX_PER_SPRINT_WEEK * sprintWeeks * 0.7
      : PX_PER_SPRINT_WEEK * sprintWeeks * 0.35; // quarters

    // Build track bars: { trackKey: [{project, left, width, sprints, trackKey, disciplines}] }
    const trackBars = {};
    let maxPx = 0;
    for (const t of TRACKS) {
      const bars = [];
      let cumSprints = 0;
      for (const pid of (tracks[t.key] || [])) {
        const p = projectById[pid];
        if (!p) continue;
        const eff = effectiveSprints(p);
        const ovKey = `${t.key}:${pid}`;
        const ov = timelineOverrides[ovKey];
        const autoStart = cumSprints;
        const autoSprints = eff.total;
        const startSp = ov && ov.startSprints != null ? ov.startSprints : autoStart;
        const durSp = ov && ov.durationSprints != null ? ov.durationSprints : autoSprints;
        const left = startSp * pxPerSprint;
        const width = Math.max(40, durSp * pxPerSprint);
        const laneIndex = timelineLaneAssignments[`${t.key}:${pid}`] || 0;
        bars.push({ project: p, left, width, sprints: durSp, autoSprints, startSprints: startSp, autoStart, trackKey: t.key, hasOverride: !!ov, disciplines: eff, laneIndex });
        cumSprints = Math.max(cumSprints, startSp + durSp);
        if (!ov) cumSprints = autoStart + autoSprints; // without override, sequential
      }
      // Ghost blocks appended at the end of the track
      for (const g of (ghostsByTrack[t.key] || [])) {
        const totalSp = (g.sizing.backend||0) + (g.sizing.frontend||0) + (g.sizing.natives||0) + (g.sizing.qa||0);
        const ovKey = `${t.key}:${g.project.id}`;
        const ov = timelineOverrides[ovKey];
        const autoStart = cumSprints;
        const startSp = ov && ov.startSprints != null ? ov.startSprints : autoStart;
        const durSp = ov && ov.durationSprints != null ? ov.durationSprints : totalSp;
        const left = startSp * pxPerSprint;
        const width = Math.max(40, durSp * pxPerSprint);
        const gLaneIndex = timelineLaneAssignments[`${t.key}:${g.project.id}`] || 0;
        bars.push({ project: g.project, left, width, sprints: durSp, autoSprints: totalSp, startSprints: startSp, autoStart, trackKey: t.key, hasOverride: !!ov, ghost: true, homeTrack: g.homeTrack, disciplines: g.sizing, laneIndex: gLaneIndex });
        cumSprints = Math.max(cumSprints, startSp + durSp);
        if (!ov) cumSprints = autoStart + totalSp;
      }
      trackBars[t.key] = bars;
      const trackMax = bars.reduce((m, b) => Math.max(m, b.left + b.width), 0);
      maxPx = Math.max(maxPx, trackMax);
    }

    const totalWeeks = (maxPx / PX_PER_SPRINT_WEEK) * (scale === 'months' ? 1/0.7 : scale === 'quarters' ? 1/0.35 : 1);

    // Generate ruler marks
    const marks = [];
    const totalPx = maxPx + 200; // extra padding
    if (scale === 'weeks') {
      const weekPx = PX_PER_SPRINT_WEEK;
      const numWeeks = Math.ceil(totalPx / weekPx);
      for (let i = 0; i < numWeeks; i++) {
        const d = new Date(startDate);
        d.setDate(d.getDate() + i * 7);
        marks.push({ label: `W${i+1}`, width: weekPx, date: d });
      }
    } else if (scale === 'months') {
      const monthPx = PX_PER_SPRINT_WEEK * (4.33 / sprintWeeks) * pxPerSprint / PX_PER_SPRINT_WEEK * sprintWeeks;
      // Simpler approach: compute months from start to end
      const d = new Date(startDate);
      let px = 0;
      while (px < totalPx) {
        const nextMonth = new Date(d.getFullYear(), d.getMonth() + 1, 1);
        const daysInMonth = (nextMonth - d) / (1000*60*60*24);
        const weeksInMonth = daysInMonth / 7;
        const w = weeksInMonth / sprintWeeks * pxPerSprint;
        marks.push({ label: d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }), width: Math.max(60, w), date: new Date(d) });
        px += w;
        d.setMonth(d.getMonth() + 1); d.setDate(1);
      }
    } else { // quarters
      const d = new Date(startDate);
      let px = 0;
      const qNames = ['Q1','Q2','Q3','Q4'];
      while (px < totalPx) {
        const q = Math.floor(d.getMonth() / 3);
        const nextQ = new Date(d.getFullYear(), (q + 1) * 3, 1);
        const daysInQ = (nextQ - d) / (1000*60*60*24);
        const weeksInQ = daysInQ / 7;
        const w = weeksInQ / sprintWeeks * pxPerSprint;
        marks.push({ label: `${qNames[q]} ${d.getFullYear()}`, width: Math.max(80, w), date: new Date(d) });
        px += w;
        d.setTime(nextQ.getTime());
      }
    }

    // Milestone positions (date to px)
    const msPositions = (milestones || []).map(m => {
      const mDate = new Date(m.date);
      const daysDiff = (mDate - startDate) / (1000*60*60*24);
      const weeksDiff = daysDiff / 7;
      const sprintsDiff = weeksDiff / sprintWeeks;
      return { ...m, px: sprintsDiff * pxPerSprint };
    }).filter(m => m.px >= 0);

    return { trackBars, marks, totalPx: totalPx, msPositions, pxPerSprint };
  }, [tracks, projectById, effectiveSprints, ghostsByTrack, timelineConfig, milestones, timelineOverrides, timelineLaneAssignments, trackSubLaneCounts]);

  // Drag handlers for timeline bars (resize left/right + move with lane support)
  const handleBarDragStart = useCallback((e, bar, side) => {
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startY = e.clientY;
    const pxPerSprint = timelineData.pxPerSprint;
    const origLeft = bar.left;
    const origWidth = bar.width;
    const origStartSp = bar.startSprints;
    const origDurSp = bar.sprints;
    const origLaneIndex = bar.laneIndex || 0;

    const barEl = e.target.closest('.tl-bar');
    const trackBarsEl = barEl?.closest('.tl-track-bars');
    const maxLane = (trackSubLaneCounts[bar.trackKey] || 1) - 1;

    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX;
      const el = barEl;
      if (side === 'right') {
        const newWidth = Math.max(40, origWidth + dx);
        const newDurSp = Math.max(1, Math.round(newWidth / pxPerSprint));
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: origStartSp, durationSprints: newDurSp, laneIndex: origLaneIndex };
        if (el) { el.style.width = (newDurSp * pxPerSprint) + 'px'; }
      } else if (side === 'left') {
        const newLeft = origLeft + dx;
        const newStartSp = Math.max(0, Math.round(newLeft / pxPerSprint));
        const newDurSp = Math.max(1, origDurSp + (origStartSp - newStartSp));
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: newStartSp, durationSprints: newDurSp, laneIndex: origLaneIndex };
        if (el) { el.style.left = (newStartSp * pxPerSprint) + 'px'; el.style.width = (newDurSp * pxPerSprint) + 'px'; }
      } else { // move (horizontal + vertical lane)
        const newLeft = origLeft + dx;
        const newStartSp = Math.max(0, Math.round(newLeft / pxPerSprint));
        // Detect vertical lane from cursor position
        let newLaneIndex = origLaneIndex;
        if (trackBarsEl && maxLane > 0) {
          const rect = trackBarsEl.getBoundingClientRect();
          const relativeY = ev.clientY - rect.top;
          newLaneIndex = Math.max(0, Math.min(maxLane, Math.floor(relativeY / 66)));
        }
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: newStartSp, durationSprints: origDurSp, laneIndex: newLaneIndex };
        if (el) {
          el.style.left = (newStartSp * pxPerSprint) + 'px';
          el.style.top = (newLaneIndex * 66 + 6) + 'px';
        }
      }
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      document.body.style.cursor = '';
      if (dragRef.current) {
        updateTimelineOverride(dragRef.current.projectId, dragRef.current.trackKey, {
          startSprints: dragRef.current.startSprints,
          durationSprints: dragRef.current.durationSprints,
        });
        // Update lane assignment if changed
        if (dragRef.current.laneIndex !== origLaneIndex) {
          updateLaneAssignment(dragRef.current.projectId, dragRef.current.trackKey, dragRef.current.laneIndex);
        }
        dragRef.current = null;
      }
    };

    document.body.style.cursor = side === 'move' ? 'grabbing' : 'col-resize';
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }, [timelineData.pxPerSprint, updateTimelineOverride, updateLaneAssignment, trackSubLaneCounts]);

  const activeV = VERTICALS.find(v => v.key === activeVertical);
  const roadmapTotalSprints = currentData.filter(p => roadmapIds.has(p.id)).reduce((s, p) => s + projectSprints(p).total, 0);

  // â”€â”€ Projects Table Component â”€â”€
  const VALID_SIZES = ['', 'XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];
  const VALID_IMPACTS = ['XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];

  const updateProject = (projectId, field, value) => {
    const updated = currentData.map(p => p.id === projectId ? { ...p, [field]: value } : p);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell(null);
  };

  const addProject = () => {
    const maxId = currentData.length > 0 ? Math.max(...currentData.map(p => p.id)) : 0;
    const newProject = {
      id: maxId + 1, nvrd: '', masterEpic: '', subTask: 'New Project',
      pillar: '', targetMarket: '', targetKPI: '', impact: 'M',
      backend: '', frontend: '', natives: '', qa: '', inProgress: false,
    };
    const updated = [...currentData, newProject];
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell({ id: newProject.id, field: 'subTask' });
    setEditValue('New Project');
  };

  const fileInputRef = useRef(null);

  const handleExcelImport = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const wb = XLSX.read(evt.target.result, { type: 'array' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
        if (!rows.length) { alert('No data found in Excel file.'); return; }

        const colMap = {
          'nvrd': 'nvrd',
          'masterepic': 'masterEpic', 'epic': 'masterEpic',
          'subtask': 'subTask', 'task': 'subTask', 'name': 'subTask',
          'pillar': 'pillar',
          'targetmarket': 'targetMarket', 'market': 'targetMarket',
          'targetkpi': 'targetKPI', 'kpi': 'targetKPI',
          'impact': 'impact',
          'backend': 'backend', 'be': 'backend',
          'frontend': 'frontend', 'fe': 'frontend',
          'natives': 'natives', 'native': 'natives', 'mobile': 'natives',
          'qa': 'qa', 'quality': 'qa',
          'inprogress': 'inProgress', 'progress': 'inProgress', 'status': 'inProgress',
        };

        const normalize = (s) => s.trim().toLowerCase().replace(/[^a-z0-9]/g, '');

        const headerMap = {};
        Object.keys(rows[0]).forEach(h => {
          const key = normalize(h);
          if (colMap[key]) headerMap[h] = colMap[key];
        });

        // Parse each row's values using headerMap
        const parseRow = (row) => {
          const vals = {};
          Object.entries(headerMap).forEach(([excelCol, field]) => {
            let val = String(row[excelCol] ?? '').trim();
            if (field === 'inProgress') {
              vals[field] = ['true', 'yes', '1', 'x'].includes(val.toLowerCase());
            } else if (['backend', 'frontend', 'natives', 'qa'].includes(field)) {
              const upper = val.toUpperCase();
              vals[field] = VALID_SIZES.includes(upper) ? upper : '';
            } else if (field === 'impact') {
              const upper = val.toUpperCase();
              vals[field] = VALID_IMPACTS.includes(upper) ? upper : 'M';
            } else {
              vals[field] = val;
            }
          });
          return vals;
        };

        // Build lookup of existing projects by masterEpic+subTask
        const existingMap = {};
        currentData.forEach(p => {
          const key = (p.masterEpic || '').trim().toLowerCase() + '||' + (p.subTask || '').trim().toLowerCase();
          if (key !== '||') existingMap[key] = p.id;
        });

        let maxId = currentData.length > 0 ? Math.max(...currentData.map(p => p.id)) : 0;
        let updatedCount = 0, addedCount = 0;
        const newProjects = [];
        const updateMap = {}; // id -> fields to update

        rows.forEach(row => {
          const vals = parseRow(row);
          const epic = (vals.masterEpic || '').trim().toLowerCase();
          const sub = (vals.subTask || '').trim().toLowerCase();
          const matchKey = epic + '||' + sub;

          if (matchKey !== '||' && existingMap[matchKey] !== undefined) {
            // Existing project â€” update values but keep id, inProgress, and swimlane assignments intact
            updateMap[existingMap[matchKey]] = vals;
            updatedCount++;
          } else {
            // New project
            maxId++;
            newProjects.push({
              id: maxId, nvrd: '', masterEpic: '', subTask: '',
              pillar: '', targetMarket: '', targetKPI: '', impact: 'M',
              backend: '', frontend: '', natives: '', qa: '', inProgress: false,
              ...vals,
            });
            addedCount++;
          }
        });

        // Apply updates to existing projects (keeps their id and position)
        const merged = currentData.map(p => {
          if (updateMap[p.id]) {
            return { ...p, ...updateMap[p.id] };
          }
          return p;
        });
        // Append new projects at end
        const updated = [...merged, ...newProjects];
        setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
        saveProjects(activeVertical, updated);

        const parts = [];
        if (addedCount) parts.push(`${addedCount} added`);
        if (updatedCount) parts.push(`${updatedCount} updated`);
        setSaveStatus({ type: 'ok', msg: parts.length ? parts.join(', ') : 'No changes' });
        setTimeout(() => setSaveStatus(null), 4000);
      } catch (err) {
        alert('Failed to parse Excel file: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
    e.target.value = '';
  };

  const deleteProject = (projectId) => {
    if (!window.confirm('Delete this project?')) return;
    const updated = currentData.filter(p => p.id !== projectId);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => removeFromTracks(prev, projectId));
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
  };

  // â”€â”€ Bulk operations â”€â”€
  const toggleSelect = (id) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  };

  const toggleSelectAll = () => {
    if (selectedIds.size === currentData.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(currentData.map(p => p.id)));
    }
  };

  const bulkDelete = () => {
    if (selectedIds.size === 0) return;
    if (!window.confirm(`Delete ${selectedIds.size} selected project${selectedIds.size > 1 ? 's' : ''}?`)) return;
    const updated = currentData.filter(p => !selectedIds.has(p.id));
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => {
      let t = prev;
      for (const id of selectedIds) t = removeFromTracks(t, id);
      return t;
    });
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
    setSelectedIds(new Set());
  };

  const bulkEdit = () => {
    if (selectedIds.size === 0 || !bulkField) return;
    const updated = currentData.map(p =>
      selectedIds.has(p.id) ? { ...p, [bulkField]: bulkValue } : p
    );
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
  };

  const BULK_FIELD_OPTIONS = [
    { key: 'pillar', label: 'Pillar' },
    { key: 'targetMarket', label: 'Market' },
    { key: 'targetKPI', label: 'KPI' },
    { key: 'impact', label: 'Impact' },
    { key: 'backend', label: 'Backend' },
    { key: 'frontend', label: 'Frontend' },
    { key: 'natives', label: 'Natives' },
    { key: 'qa', label: 'QA' },
    { key: 'masterEpic', label: 'Epic' },
  ];

  const sizeFields = new Set(['impact', 'backend', 'frontend', 'natives', 'qa']);

  const startEdit = (id, field, value) => {
    setEditingCell({ id, field });
    setEditValue(value || '');
  };

  const commitEditRef = useRef(null);
  commitEditRef.current = () => {
    if (editingCell) {
      updateProject(editingCell.id, editingCell.field, editValue);
    }
  };
  const commitEdit = () => commitEditRef.current();

  const dropdownFields = { impact: VALID_IMPACTS, backend: VALID_SIZES, frontend: VALID_SIZES, natives: VALID_SIZES, qa: VALID_SIZES };

  const renderEditableCell = (p, field) => {
    const isEditing = editingCell?.id === p.id && editingCell?.field === field;
    const value = p[field] || '';

    if (isEditing) {
      if (dropdownFields[field]) {
        return (
          <select className="cell-select" value={editValue}
            onChange={(e) => { updateProject(p.id, field, e.target.value); }}
            onBlur={() => setEditingCell(null)}
            onKeyDown={(e) => { if (e.key === 'Escape') setEditingCell(null); }}
            autoFocus>
            {dropdownFields[field].map(v => <option key={v} value={v}>{v || 'â€”'}</option>)}
          </select>
        );
      }
      return (
        <input className="cell-input" value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={commitEdit}
          onKeyDown={(e) => {
            if (e.key === 'Enter') commitEdit();
            if (e.key === 'Escape') setEditingCell(null);
          }}
          autoFocus />
      );
    }
    return (
      <div className="cell-view" onClick={() => startEdit(p.id, field, value)}>
        {value || 'â€”'}
      </div>
    );
  };

  const TABLE_COLS = [
    { key: 'nvrd', label: 'NVRD', width: '8%' },
    { key: 'masterEpic', label: 'Epic', width: '12%' },
    { key: 'subTask', label: 'Sub Task', width: '22%' },
    { key: 'pillar', label: 'Pillar', width: '9%' },
    { key: 'targetMarket', label: 'Market', width: '7%' },
    { key: 'targetKPI', label: 'KPI', width: '8%' },
    { key: 'impact', label: 'Impact', width: '6%' },
    { key: 'backend', label: 'BE', width: '5%' },
    { key: 'frontend', label: 'FE', width: '5%' },
    { key: 'natives', label: 'Native', width: '5%' },
    { key: 'qa', label: 'QA', width: '5%' },
  ];

  const projectsTableJSX = (
    <div className="projects-container">
      <div className="projects-toolbar">
        <button className="btn btn-primary" onClick={addProject}>+ Add Project</button>
        <button className="btn btn-primary" onClick={() => fileInputRef.current?.click()}
          style={{background:'var(--blue)'}}>Import Excel</button>
        <input type="file" ref={fileInputRef} accept=".xlsx,.xls,.csv"
          style={{display:'none'}} onChange={handleExcelImport} />
        <span className="project-count-badge">{currentData.length} projects</span>
        {selectedIds.size > 0 && (
          <button className="btn-sm" onClick={() => setSelectedIds(new Set())} style={{marginLeft:4}}>
            Deselect all
          </button>
        )}
        {saveStatus && (
          <span style={{
            fontSize: 11, padding: '3px 10px', borderRadius: 6, fontWeight: 600,
            background: saveStatus.type === 'ok' ? 'rgba(0,184,148,0.15)' : 'rgba(225,112,85,0.15)',
            color: saveStatus.type === 'ok' ? 'var(--green)' : 'var(--red)',
          }}>{saveStatus.msg}</span>
        )}
      </div>

      {selectedIds.size > 0 && (
        <div className="bulk-bar">
          <span className="bulk-count">{selectedIds.size} selected</span>
          <div className="bulk-sep" />
          <button className="btn-sm danger" onClick={bulkDelete}>
            Delete selected
          </button>
          <div className="bulk-sep" />
          <div className="bulk-edit-group">
            <span style={{fontSize:11, color:'var(--text2)'}}>Set</span>
            <select value={bulkField} onChange={e => { setBulkField(e.target.value); setBulkValue(''); }}>
              {BULK_FIELD_OPTIONS.map(o => <option key={o.key} value={o.key}>{o.label}</option>)}
            </select>
            <span style={{fontSize:11, color:'var(--text2)'}}>to</span>
            {sizeFields.has(bulkField) ? (
              <select value={bulkValue} onChange={e => setBulkValue(e.target.value)}>
                <option value="">â€” select â€”</option>
                {(bulkField === 'impact' ? VALID_IMPACTS : VALID_SIZES.filter(Boolean)).map(v =>
                  <option key={v} value={v}>{v}</option>
                )}
              </select>
            ) : (
              <input type="text" value={bulkValue} onChange={e => setBulkValue(e.target.value)}
                placeholder="value..." style={{width:120}} />
            )}
            <button className="btn-sm apply" onClick={bulkEdit} disabled={!bulkValue}>
              Apply
            </button>
          </div>
        </div>
      )}

      <table className="projects-table">
        <thead>
          <tr>
            <th className="check-col">
              <input type="checkbox" className="row-checkbox"
                checked={currentData.length > 0 && selectedIds.size === currentData.length}
                onChange={toggleSelectAll} />
            </th>
            <th style={{width:'3%'}}>#</th>
            {TABLE_COLS.map(c => <th key={c.key} style={{width:c.width}}>{c.label}</th>)}
            <th style={{width:'5%'}}></th>
          </tr>
        </thead>
        <tbody>
          {currentData.map((p, i) => (
            <tr key={p.id} className={`${editingCell?.id === p.id ? 'editing-row' : ''} ${selectedIds.has(p.id) ? 'editing-row' : ''}`}>
              <td className="check-col">
                <input type="checkbox" className="row-checkbox"
                  checked={selectedIds.has(p.id)}
                  onChange={() => toggleSelect(p.id)} />
              </td>
              <td style={{color:'var(--text2)', fontSize:10}}>{i+1}</td>
              {TABLE_COLS.map(c => <td key={c.key}>{renderEditableCell(p, c.key)}</td>)}
              <td>
                <button className="btn-icon danger" onClick={() => deleteProject(p.id)} title="Delete project">
                  Ã—
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      {currentData.length === 0 && (
        <div style={{textAlign:'center', padding:'60px 40px', color:'var(--text2)'}}>
          <p style={{fontSize:16, marginBottom:12}}>No projects yet</p>
          <p style={{fontSize:13}}>Click <strong>"+ Add Project"</strong> to create your first project.</p>
        </div>
      )}
    </div>
  );

  const renderTooltip = () => {
    if (!tooltip) return null;
    const { p, x, y } = tooltip;
    const s = projectSprints(p);
    const eff = effectiveSprints(p);
    const hasSplit = splits[p.id] && Object.keys(splits[p.id]).length > 0;
    const efforts = [];
    if (s.backend) efforts.push({ label: 'BE', val: p.backend, sprints: s.backend, effective: eff.backend });
    if (s.frontend) efforts.push({ label: 'FE', val: p.frontend, sprints: s.frontend, effective: eff.frontend });
    if (s.natives) efforts.push({ label: 'Native', val: p.natives, sprints: s.natives, effective: eff.natives });
    if (s.qa) efforts.push({ label: 'QA', val: p.qa, sprints: s.qa, effective: eff.qa });
    // Keep tooltip on screen
    const tx = Math.min(x, window.innerWidth - 340);
    const ty = Math.min(y, window.innerHeight - 200);
    return (
      <div className="tooltip-overlay" style={{ left: tx, top: ty }}>
        <div className="tooltip-card">
          <div className="tt-title">{p.subTask}</div>
          <div className="tt-meta">
            <span className="pill pill-pillar" style={{background: pillarColorMap[p.pillar] || '#6c5ce7', color: isLightColor(pillarColorMap[p.pillar] || '#6c5ce7') ? '#333' : 'white'}}>{p.pillar}</span>
            <span className="pill pill-market">{p.targetMarket}</span>
            <span className="pill pill-kpi">{p.targetKPI}</span>
            <span className={`pill pill-impact impact-${p.impact}`}>Impact: {p.impact}</span>
          </div>
          <div className="tt-efforts">
            {efforts.map(e => (
              <span key={e.label} className="effort-tag">
                {e.label}: <span className="val">{e.val}</span> ({e.sprints}sp)
                {hasSplit && e.effective !== e.sprints && <span style={{color:'var(--yellow)',marginLeft:3}}>â†’ {e.effective}sp here</span>}
              </span>
            ))}
          </div>
          <div className="tt-total">Total: {s.total} man-sprints{hasSplit && ` (${eff.total} in home lane)`}</div>
          {hasSplit && (
            <div style={{fontSize:10,color:'var(--yellow)',marginTop:4,borderTop:'1px solid var(--border)',paddingTop:4}}>
              â‘‚ Split: {Object.entries(splits[p.id]).map(([tk, sz]) => {
                const label = TRACKS.find(t => t.key === tk)?.label || tk;
                const total = (sz.backend||0) + (sz.frontend||0) + (sz.natives||0) + (sz.qa||0);
                return `${label} ${total}sp`;
              }).join(', ')}
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <>
      <div className="app-header">
        <h1>
          <span style={{color: activeV.color}}>{activeV.icon}</span>
          {' '}{activeV.label} <span>Capacity Planner</span> <span style={{fontSize:9,color:'var(--text2)',opacity:0.5}}>v3.0</span>
        </h1>
        <div className="header-right">
          <div style={{display:'flex',gap:2,marginRight:8}}>
            <button onClick={handleUndo} disabled={undoLen === 0}
              title="Undo (Ctrl+Z)"
              style={{fontSize:14,background:'none',border:'1px solid var(--border)',borderRadius:4,padding:'2px 8px',cursor:undoLen?'pointer':'default',color:undoLen?'var(--text1)':'var(--text2)',opacity:undoLen?1:0.4}}>â†¶</button>
            <button onClick={handleRedo} disabled={redoLen === 0}
              title="Redo (Ctrl+Shift+Z)"
              style={{fontSize:14,background:'none',border:'1px solid var(--border)',borderRadius:4,padding:'2px 8px',cursor:redoLen?'pointer':'default',color:redoLen?'var(--text1)':'var(--text2)',opacity:redoLen?1:0.4}}>â†·</button>
          </div>
          <div className="tab-switcher">
            <button className={`tab-btn ${activeTab === 'planner' ? 'active' : ''}`}
              onClick={() => setActiveTab('planner')}>Planner</button>
            <button className={`tab-btn ${activeTab === 'projects' ? 'active' : ''}`}
              onClick={() => setActiveTab('projects')}>Projects</button>
            <button className={`tab-btn ${activeTab === 'dashboard' ? 'active' : ''}`}
              onClick={() => setActiveTab('dashboard')}>Dashboard</button>
          </div>
          <div className="vertical-selector">
            <label>Vertical</label>
            <select className="vertical-select" value={activeVertical}
              onChange={e => handleVerticalChange(e.target.value)}>
              {VERTICALS.map(v => (
                <option key={v.key} value={v.key}>{v.icon} {v.label}</option>
              ))}
            </select>
          </div>
          {saving && <span style={{fontSize:11, color:'var(--accent2)'}}>Saving...</span>}
          {currentData.length > 0 && activeTab === 'planner' && (
            <span style={{fontSize:12, color:'var(--text2)'}}>
              {roadmapIds.size} in roadmap Â· {currentData.length - roadmapIds.size} in backlog
            </span>
          )}
          {authUser && (
            <div style={{display:'flex',alignItems:'center',gap:6,marginLeft:8}}>
              <button onClick={() => { setShowSnapshots(true); loadSnapshots(); }}
                style={{fontSize:10,color:'var(--text2)',background:'none',border:'1px solid var(--border)',borderRadius:4,padding:'2px 6px',cursor:'pointer'}}
                title="Scenario Snapshots">ðŸ“¸ Snapshots</button>
              {authUser.email === 'kmermigkas@novibet.com' && <a href="/audit.html" target="_blank" rel="noopener" style={{fontSize:10,color:'var(--text2)',textDecoration:'none',border:'1px solid var(--border)',borderRadius:4,padding:'2px 6px'}} title="View activity log">ðŸ“‹ Log</a>}
              {authUser.picture && <img src={authUser.picture} style={{width:24,height:24,borderRadius:'50%'}} referrerPolicy="no-referrer" />}
              <span style={{fontSize:11,color:'var(--text2)'}}>{authUser.name?.split(' ')[0]}</span>
              <button onClick={onLogout} style={{fontSize:10,color:'var(--text2)',background:'none',border:'1px solid var(--border)',borderRadius:4,padding:'2px 6px',cursor:'pointer'}}>Logout</button>
            </div>
          )}
        </div>
      </div>

      {loading ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon" style={{animation:'pulse-indicator 1s ease-in-out infinite alternate'}}>â³</div>
          <h2>Loading {activeV.label} data...</h2>
        </div>
      ) : activeTab === 'dashboard' ? (
        <DashboardView
          capacity={capacity}
          buffer={buffer}
          usedCapacity={usedCapacity}
          bufferedUsed={bufferedUsed}
          totalDemand={totalDemand}
          bufferedDemand={bufferedDemand}
          trackCapacity={trackCapacity}
          trackUsed={trackUsed}
          unallocated={unallocated}
          tracks={TRACKS}
          currentData={currentData}
          roadmapIds={roadmapIds}
          projectSprints={projectSprints}
          sizeMap={sizeMap}
          pillarColorMap={pillarColorMap}
        />
      ) : activeTab === 'projects' ? (
        projectsTableJSX
      ) : currentData.length === 0 ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon">{activeV.icon}</div>
          <h2>{activeV.label} Backlog</h2>
          <p>No project data loaded for this vertical yet. Switch to the <strong>Projects</strong> tab above to add projects.</p>
        </div>
      ) : (<>

      {/* 1. Configuration */}
      <div className="settings-panel">
        <div className="settings-tabs">
          <button className={`settings-tab ${settingsTab === 'config' ? 'active' : ''}`} onClick={() => toggleSettingsTab('config')}>âš™ï¸ Configuration</button>
          <button className={`settings-tab ${settingsTab === 'alloc' ? 'active' : ''}`} onClick={() => toggleSettingsTab('alloc')}>ðŸ“Š Swimlane Allocation</button>
          <button className={`settings-tab ${settingsTab === 'demand' ? 'active' : ''}`} onClick={() => toggleSettingsTab('demand')}>ðŸŽ¯ Demand & Buffer</button>
          <button className={`settings-tab ${settingsTab === 'usage' ? 'active' : ''}`} onClick={() => toggleSettingsTab('usage')}>ðŸ“ˆ Capacity Usage</button>
          <button className={`settings-tab ${settingsTab === 'tracks' ? 'active' : ''}`} onClick={() => toggleSettingsTab('tracks')}>Tracks</button>
        </div>

        {settingsTab === 'config' && (
          <div className="settings-tab-content">
            <div className="config-bar">
              <div className="config-section">
                <h3>Team Capacity (man-sprints)</h3>
                <div className="config-inputs">
                  {['backend','frontend','natives','qa'].map(k => (
                    <div key={k} className="config-field">
                      <label>{k.charAt(0).toUpperCase() + k.slice(1)}</label>
                      <input type="number" min="0" value={capacity[k]}
                        onChange={e => setCapacity(prev => ({...prev, [k]: parseInt(e.target.value)||0}))} />
                    </div>
                  ))}
                </div>
              </div>
              <div className="config-section">
                <h3>T-Shirt (man-sprints)</h3>
                <div className="size-mapping">
                  {Object.entries(sizeMap).map(([size, val]) => (
                    <div key={size} className="size-chip">
                      <span>{size}</span>
                      <input type="number" min="0" step="0.5" value={val}
                        onChange={e => setSizeMap(prev => ({...prev, [size]: parseFloat(e.target.value)||0}))} />
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}

        {settingsTab === 'alloc' && (
          <div className="settings-tab-content">
            <div className="track-alloc-section">
              <div className="track-alloc-grid">
                <div className="track-alloc-header"></div>
                {['backend','frontend','natives','qa'].map(d => (
                  <div key={d} className="track-alloc-header">{d.charAt(0).toUpperCase()+d.slice(1)}</div>
                ))}
                <div className="track-alloc-header"></div>
                {TRACKS.map(t => {
                  const used = trackUsed[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
                  const tc = trackCapacity[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
                  return (
                    <React.Fragment key={t.key}>
                      <div className="track-alloc-label" style={{borderLeft:`3px solid ${t.borderColor}`, paddingLeft:8}}>{t.label}</div>
                      {['backend','frontend','natives','qa'].map(d => {
                        const pct = tc[d] > 0 ? Math.round(used[d] / tc[d] * 100) : 0;
                        const color = pct > 100 ? '#e17055' : pct > 80 ? '#fdcb6e' : '#00b894';
                        return (
                          <div key={d}>
                            <input type="number" min="0" className={`track-alloc-input${used[d] > tc[d] && tc[d] > 0 ? ' over-cap' : ''}`}
                              value={tc[d]} onChange={e => updateTrackCapacity(t.key, d, parseInt(e.target.value)||0)} />
                            {tc[d] > 0 && <div className="track-cap-bar"><div className="track-cap-fill" style={{width:`${Math.min(pct,100)}%`, background: color}} /></div>}
                          </div>
                        );
                      })}
                      <div style={{fontSize:10,color:'var(--muted)'}}>
                        {Object.values(used).reduce((a,b)=>a+b,0)}/{Object.values(tc).reduce((a,b)=>a+b,0)}
                      </div>
                    </React.Fragment>
                  );
                })}
                <div className="track-alloc-label" style={{fontWeight:700}}>Remaining</div>
                {['backend','frontend','natives','qa'].map(d => (
                  <div key={d} className={`track-alloc-remaining ${unallocated[d] < 0 ? 'over' : unallocated[d] === 0 ? 'warn' : 'ok'}`}>
                    {unallocated[d]}
                  </div>
                ))}
                <div></div>
              </div>
            </div>
          </div>
        )}

        {settingsTab === 'demand' && (
          <div className="settings-tab-content">
            <div className="demand-section">
              {['backend', 'frontend', 'natives', 'qa'].map(k => (
                <div key={k} className="demand-card">
                  <div className="demand-card-title">{k.charAt(0).toUpperCase() + k.slice(1)} Total Demand</div>
                  <div className="demand-card-value">{totalDemand[k]} <span style={{fontSize:11,color:'var(--muted)',fontWeight:400}}>sprints</span></div>
                  <div className="demand-buffer-row">
                    <button className="demand-buffer-btn" onClick={() => updateBuffer(k, -5)}>âˆ’</button>
                    <span className="demand-buffer-pct">{buffer[k] >= 0 ? '+' : ''}{buffer[k]}%</span>
                    <button className="demand-buffer-btn" onClick={() => updateBuffer(k, 5)}>+</button>
                  </div>
                  {buffer[k] !== 0 && (
                    <div className="demand-card-buffered">With buffer: {bufferedDemand[k]} sprints</div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}

        {settingsTab === 'usage' && (
          <div className="settings-tab-content">
            <div className="capacity-overview">
              {renderCapBar('Backend', bufferedUsed.backend, capacity.backend)}
              {renderCapBar('Frontend', bufferedUsed.frontend, capacity.frontend)}
              {renderCapBar('Natives', bufferedUsed.natives, capacity.natives)}
              {renderCapBar('QA', bufferedUsed.qa, capacity.qa)}
              <div className="cap-total">
                {renderCapBar('Total Capacity', totalUsed, totalCapacity)}
              </div>
            </div>
          </div>
        )}

        {settingsTab === 'tracks' && (
          <div className="settings-tab-content">
            <div style={{maxWidth:600}}>
              <h3 style={{fontSize:11,textTransform:'uppercase',letterSpacing:1,color:'var(--text2)',marginBottom:8}}>Swimlane Tracks</h3>
              {currentTrackConfig.map((t, idx) => (
                <div key={t.key} style={{display:'flex',alignItems:'center',gap:8,padding:'6px 0',borderBottom:'1px solid var(--border)'}}>
                  <div style={{width:20,height:20,borderRadius:4,background:`linear-gradient(135deg, ${t.color}cc, ${t.color}88)`,flexShrink:0}} />
                  <input type="color" value={t.color}
                    onChange={e => updateTrackColor(idx, e.target.value)}
                    style={{width:28,height:28,border:'none',background:'none',cursor:'pointer',padding:0}} />
                  <input type="text" value={t.label}
                    onChange={e => updateTrackLabel(idx, e.target.value)}
                    style={{flex:1,padding:'4px 8px',background:'var(--bg)',border:'1px solid var(--border)',borderRadius:4,color:'var(--text)',fontSize:13}} />
                  <button onClick={() => removeTrack(idx)}
                    disabled={currentTrackConfig.length <= 1}
                    style={{fontSize:10,padding:'4px 8px',background:'var(--red)',color:'white',border:'none',borderRadius:4,cursor:'pointer',opacity:currentTrackConfig.length<=1?0.3:1}}
                    title="Remove track">Remove</button>
                </div>
              ))}
              <button onClick={addTrack}
                style={{marginTop:8,padding:'6px 14px',background:'linear-gradient(135deg, var(--accent), var(--accent2))',color:'white',border:'none',borderRadius:6,fontSize:12,fontWeight:600,cursor:'pointer'}}>
                + Add Track
              </button>
            </div>
          </div>
        )}
      </div>

      <div className="main-scroll">
        {/* Roadmap Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              âœ… In Roadmap
              <span className="badge roadmap-badge">{roadmapProjects.length}</span>
              <span style={{fontSize:11,color:'var(--text2)',fontWeight:400,marginLeft:8}}>
                {roadmapTotalSprints} total sprints
              </span>
            </h2>
            <div className="lane-stats">
              {['backend','frontend','natives','qa'].map(k => (
                <span key={k} className="stat-chip">
                  {k.charAt(0).toUpperCase()+k.slice(1)}: <strong>{bufferedUsed[k]}</strong>/{capacity[k]}
                </span>
              ))}
              <button className="btn-timeline" onClick={() => setShowTimeline(true)}>ðŸ“Š Timeline</button>
            </div>
          </div>
          <div className="track-group">
            {TRACKS.map((track, i) => (
              <React.Fragment key={track.key}>
                {i > 0 && <div className="track-divider" />}
                {(() => {
                  const tc = trackCapacity[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                  const tu = trackUsed[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                  const hasAlloc = Object.values(tc).some(v => v > 0);
                  return hasAlloc ? (
                    <div className="track-capacity-bar">
                      {['backend','frontend','natives','qa'].map(d => {
                        if (!tc[d]) return null;
                        const label = d === 'backend' ? 'Backend' : d === 'frontend' ? 'Frontend' : d === 'natives' ? 'Natives' : 'QA';
                        const buffered = Math.round(tu[d] * (1 + (buffer[d] || 0) / 100) * 10) / 10;
                        const isOver = buffered > tc[d];
                        return (
                          <span key={d} className={`track-cap-chip${isOver ? ' over' : ''}`}>
                            {label}: <strong>{buffered}</strong>/{tc[d]}
                          </span>
                        );
                      })}
                    </div>
                  ) : null;
                })()}
                <div className="track-row">
                  <div className="track-label" style={{background: track.gradient}}>
                    {track.label}
                  </div>
                  <div className="track-flow"
                    onDragOver={handleDragOver} onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                    onDrop={(e) => handleDropOnTrack(e, track.key)}
                    style={{borderColor: track.borderColor}}>
                    {(trackProjects[track.key] || []).length === 0 && (ghostsByTrack[track.key] || []).length === 0 && <div className="track-empty">Drag projects here</div>}
                    {(() => {
                      const realProjects = (trackProjects[track.key] || []).map(p => ({ type: 'real', project: p }));
                      const ghosts = (ghostsByTrack[track.key] || []).map(g => ({ type: 'ghost', project: g.project, sizing: g.sizing, homeTrack: g.homeTrack }));
                      const combined = [...realProjects, ...ghosts];
                      // Sort by stored order if available
                      const orderKey = track.key;
                      const order = trackBlockOrder[orderKey];
                      if (order && order.length > 0) {
                        combined.sort((a, b) => {
                          const aKey = a.type === 'ghost' ? `ghost:${a.project.id}` : String(a.project.id);
                          const bKey = b.type === 'ghost' ? `ghost:${b.project.id}` : String(b.project.id);
                          const aIdx = order.indexOf(aKey);
                          const bIdx = order.indexOf(bKey);
                          if (aIdx === -1 && bIdx === -1) return 0;
                          if (aIdx === -1) return 1;
                          if (bIdx === -1) return 1;
                          return aIdx - bIdx;
                        });
                      }
                      return combined.map((item, idx) => {
                        if (item.type === 'ghost') {
                          return renderGhostBlock(item.project, item.sizing, track.key, item.homeTrack, idx);
                        } else {
                          return renderBlock(item.project, 'roadmap', track.key, idx);
                        }
                      });
                    })()}
                  </div>
                </div>
              </React.Fragment>
            ))}
          </div>
        </div>

        {/* Filters & Sort */}
        <div className="filters-bar">
          <input className="search-input" placeholder="Search projects..." value={search} onChange={e => setSearch(e.target.value)} />
          <FilterDropdown filterKey="pillar" label="Pillar" />
          <FilterDropdown filterKey="epic" label="Epic" />
          <FilterDropdown filterKey="market" label="Market" />
          <FilterDropdown filterKey="kpi" label="KPI" />
          <FilterDropdown filterKey="impact" label="Impact" />
          {activeFilterCount > 0 && (
            <button className="btn" onClick={() => setFilters({pillar:[],market:[],epic:[],kpi:[],impact:[]})}>
              Clear ({activeFilterCount})
            </button>
          )}
          <div style={{marginLeft:'auto'}} className="sort-controls">
            <span style={{fontSize:10,color:'var(--text2)'}}>Sort:</span>
            <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
              <option value="impact">Impact â†“</option>
              <option value="effort">Effort â†“</option>
              <option value="epic">Epic</option>
              <option value="pillar">Pillar</option>
              <option value="name">Name</option>
            </select>
          </div>
          <div className="color-legend">
            {Object.entries(pillarColorMap).map(([name, color]) => (
              <div key={name} className="legend-item">
                <div className="legend-dot" style={{background: color}}></div>
                {name}
              </div>
            ))}
          </div>
        </div>

        {/* Backlog Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              ðŸ“‹ Backlog
              <span className="badge backlog-badge">{backlogProjects.length}</span>
            </h2>
            <div style={{display:'flex',gap:6}}>
              <button className="btn" style={{fontSize:11,padding:'4px 10px',background: backlogView === 'blocks' ? 'var(--accent1)' : 'var(--surface2)'}} onClick={() => setBacklogView('blocks')}>Blocks</button>
              <button className="btn" style={{fontSize:11,padding:'4px 10px',background: backlogView === 'table' ? 'var(--accent1)' : 'var(--surface2)'}} onClick={() => setBacklogView('table')}>List</button>
            </div>
          </div>
          {backlogView === 'blocks' ? (
          <div className="flow-container"
            onDragOver={handleDragOver} onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave} onDrop={handleDropOnBacklog}>
            {backlogProjects.length === 0 && <div className="empty-flow">All projects are in the roadmap</div>}
            {backlogProjects.map(p => renderBlock(p, 'backlog'))}
          </div>
          ) : (
          <div style={{overflowX:'auto'}}>
            {backlogProjects.length === 0 ? <div className="empty-flow">All projects are in the roadmap</div> : (
            <table style={{width:'100%',borderCollapse:'collapse',fontSize:12}}>
              <thead>
                <tr style={{borderBottom:'1px solid var(--border)',textAlign:'left'}}>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'30%'}}>Name</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'14%'}}>Epic</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'10%'}}>Pillar</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'7%',textAlign:'center'}}>Impact</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'5%',textAlign:'center'}}>BE</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'5%',textAlign:'center'}}>FE</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'5%',textAlign:'center'}}>Nat</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'5%',textAlign:'center'}}>QA</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'7%',textAlign:'center'}}>Sprints</th>
                  <th style={{padding:'6px 8px',color:'var(--text2)',fontWeight:600,width:'8%',textAlign:'center'}}>Market</th>
                  <th style={{padding:'6px 8px',width:'4%'}}></th>
                </tr>
              </thead>
              <tbody>
                {backlogProjects.map(p => {
                  const sp = CP.computeProjectSprints(p, sizeMap);
                  const pColor = pillarColorMap[p.pillar];
                  return (
                    <tr key={p.id} style={{borderBottom:'1px solid var(--border)',cursor:'pointer'}}
                      onMouseEnter={(e) => setTooltip({ p, x: e.clientX, y: e.clientY })}
                      onMouseLeave={() => setTooltip(null)}
                      draggable onDragStart={() => { dragItem.current = p.id; dragSource.current = 'backlog'; }}>
                      <td style={{padding:'6px 8px',color:'var(--text1)'}}>{p.subTask || 'â€”'}</td>
                      <td style={{padding:'6px 8px',color:'var(--text2)',fontSize:11}}>{p.masterEpic || 'â€”'}</td>
                      <td style={{padding:'6px 8px'}}>
                        {p.pillar && <span className="pill pill-pillar" style={{background: pColor || '#6c5ce7', color: isLightColor(pColor || '#6c5ce7') ? '#333' : 'white'}}>{p.pillar}</span>}
                      </td>
                      <td style={{padding:'6px 8px',textAlign:'center'}}><span className={`pill pill-impact impact-${p.impact}`}>{p.impact || 'â€”'}</span></td>
                      <td style={{padding:'6px 8px',textAlign:'center',color:'var(--text2)'}}>{p.backend || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center',color:'var(--text2)'}}>{p.frontend || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center',color:'var(--text2)'}}>{p.natives || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center',color:'var(--text2)'}}>{p.qa || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center',fontWeight:600,color:'var(--text1)'}}>{sp.total || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center',color:'var(--text2)',fontSize:11}}>{p.targetMarket || 'â€”'}</td>
                      <td style={{padding:'6px 8px',textAlign:'center'}}>
                        <button className="btn" style={{fontSize:10,padding:'2px 6px'}} onClick={() => moveToTrack(p.id, trackKeys[0])}>+ Roadmap</button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
            )}
          </div>
          )}
        </div>
      </div>

      {renderTooltip()}
      </>)}

      {showTimeline && (
        <div className="timeline-overlay" onClick={() => setShowTimeline(false)}>
          <div className="timeline-modal" onClick={e => e.stopPropagation()}>
            <div className="tl-header">
              <h2>ðŸ“Š Timeline</h2>
              <div className="tl-controls">
                <div className="tl-ctrl-group">
                  <label>Start:</label>
                  <input type="date" value={timelineConfig.sprintStartDate}
                    onChange={e => updateTimelineConfig({ sprintStartDate: e.target.value })} />
                </div>
                <div className="tl-ctrl-group">
                  <label>Sprint:</label>
                  <select value={timelineConfig.sprintDurationWeeks}
                    onChange={e => updateTimelineConfig({ sprintDurationWeeks: parseInt(e.target.value) })}>
                    <option value={1}>1 wk</option>
                    <option value={2}>2 wk</option>
                    <option value={3}>3 wk</option>
                    <option value={4}>4 wk</option>
                  </select>
                </div>
                <div className="tl-ctrl-group">
                  <label>Scale:</label>
                  <select value={timelineConfig.timeScale}
                    onChange={e => updateTimelineConfig({ timeScale: e.target.value })}>
                    <option value="weeks">Weeks</option>
                    <option value="months">Months</option>
                    <option value="quarters">Quarters</option>
                  </select>
                </div>
              </div>
              <button className="tl-close" onClick={() => setShowTimeline(false)} title="Close">âœ•</button>
            </div>
            <div className="tl-body">
              {/* Milestones sidebar */}
              <div className="tl-sidebar">
                <div className="tl-sidebar-header">
                  <span>Milestones</span>
                  <button className="tl-btn" onClick={() => {
                    const name = prompt('Milestone name:');
                    if (name) {
                      const date = prompt('Date (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
                      if (date) addMilestone(name, date);
                    }
                  }}>+ Add</button>
                </div>
                <div className="tl-sidebar-content">
                  {milestones.length === 0 && <div className="tl-ms-empty">No milestones yet. Click "+ Add" to create one.</div>}
                  {milestones.map(m => (
                    <div key={m.id} className="tl-ms-item">
                      <div className="tl-ms-dot" style={{background: m.color}} />
                      <div style={{flex:1,minWidth:0}}>
                        <div className="tl-ms-name">{m.name}</div>
                        <div className="tl-ms-date">{m.date}</div>
                      </div>
                      <div className="tl-ms-actions">
                        <button className="tl-ms-btn" onClick={() => {
                          const name = prompt('Milestone name:', m.name);
                          if (name !== null) updateMilestone(m.id, { name });
                        }}>âœŽ</button>
                        <button className="tl-ms-btn" onClick={() => {
                          const date = prompt('Date (YYYY-MM-DD):', m.date);
                          if (date !== null) updateMilestone(m.id, { date });
                        }}>ðŸ“…</button>
                        <button className="tl-ms-btn del" onClick={() => {
                          if (confirm('Remove this milestone?')) removeMilestone(m.id);
                        }}>âœ•</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              {/* Timeline grid */}
              <div className="tl-grid-wrapper">
                <div className="tl-grid" style={{width: timelineData.totalPx}}>
                  {/* Ruler */}
                  <div className="tl-ruler">
                    <div className="tl-ruler-label">Swimlane</div>
                    <div className="tl-ruler-bar">
                      {timelineData.marks.map((m, i) => (
                        <div key={i} className="tl-ruler-mark" style={{width: m.width}}>{m.label}</div>
                      ))}
                      {/* Milestone flags in ruler */}
                      {timelineData.msPositions.map(m => (
                        <div key={m.id} className="tl-milestone-flag"
                          style={{left: m.px, background: m.color}}>
                          {m.name}
                        </div>
                      ))}
                    </div>
                  </div>
                  {/* Track rows */}
                  {TRACKS.map(track => {
                    const laneCount = trackSubLaneCounts[track.key] || 1;
                    const trackHeight = Math.max(80, laneCount * 66 + 14);
                    return (
                    <div key={track.key} className="tl-track" style={{minHeight: trackHeight}}>
                      <div className="tl-track-label" style={{background: track.gradient}}>
                        <span>{track.label}</span>
                        <div className="sub-lane-controls">
                          <button className="sub-lane-btn" onClick={() => addSubLane(track.key)} title="Add parallel lane">+</button>
                          {laneCount > 1 && <button className="sub-lane-btn" onClick={() => removeSubLane(track.key)} title="Remove last lane">âˆ’</button>}
                          {laneCount > 1 && <span style={{fontSize:'9px',color:'rgba(255,255,255,0.6)'}}>{laneCount}</span>}
                        </div>
                      </div>
                      <div className="tl-track-bars" style={{width: timelineData.totalPx - 110, minHeight: trackHeight - 8}}>
                        {/* Sub-lane separator lines */}
                        {Array.from({length: laneCount - 1}, (_, i) => (
                          <div key={`sep-${i}`} className="tl-sublane-separator" style={{top: (i + 1) * 66}} />
                        ))}
                        {(timelineData.trackBars[track.key] || []).map((bar, i) => {
                          const d = bar.disciplines || {};
                          const dB = d.backend||0;
                          const dF = d.frontend||0;
                          const dN = d.natives||0;
                          const dQ = d.qa||0;
                          return (
                          <div key={bar.ghost ? `g-${bar.project.id}` : bar.project.id}
                            className={`tl-bar ${bar.ghost ? 'ghost' : ''} ${bar.project.inProgress ? 'in-progress' : ''} ${bar.hasOverride ? 'has-override' : ''}`}
                            style={{left: bar.left, width: bar.width, top: bar.laneIndex * 66 + 6, background: getBlockBg(bar.project.pillar, pillarColorMap)}}
                            onMouseEnter={(e) => handleMouseEnter(e, bar.project)}
                            onMouseLeave={handleMouseLeave}
                            onMouseDown={e => { if (!e.target.classList.contains('tl-bar-handle')) handleBarDragStart(e, bar, 'move'); }}
                            onDoubleClick={() => {
                              if (bar.hasOverride && confirm('Reset this bar to auto-layout?')) {
                                clearTimelineOverride(bar.project.id, bar.trackKey);
                              }
                            }}
                            title={`${bar.project.subTask}${bar.hasOverride ? ' (double-click to reset)' : ''}${bar.ghost ? ' (split from ' + (TRACKS.find(t=>t.key===bar.homeTrack)?.label||'') + ')' : ''}`}>
                            <div className="tl-bar-handle left"
                              onMouseDown={e => handleBarDragStart(e, bar, 'left')} />
                            <div className="tl-bar-row1">
                              <span className="tl-bar-label">{bar.project.subTask}</span>
                            </div>
                            <div className="tl-bar-row2">
                              {bar.project.nvrd && <span className="tl-bar-jira">{bar.project.nvrd}</span>}
                              <div className="tl-bar-disciplines">
                                {dB > 0 && <span>B:{dB}</span>}
                                {dF > 0 && <span>F:{dF}</span>}
                                {dN > 0 && <span>N:{dN}</span>}
                                {dQ > 0 && <span>Q:{dQ}</span>}
                              </div>
                            </div>
                            <div className="tl-bar-handle right"
                              onMouseDown={e => handleBarDragStart(e, bar, 'right')} />
                          </div>
                          );
                        })}
                        {/* Milestone lines in each track */}
                        {timelineData.msPositions.map(m => (
                          <div key={m.id} className="tl-milestone-line"
                            style={{left: m.px, background: m.color}} />
                        ))}
                      </div>
                    </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {splitModal && (() => {
        const { projectId, projectName, homeTrack } = splitModal;
        const proj = projectById[projectId];
        const fullSprints = proj ? projectSprints(proj) : { backend:0,frontend:0,natives:0,qa:0,total:0 };
        const existingSplits = splits[projectId] || {};
        const otherTracks = TRACKS.filter(t => t.key !== homeTrack);
        const [targetTrack, setTargetTrack] = [
          splitModal._targetTrack || otherTracks[0]?.key,
          (v) => setSplitModal(prev => ({ ...prev, _targetTrack: v }))
        ];
        const [splitSizing, setSplitSizing] = [
          splitModal._sizing || existingSplits[targetTrack] || { backend: 0, frontend: 0, natives: 0, qa: 0 },
          (v) => setSplitModal(prev => ({ ...prev, _sizing: typeof v === 'function' ? v(prev._sizing || existingSplits[prev._targetTrack || otherTracks[0]?.key] || { backend:0,frontend:0,natives:0,qa:0 }) : v }))
        ];
        // Calculate total split-out per discipline (existing + current form)
        const allSplitOut = { backend:0, frontend:0, natives:0, qa:0 };
        for (const [tk, sz] of Object.entries(existingSplits)) {
          if (tk === targetTrack) continue; // current form replaces this track's split
          allSplitOut.backend += (sz.backend||0);
          allSplitOut.frontend += (sz.frontend||0);
          allSplitOut.natives += (sz.natives||0);
          allSplitOut.qa += (sz.qa||0);
        }
        // Add current form values
        const totalOut = {
          backend: allSplitOut.backend + (splitSizing.backend||0),
          frontend: allSplitOut.frontend + (splitSizing.frontend||0),
          natives: allSplitOut.natives + (splitSizing.natives||0),
          qa: allSplitOut.qa + (splitSizing.qa||0),
        };
        const remaining = {
          backend: fullSprints.backend - totalOut.backend,
          frontend: fullSprints.frontend - totalOut.frontend,
          natives: fullSprints.natives - totalOut.natives,
          qa: fullSprints.qa - totalOut.qa,
        };
        const hasOverSplit = remaining.backend < 0 || remaining.frontend < 0 || remaining.natives < 0 || remaining.qa < 0;
        const homeLabel = TRACKS.find(t => t.key === homeTrack)?.label || homeTrack;
        return (
          <div className="split-modal-overlay" onClick={() => setSplitModal(null)}>
            <div className="split-modal" onClick={e => e.stopPropagation()}>
              <h3>Split: {projectName}</h3>
              <div style={{fontSize:11,color:'var(--text2)',marginBottom:8}}>
                Full sizing: B{fullSprints.backend} F{fullSprints.frontend} N{fullSprints.natives} Q{fullSprints.qa} = {fullSprints.total}sp
              </div>
              {Object.keys(existingSplits).length > 0 && (
                <div className="split-existing">
                  <div style={{fontSize:10,color:'var(--text2)',marginBottom:4,fontWeight:600}}>EXISTING SPLITS</div>
                  {Object.entries(existingSplits).map(([tk, sz]) => {
                    const tLabel = TRACKS.find(t => t.key === tk)?.label || tk;
                    const total = (sz.backend||0) + (sz.frontend||0) + (sz.natives||0) + (sz.qa||0);
                    return (
                      <div key={tk} className="split-existing-item">
                        <span>{tLabel}: B{sz.backend||0} F{sz.frontend||0} N{sz.natives||0} Q{sz.qa||0} = {total}sp</span>
                        <button className="btn-sm" style={{fontSize:10,padding:'2px 6px',background:'var(--red)',color:'white',border:'none',borderRadius:3,cursor:'pointer'}}
                          onClick={() => { removeSplit(projectId, tk); setSplitModal(prev => ({...prev})); }}>Remove</button>
                      </div>
                    );
                  })}
                </div>
              )}
              <div className="split-modal-fields">
                <div className="split-field-row">
                  <label>Target Lane</label>
                  <select value={targetTrack} onChange={e => {
                    const newTrack = e.target.value;
                    setSplitModal(prev => ({ ...prev, _targetTrack: newTrack, _sizing: existingSplits[newTrack] || { backend:0, frontend:0, natives:0, qa:0 } }));
                  }}>
                    {otherTracks.map(t => <option key={t.key} value={t.key}>{t.label}</option>)}
                  </select>
                </div>
                {['backend','frontend','natives','qa'].map(d => {
                  const max = fullSprints[d] - allSplitOut[d];
                  const isOver = (splitSizing[d]||0) > max;
                  return (
                    <div key={d} className="split-field-row">
                      <label>{d.charAt(0).toUpperCase()+d.slice(1)}</label>
                      <input type="number" min="0" max={max} step="0.5" value={splitSizing[d] || 0}
                        style={isOver ? {borderColor:'var(--red)',color:'var(--red)'} : {}}
                        onChange={e => setSplitSizing(prev => ({...prev, [d]: parseFloat(e.target.value)||0}))} />
                      <span style={{fontSize:10,color: isOver ? 'var(--red)' : 'var(--text2)'}}> / {max}sp max</span>
                    </div>
                  );
                })}
              </div>
              <div style={{fontSize:11,margin:'8px 0',padding:'6px 8px',borderRadius:6,background: hasOverSplit ? 'rgba(225,112,85,0.15)' : 'rgba(0,184,148,0.1)',border: `1px solid ${hasOverSplit ? 'var(--red)' : 'var(--green)'}`}}>
                Remaining in <strong>{homeLabel}</strong>: B{remaining.backend} F{remaining.frontend} N{remaining.natives} Q{remaining.qa}
                {hasOverSplit && <span style={{color:'var(--red)',fontWeight:600}}> â€” over-split!</span>}
              </div>
              <div className="split-modal-actions">
                <button className="btn-cancel" onClick={() => setSplitModal(null)}>Cancel</button>
                <button className="btn-save" onClick={() => {
                  const finalTarget = splitModal._targetTrack || otherTracks[0]?.key;
                  const finalSizing = splitModal._sizing || existingSplits[finalTarget] || { backend:0,frontend:0,natives:0,qa:0 };
                  saveSplit(projectId, finalTarget, finalSizing);
                  setSplitModal(null);
                }}>Save Split</button>
              </div>
            </div>
          </div>
        );
      })()}

      {/* Snapshot Modal */}
      {showSnapshots && (
        <div style={{position:'fixed',top:0,left:0,right:0,bottom:0,background:'rgba(0,0,0,0.6)',zIndex:9999,display:'flex',alignItems:'center',justifyContent:'center'}}
          onClick={() => setShowSnapshots(false)}>
          <div style={{background:'var(--surface1)',border:'1px solid var(--border)',borderRadius:12,padding:24,width:520,maxHeight:'80vh',overflow:'auto',boxShadow:'0 8px 32px rgba(0,0,0,0.4)'}}
            onClick={e => e.stopPropagation()}>
            <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
              <h3 style={{margin:0,fontSize:16,color:'var(--text1)'}}>ðŸ“¸ Scenario Snapshots</h3>
              <button onClick={() => setShowSnapshots(false)}
                style={{background:'none',border:'none',color:'var(--text2)',fontSize:18,cursor:'pointer'}}>âœ•</button>
            </div>

            {/* Save New Snapshot */}
            <div style={{background:'var(--surface2)',borderRadius:8,padding:12,marginBottom:16}}>
              <div style={{fontSize:11,fontWeight:600,color:'var(--text2)',marginBottom:8,textTransform:'uppercase'}}>Save Current State</div>
              <input value={snapshotName} onChange={e => setSnapshotName(e.target.value)}
                placeholder="Snapshot name (e.g., Sprint 5 Plan)"
                style={{width:'100%',padding:'6px 10px',background:'var(--bg)',border:'1px solid var(--border)',borderRadius:4,color:'var(--text1)',fontSize:12,marginBottom:6,boxSizing:'border-box'}} />
              <input value={snapshotDesc} onChange={e => setSnapshotDesc(e.target.value)}
                placeholder="Description (optional)"
                style={{width:'100%',padding:'6px 10px',background:'var(--bg)',border:'1px solid var(--border)',borderRadius:4,color:'var(--text1)',fontSize:12,marginBottom:8,boxSizing:'border-box'}} />
              <button onClick={saveSnapshot} disabled={!snapshotName.trim() || snapshotLoading}
                style={{padding:'6px 16px',background:'var(--accent1)',color:'#fff',border:'none',borderRadius:4,fontSize:11,fontWeight:600,cursor:snapshotName.trim()?'pointer':'default',opacity:snapshotName.trim()?1:0.5}}>
                {snapshotLoading ? 'Saving...' : 'Save Snapshot'}
              </button>
            </div>

            {/* Snapshot List */}
            <div style={{fontSize:11,fontWeight:600,color:'var(--text2)',marginBottom:8,textTransform:'uppercase'}}>
              Saved Snapshots ({snapshots.length})
            </div>
            {snapshots.length === 0 ? (
              <div style={{textAlign:'center',padding:20,color:'var(--text2)',fontSize:12}}>
                No snapshots saved yet. Save one above to get started.
              </div>
            ) : (
              <div style={{display:'flex',flexDirection:'column',gap:8}}>
                {snapshots.map(s => (
                  <div key={s.id} style={{background:'var(--surface2)',borderRadius:6,padding:'10px 12px',border:'1px solid var(--border)'}}>
                    <div style={{display:'flex',justifyContent:'space-between',alignItems:'center'}}>
                      <div>
                        <div style={{fontSize:13,fontWeight:600,color:'var(--text1)'}}>{s.name}</div>
                        {s.description && <div style={{fontSize:11,color:'var(--text2)',marginTop:2}}>{s.description}</div>}
                        <div style={{fontSize:10,color:'var(--text2)',marginTop:4}}>
                          {new Date(s.createdAt).toLocaleDateString()} {new Date(s.createdAt).toLocaleTimeString()}
                          {' Â· '}{s.projectCount} projects Â· by {s.createdBy?.split('@')[0]}
                        </div>
                      </div>
                      <div style={{display:'flex',gap:6}}>
                        <button onClick={() => restoreSnapshot(s.id, s.name)}
                          style={{padding:'4px 10px',background:'#0984e3',color:'#fff',border:'none',borderRadius:4,fontSize:10,fontWeight:600,cursor:'pointer'}}>
                          Restore
                        </button>
                        <button onClick={() => deleteSnapshot(s.id, s.name)}
                          style={{padding:'4px 10px',background:'none',color:'#e74c3c',border:'1px solid #e74c3c',borderRadius:4,fontSize:10,fontWeight:600,cursor:'pointer'}}>
                          Delete
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      )}
    </>
  );
}

const GOOGLE_CLIENT_ID = '487456084105-01l0m47e7up61qb40sf2v7gtjmrp6hqt.apps.googleusercontent.com';
const ALLOWED_DOMAIN = 'novibet.com';
const GOOGLE_AUTH_KEY = 'cp_google_auth';

function decodeJwt(token) {
  try {
    const base64 = token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/');
    return JSON.parse(atob(base64));
  } catch { return null; }
}

function getStoredGoogleAuth() {
  try {
    const stored = localStorage.getItem(GOOGLE_AUTH_KEY);
    if (!stored) return null;
    const data = JSON.parse(stored);
    if (data.exp && data.exp * 1000 < Date.now() + 300000) {
      localStorage.removeItem(GOOGLE_AUTH_KEY);
      return null;
    }
    if (!data.email || !data.email.endsWith('@' + ALLOWED_DOMAIN)) {
      localStorage.removeItem(GOOGLE_AUTH_KEY);
      return null;
    }
    return data;
  } catch { return null; }
}

function AuthGate() {
  const [user, setUser] = useState(() => getStoredGoogleAuth());
  const [error, setError] = useState('');
  const googleBtnRef = useRef(null);

  useEffect(() => {
    if (user) return;
    const initGoogle = () => {
      if (!window.google?.accounts?.id) {
        setTimeout(initGoogle, 200);
        return;
      }
      window.google.accounts.id.initialize({
        client_id: GOOGLE_CLIENT_ID,
        callback: handleGoogleResponse,
        auto_select: true,
      });
      if (googleBtnRef.current) {
        window.google.accounts.id.renderButton(googleBtnRef.current, {
          theme: 'filled_black',
          size: 'large',
          width: 300,
          text: 'signin_with',
          shape: 'pill',
        });
      }
    };
    initGoogle();
  }, [user]);

  const handleGoogleResponse = useCallback((response) => {
    const payload = decodeJwt(response.credential);
    if (!payload) {
      setError('Failed to verify Google sign-in');
      return;
    }
    if (!payload.email || !payload.email.endsWith('@' + ALLOWED_DOMAIN)) {
      setError('Access denied. Use your company account.');
      return;
    }
    const userData = {
      email: payload.email,
      name: payload.name,
      picture: payload.picture,
      exp: payload.exp,
      credential: response.credential,
    };
    localStorage.setItem(GOOGLE_AUTH_KEY, JSON.stringify(userData));
    setUser(userData);
    setError('');
  }, []);

  const handleLogout = () => {
    localStorage.removeItem(GOOGLE_AUTH_KEY);
    setUser(null);
    if (window.google?.accounts?.id) {
      window.google.accounts.id.disableAutoSelect();
    }
  };

  if (user) return <ErrorBoundary><App onLogout={handleLogout} user={user} /></ErrorBoundary>;

  return (
    <div className="auth-gate">
      <div className="auth-box">
        <div className="auth-icon">ðŸ”’</div>
        <h2>Capacity Planner</h2>
        <p className="auth-domain">Sign in with your company account</p>

        <div className="auth-google-wrap">
          <div ref={googleBtnRef}></div>
        </div>

        {error && <div className="auth-msg">{error}</div>}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<AuthGate />);
</script>
</body>
</html>
