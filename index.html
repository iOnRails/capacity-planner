<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Capacity Planner</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #232733;
    --border: #2e3345;
    --text: #e2e4eb;
    --text2: #8b90a0;
    --accent: #6c5ce7;
    --accent2: #a29bfe;
    --green: #00b894;
    --yellow: #fdcb6e;
    --red: #e17055;
    --orange: #e67e22;
    --blue: #0984e3;
    --pink: #e84393;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* â”€â”€ Header â”€â”€ */
  .app-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 28px; background: var(--surface);
    border-bottom: 1px solid var(--border);
    position: sticky; top: 0; z-index: 100;
  }
  .app-header h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.3px; }
  .app-header h1 span { color: var(--accent2); }
  .header-right { display: flex; gap: 12px; align-items: center; }

  /* â”€â”€ Vertical Selector â”€â”€ */
  .vertical-selector { display: flex; align-items: center; gap: 8px; }
  .vertical-selector label {
    font-size: 11px; color: var(--text2); text-transform: uppercase;
    letter-spacing: 0.8px; font-weight: 600;
  }
  .vertical-select {
    padding: 7px 32px 7px 14px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    color: var(--text); font-size: 14px; font-weight: 700;
    outline: none; cursor: pointer; appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b90a0'%3E%3Cpath d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 10px center;
    transition: border-color 0.15s;
  }
  .vertical-select:hover, .vertical-select:focus { border-color: var(--accent); }

  /* â”€â”€ Config Panel â”€â”€ */
  .config-bar {
    background: var(--surface); border-bottom: 1px solid var(--border);
    padding: 14px 28px; display: flex; gap: 28px; align-items: flex-end; flex-wrap: wrap;
  }
  .config-bar > .section-title { width: 100%; margin-bottom: 0; }
  .section-title {
    font-size: 15px; font-weight: 700; color: var(--text); margin-bottom: 10px;
    letter-spacing: -0.2px;
  }
  .section-title .section-icon { margin-right: 6px; }
  .config-section h3 {
    font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
    color: var(--text2); margin-bottom: 6px; font-weight: 600;
  }
  .config-inputs { display: flex; gap: 10px; flex-wrap: wrap; }
  .config-field { display: flex; flex-direction: column; gap: 3px; }
  .config-field label { font-size: 10px; color: var(--text2); font-weight: 500; }
  .config-field input {
    width: 64px; padding: 5px 8px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 6px;
    color: var(--text); font-size: 13px; font-weight: 600;
    text-align: center; outline: none;
  }
  .config-field input:focus { border-color: var(--accent); }
  .size-mapping { display: flex; gap: 5px; align-items: center; }
  .size-chip { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .size-chip span { font-size: 9px; color: var(--text2); font-weight: 600; }
  .size-chip input {
    width: 40px; padding: 3px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; text-align: center; outline: none;
  }
  .size-chip input:focus { border-color: var(--accent); }

  /* â”€â”€ Capacity Bars â”€â”€ */
  .capacity-overview {
    padding: 14px 28px; display: flex; gap: 14px; flex-wrap: wrap;
    background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .capacity-overview > .section-title { width: 100%; margin-bottom: 2px; }
  .cap-bar-container { flex: 1; min-width: 160px; }
  .cap-bar-label {
    display: flex; justify-content: space-between;
    font-size: 11px; margin-bottom: 3px; font-weight: 500;
  }
  .cap-bar-track {
    height: 18px; background: var(--bg); border-radius: 5px;
    overflow: hidden; border: 1px solid var(--border);
  }
  .cap-bar-fill {
    height: 100%; border-radius: 4px; transition: width 0.4s ease, background 0.3s;
    display: flex; align-items: center; justify-content: flex-end;
    padding-right: 5px; font-size: 9px; font-weight: 700;
    color: rgba(255,255,255,0.9);
  }
  .cap-total {
    flex: 1; min-width: 160px; background: var(--surface2);
    border-radius: 8px; padding: 6px 12px; border: 1px solid var(--border);
  }
  .cap-total .cap-bar-label { font-weight: 700; font-size: 12px; }

  /* â”€â”€ Track Capacity Allocation â”€â”€ */
  .track-alloc-section {
    padding: 14px 28px; background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .track-alloc-section h3 { font-size: 15px; font-weight: 700; margin: 0 0 10px 0; color: var(--text); }
  .track-alloc-grid {
    display: grid; grid-template-columns: 120px repeat(4, 1fr) auto; gap: 6px 10px; align-items: center;
  }
  .track-alloc-header { font-size: 10px; text-transform: uppercase; color: var(--muted); font-weight: 600; letter-spacing: 0.5px; }
  .track-alloc-label { font-size: 12px; font-weight: 600; color: var(--text); }
  .track-alloc-input {
    width: 100%; padding: 4px 6px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px; text-align: center; outline: none;
  }
  .track-alloc-input:focus { border-color: var(--accent); }
  .track-alloc-input.over-cap { border-color: #e17055; background: rgba(225,112,85,0.1); }
  .track-alloc-remaining { font-size: 11px; text-align: center; }
  .track-alloc-remaining.ok { color: #00b894; }
  .track-alloc-remaining.warn { color: #fdcb6e; }
  .track-alloc-remaining.over { color: #e17055; font-weight: 700; }
  .track-cap-bar { margin-top: 2px; height: 4px; background: var(--bg); border-radius: 2px; overflow: hidden; }
  .track-cap-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }

  /* â”€â”€ Total Demand â”€â”€ */
  .demand-section {
    padding: 14px 28px; display: flex; gap: 16px; flex-wrap: wrap;
    background: var(--surface); border-bottom: 1px solid var(--border); align-items: stretch;
  }
  .demand-section > .section-title { width: 100%; margin-bottom: 2px; align-self: flex-start;
  }
  .demand-card {
    flex: 1; min-width: 150px; background: var(--surface2); border-radius: 8px;
    padding: 10px 14px; border: 1px solid var(--border); display: flex; flex-direction: column; gap: 6px;
  }
  .demand-card-title { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); font-weight: 600; }
  .demand-card-value { font-size: 20px; font-weight: 700; color: var(--text); }
  .demand-card-buffered { font-size: 11px; color: var(--accent); font-weight: 500; }
  .demand-buffer-row { display: flex; align-items: center; gap: 6px; margin-top: 2px; }
  .demand-buffer-btn {
    width: 22px; height: 22px; border-radius: 4px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text); font-size: 13px; font-weight: 700;
    cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s;
    padding: 0; line-height: 1;
  }
  .demand-buffer-btn:hover { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .demand-buffer-pct { font-size: 11px; color: var(--muted); min-width: 36px; text-align: center; }

  /* â”€â”€ Filters â”€â”€ */
  .filters-bar {
    padding: 10px 28px; display: flex; gap: 8px; flex-wrap: wrap;
    align-items: center; background: var(--surface); border-bottom: 1px solid var(--border);
  }
  .filter-group { position: relative; }
  .filter-btn {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; cursor: pointer;
    display: flex; align-items: center; gap: 5px; transition: all 0.15s;
  }
  .filter-btn:hover { border-color: var(--accent); }
  .filter-btn.active { border-color: var(--accent); background: rgba(108,92,231,0.15); }
  .filter-btn .count {
    background: var(--accent); color: white; font-size: 9px;
    padding: 1px 5px; border-radius: 10px; font-weight: 700;
  }
  .filter-dropdown {
    position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; padding: 6px; z-index: 50; min-width: 150px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
  }
  .filter-dropdown.open { display: block; }
  .filter-option {
    display: flex; align-items: center; gap: 6px; padding: 5px 8px;
    border-radius: 4px; cursor: pointer; font-size: 11px;
  }
  .filter-option:hover { background: rgba(255,255,255,0.05); }
  .filter-option input[type="checkbox"] { accent-color: var(--accent); }
  .search-input {
    padding: 5px 12px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 11px; outline: none; width: 200px;
  }
  .search-input:focus { border-color: var(--accent); }
  .search-input::placeholder { color: var(--text2); }
  .sort-controls { display: flex; gap: 5px; align-items: center; }
  .sort-controls select {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none; cursor: pointer;
  }

  /* â”€â”€ Btn â”€â”€ */
  .btn {
    padding: 5px 14px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn:hover { border-color: var(--accent); }
  .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-primary:hover { background: var(--accent2); }

  /* â”€â”€ Lane (horizontal) â”€â”€ */
  .lane-section { padding: 0 28px 8px; }
  .lane-header-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 28px 10px; margin: 0 -28px;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .lane-header-row h2 {
    font-size: 16px; font-weight: 700; display: flex; align-items: center; gap: 8px;
  }
  .badge {
    font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 700;
  }
  .roadmap-badge { background: rgba(0,184,148,0.2); color: var(--green); }
  .backlog-badge { background: rgba(139,144,160,0.2); color: var(--text2); }
  .lane-stats {
    display: flex; gap: 8px; align-items: center;
  }
  .stat-chip {
    font-size: 10px; padding: 3px 8px; background: var(--surface);
    border-radius: 6px; color: var(--text2); font-weight: 500;
  }
  .stat-chip strong { color: var(--text); }

  /* â”€â”€ Flow Container â”€â”€ */
  .flow-container {
    display: flex; flex-wrap: wrap; gap: 6px; padding: 10px;
    min-height: 80px; border-radius: 10px;
    background: var(--surface); border: 1px solid var(--border);
    transition: all 0.2s;
    margin-top: 10px;
  }
  .flow-container.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
    box-shadow: inset 0 0 20px rgba(108,92,231,0.08);
  }
  .flow-container.roadmap-flow { border-color: rgba(0,184,148,0.25); }
  .empty-flow {
    width: 100%; display: flex; align-items: center; justify-content: center;
    min-height: 70px; color: var(--text2); font-size: 12px;
    border: 2px dashed var(--border); border-radius: 8px;
  }

  /* â”€â”€ Track (sub-lane within roadmap) â”€â”€ */
  .track-group { margin-top: 10px; }
  .track-row {
    display: flex; align-items: stretch; gap: 0;
  }
  .track-label {
    writing-mode: vertical-lr; text-orientation: mixed;
    transform: rotate(180deg);
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; font-weight: 700; letter-spacing: 0.5px;
    padding: 10px 8px; border-radius: 10px 0 0 10px;
    min-width: 36px; text-align: center; white-space: nowrap;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .track-flow {
    display: flex; flex-wrap: wrap; gap: 8px; padding: 12px;
    min-height: 80px; border-radius: 0 10px 10px 0;
    background: var(--surface); border: 1px solid var(--border);
    border-left: none; flex: 1; transition: all 0.2s;
    align-content: flex-start;
  }
  .track-flow.drag-over {
    background: rgba(108,92,231,0.06);
    border-color: var(--accent);
  }
  .track-divider {
    height: 1px; background: var(--border); margin: 2px 0 2px 36px; opacity: 0.5;
  }
  .track-empty {
    display: flex; align-items: center; justify-content: center;
    width: 100%; min-height: 50px; color: var(--text2); font-size: 12px;
    border: 1px dashed var(--border); border-radius: 6px;
    font-style: italic;
  }

  /* â”€â”€ Project Block (proportional) â”€â”€ */
  .project-block {
    position: relative; border-radius: 8px; cursor: grab;
    transition: all 0.15s; user-select: none; overflow: hidden;
    display: flex; flex-direction: column; justify-content: space-between;
    border: 1px solid transparent;
  }
  .project-block:hover {
    border-color: rgba(255,255,255,0.3);
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    transform: translateY(-2px);
    z-index: 5;
  }
  .project-block.dragging { opacity: 0.3; transform: scale(0.95); }
  .project-block.in-progress { box-shadow: inset 0 0 0 2px var(--green); }

  /* â”€â”€ Overflow indicator â”€â”€ */
  .project-block.overflow-block {
    border: 2px solid #ff4444 !important;
    box-shadow: 0 0 12px rgba(255,68,68,0.5), inset 0 0 0 1px rgba(255,68,68,0.3);
    animation: overflow-pulse 1.5s ease-in-out infinite alternate;
  }
  @keyframes overflow-pulse {
    from { box-shadow: 0 0 8px rgba(255,68,68,0.4), inset 0 0 0 1px rgba(255,68,68,0.2); }
    to { box-shadow: 0 0 16px rgba(255,68,68,0.7), inset 0 0 0 1px rgba(255,68,68,0.4); }
  }
  .overflow-badge {
    position: absolute; top: 4px; left: 4px; z-index: 10;
    background: #ff4444; color: white; font-size: 9px; font-weight: 800;
    padding: 2px 6px; border-radius: 3px; letter-spacing: 0.3px;
    text-shadow: 0 1px 1px rgba(0,0,0,0.3); line-height: 1.2;
    pointer-events: none;
  }

  .block-content {
    padding: 10px 12px; display: flex; flex-direction: column;
    height: 100%; overflow: hidden;
  }
  .overflow-block .block-content { padding-top: 20px; }
  .ghost-block .block-content { padding-top: 20px; }
  .block-title {
    font-size: 12px; font-weight: 600; line-height: 1.3;
    overflow: hidden; text-overflow: ellipsis;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .block-bottom {
    display: flex; justify-content: space-between; align-items: flex-end;
    margin-top: auto; padding-top: 4px;
  }
  .block-jira {
    font-size: 10px; color: rgba(255,255,255,0.7); font-weight: 600;
  }
  .block-sprints {
    font-size: 11px; font-weight: 800; color: white;
    background: rgba(0,0,0,0.3); padding: 2px 7px; border-radius: 4px;
  }
  .block-pillar-line {
    height: 3px; width: 100%; opacity: 0.8;
  }

  /* â”€â”€ Ghost block (split allocation) â”€â”€ */
  .project-block.ghost-block {
    border: 2px dashed rgba(162,155,254,0.6) !important;
    opacity: 0.75;
    background: repeating-linear-gradient(
      -45deg, transparent, transparent 4px, rgba(0,0,0,0.08) 4px, rgba(0,0,0,0.08) 8px
    ) !important;
  }
  .project-block.ghost-block:hover { opacity: 0.9; }
  .ghost-origin {
    position: absolute; bottom: 3px; left: 6px; font-size: 8px; font-weight: 700;
    color: rgba(162,155,254,0.9); pointer-events: none; letter-spacing: 0.3px;
  }
  .ghost-link-icon {
    position: absolute; top: 3px; right: 22px; font-size: 10px; z-index: 10;
    pointer-events: none;
  }

  /* â”€â”€ Split button on block â”€â”€ */
  .block-split {
    position: absolute; top: 4px; right: 26px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-split { opacity: 1; }
  .block-split:hover { background: var(--accent); }

  /* â”€â”€ Split modal â”€â”€ */
  .split-modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    z-index: 300; display: flex; align-items: center; justify-content: center;
  }
  .split-modal {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 12px; padding: 20px; min-width: 340px;
    box-shadow: 0 16px 48px rgba(0,0,0,0.5);
  }
  .split-modal h3 { font-size: 14px; margin-bottom: 12px; }
  .split-modal-fields { display: flex; flex-direction: column; gap: 8px; margin-bottom: 14px; }
  .split-field-row { display: flex; align-items: center; gap: 10px; }
  .split-field-row label { width: 70px; font-size: 12px; font-weight: 500; }
  .split-field-row select, .split-field-row input {
    flex: 1; padding: 6px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px;
  }
  .split-modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
  .split-modal-actions button {
    padding: 6px 16px; border-radius: 6px; border: 1px solid var(--border);
    font-size: 12px; cursor: pointer; transition: all 0.15s;
  }
  .split-modal-actions .btn-save { background: var(--accent); color: white; border-color: var(--accent); }
  .split-modal-actions .btn-save:hover { opacity: 0.8; }
  .split-modal-actions .btn-cancel { background: var(--surface); color: var(--text); }
  .split-modal-actions .btn-cancel:hover { background: var(--surface2); }
  .split-modal-actions .btn-remove { background: var(--red); color: white; border-color: var(--red); }
  .split-modal-actions .btn-remove:hover { opacity: 0.8; }
  .split-existing { margin-bottom: 12px; padding: 8px; background: var(--bg); border-radius: 6px; }
  .split-existing-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 4px 0; font-size: 11px;
  }

  /* â”€â”€ Move button on block â”€â”€ */
  .block-move {
    position: absolute; top: 4px; right: 4px; width: 20px; height: 20px;
    border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; opacity: 0; transition: opacity 0.15s;
    background: rgba(0,0,0,0.5); color: white;
  }
  .project-block:hover .block-move { opacity: 1; }
  .block-move:hover { background: var(--accent); }

  /* â”€â”€ Tooltip â”€â”€ */
  .tooltip-overlay {
    position: fixed; z-index: 200; pointer-events: none;
  }
  .tooltip-card {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 10px; padding: 14px 16px; width: 320px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  }
  .tooltip-card .tt-title { font-size: 13px; font-weight: 700; margin-bottom: 8px; }
  .tooltip-card .tt-meta { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 8px; }
  .tooltip-card .tt-efforts { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 6px; }
  .tooltip-card .tt-total {
    font-size: 12px; font-weight: 700; color: var(--accent2); text-align: right;
  }
  .pill {
    font-size: 10px; padding: 2px 8px; border-radius: 10px;
    font-weight: 600; white-space: nowrap;
  }
  .pill-pillar { opacity: 0.9; color: white; }
  .pill-expansion { background: #00b894; }
  .pill-acquisition { background: #0984e3; }
  .pill-core-platform { background: #6c5ce7; }
  .pill-comms { background: #e67e22; }
  .pill-gamification { background: #e84393; }
  .pill-core-bonus { background: #fdcb6e; color: #333; }
  .pill-market { background: rgba(255,255,255,0.08); color: var(--text2); }
  .pill-kpi { background: rgba(9,132,227,0.15); color: var(--blue); }
  .pill-impact { font-weight: 700; }
  .impact-XS { background: rgba(139,144,160,0.15); color: var(--text2); }
  .impact-S { background: rgba(0,184,148,0.12); color: var(--green); }
  .impact-M { background: rgba(9,132,227,0.15); color: var(--blue); }
  .impact-L { background: rgba(108,92,231,0.15); color: var(--accent2); }
  .impact-XL { background: rgba(230,126,34,0.15); color: var(--orange); }
  .impact-XXL { background: rgba(225,112,85,0.15); color: var(--red); }
  .impact-XXXL { background: rgba(225,112,85,0.25); color: var(--red); }
  .effort-tag {
    font-size: 10px; padding: 2px 6px; border-radius: 4px;
    background: rgba(255,255,255,0.06); color: var(--text2); font-weight: 500;
  }
  .effort-tag .val { font-weight: 700; color: var(--text); }

  /* â”€â”€ Empty Vertical â”€â”€ */
  .empty-vertical {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; padding: 80px 40px; text-align: center; gap: 16px;
  }
  .empty-vertical-icon {
    width: 80px; height: 80px; border-radius: 20px; background: var(--surface2);
    border: 2px dashed var(--border); display: flex; align-items: center;
    justify-content: center; font-size: 32px;
  }
  .empty-vertical h2 { font-size: 18px; font-weight: 700; }
  .empty-vertical p { font-size: 13px; color: var(--text2); max-width: 400px; line-height: 1.5; }
  .empty-vertical code {
    background: var(--surface2); padding: 2px 8px; border-radius: 4px;
    font-size: 12px; color: var(--accent2);
  }

  /* â”€â”€ Scroll â”€â”€ */
  .main-scroll { overflow-y: auto; padding-bottom: 40px; }
  .main-scroll::-webkit-scrollbar { width: 6px; }
  .main-scroll::-webkit-scrollbar-track { background: transparent; }
  .main-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* â”€â”€ Color-by legend â”€â”€ */
  .color-legend {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
  }
  .legend-item {
    display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text2);
  }
  .legend-dot {
    width: 10px; height: 10px; border-radius: 3px;
  }

  /* â”€â”€ Tab Switcher â”€â”€ */
  .tab-switcher { display: flex; gap: 4px; background: var(--bg); border-radius: 8px; padding: 3px; }
  .tab-btn {
    padding: 6px 16px; border: none; border-radius: 6px; cursor: pointer;
    font-size: 12px; font-weight: 600; transition: all 0.15s;
    background: transparent; color: var(--text2);
  }
  .tab-btn:hover { color: var(--text); }
  .tab-btn.active { background: var(--accent); color: white; }

  /* â”€â”€ Projects Table â”€â”€ */
  .projects-container {
    padding: 20px 28px; overflow-y: auto;
    max-height: calc(100vh - 70px);
  }
  .projects-toolbar {
    display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;
  }
  .projects-table {
    width: 100%; border-collapse: collapse; font-size: 12px;
  }
  .projects-table th {
    text-align: left; padding: 8px 6px; border-bottom: 2px solid var(--border);
    background: var(--surface); font-size: 10px; text-transform: uppercase;
    font-weight: 700; letter-spacing: 0.5px; color: var(--text2);
    position: sticky; top: 0; z-index: 10;
  }
  .projects-table td {
    padding: 2px 3px; border-bottom: 1px solid var(--border);
    max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .projects-table tbody tr:hover { background: var(--surface2); }
  .projects-table tbody tr.editing-row { background: rgba(108,92,231,0.08); }

  .cell-view {
    padding: 4px 6px; cursor: pointer; border-radius: 4px;
    min-height: 28px; display: flex; align-items: center;
  }
  .cell-view:hover { background: rgba(108,92,231,0.1); }
  .cell-input {
    width: 100%; padding: 4px 6px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none;
    font-family: inherit;
  }
  .cell-select {
    width: 100%; padding: 4px 4px; background: var(--bg);
    border: 1px solid var(--accent); border-radius: 4px;
    color: var(--text); font-size: 12px; outline: none; cursor: pointer;
  }
  .btn-icon {
    width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text2); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; transition: all 0.15s;
  }
  .btn-icon:hover { border-color: var(--accent); color: var(--text); }
  .btn-icon.danger:hover { border-color: var(--red); color: var(--red); background: rgba(225,112,85,0.1); }

  .project-count-badge {
    font-size: 11px; color: var(--text2); padding: 4px 10px;
    background: var(--surface); border-radius: 6px;
  }

  /* â”€â”€ Bulk Actions â”€â”€ */
  .bulk-bar {
    display: flex; gap: 10px; align-items: center; padding: 10px 16px;
    background: rgba(108,92,231,0.12); border: 1px solid var(--accent);
    border-radius: 8px; margin-bottom: 12px;
  }
  .bulk-bar .bulk-count {
    font-size: 12px; font-weight: 700; color: var(--accent2);
  }
  .bulk-bar .bulk-sep {
    width: 1px; height: 20px; background: var(--border);
  }
  .bulk-edit-group {
    display: flex; gap: 6px; align-items: center;
  }
  .bulk-edit-group select, .bulk-edit-group input {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 11px; outline: none;
  }
  .bulk-edit-group select:focus, .bulk-edit-group input:focus { border-color: var(--accent); }
  .btn-sm {
    padding: 4px 10px; border-radius: 5px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); font-size: 11px;
    cursor: pointer; font-weight: 500; transition: all 0.15s;
  }
  .btn-sm:hover { border-color: var(--accent); }
  .btn-sm.danger { border-color: var(--red); color: var(--red); }
  .btn-sm.danger:hover { background: rgba(225,112,85,0.15); }
  .btn-sm.apply { background: var(--accent); border-color: var(--accent); color: white; }
  .btn-sm.apply:hover { background: var(--accent2); }

  .row-checkbox {
    accent-color: var(--accent); cursor: pointer; width: 14px; height: 14px;
  }
  .projects-table th.check-col, .projects-table td.check-col {
    width: 30px; text-align: center; padding: 4px;
  }

  /* â”€â”€ Drop Indicator â”€â”€ */
  .drop-indicator {
    width: 3px; min-height: 70px; background: var(--accent);
    border-radius: 2px; flex-shrink: 0;
    box-shadow: 0 0 8px rgba(108,92,231,0.6);
    animation: pulse-indicator 0.8s ease-in-out infinite alternate;
  }
  @keyframes pulse-indicator {
    from { opacity: 0.6; }
    to { opacity: 1; }
  }

  /* â”€â”€ Timeline / Gantt Overlay â”€â”€ */
  .timeline-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    z-index: 500; display: flex; align-items: center; justify-content: center;
    animation: tl-fade-in 0.2s ease-out;
  }
  @keyframes tl-fade-in { from { opacity: 0; } to { opacity: 1; } }
  @keyframes tl-slide-up { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

  .timeline-modal {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 14px; width: 96vw; height: 92vh;
    display: flex; flex-direction: column; overflow: hidden;
    box-shadow: 0 24px 80px rgba(0,0,0,0.7);
    animation: tl-slide-up 0.3s ease-out;
  }

  /* Header */
  .tl-header {
    display: flex; align-items: center; gap: 16px; padding: 12px 20px;
    background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  .tl-header h2 { font-size: 16px; font-weight: 700; white-space: nowrap; }
  .tl-controls { display: flex; gap: 12px; align-items: center; flex: 1; flex-wrap: wrap; }
  .tl-ctrl-group { display: flex; align-items: center; gap: 4px; }
  .tl-ctrl-group label { font-size: 11px; color: var(--text2); font-weight: 600; }
  .tl-ctrl-group input, .tl-ctrl-group select {
    padding: 4px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 5px; color: var(--text); font-size: 12px; outline: none;
  }
  .tl-ctrl-group input:focus, .tl-ctrl-group select:focus { border-color: var(--accent); }
  .tl-close {
    background: none; border: none; font-size: 22px; color: var(--text2);
    cursor: pointer; padding: 4px 8px; border-radius: 6px; margin-left: auto;
  }
  .tl-close:hover { color: var(--text); background: var(--surface2); }
  .tl-btn {
    padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--accent); color: white; font-size: 11px; font-weight: 600;
    cursor: pointer; white-space: nowrap;
  }
  .tl-btn:hover { opacity: 0.85; }
  .tl-btn-outline { background: var(--surface2); color: var(--text); }

  /* Body layout */
  .tl-body { display: flex; flex: 1; overflow: hidden; }
  .tl-sidebar {
    width: 220px; background: var(--surface); border-right: 1px solid var(--border);
    display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0;
  }
  .tl-sidebar-header {
    padding: 12px 14px; font-size: 13px; font-weight: 700; color: var(--text);
    border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;
  }
  .tl-sidebar-content { padding: 8px; flex: 1; overflow-y: auto; }
  .tl-ms-item {
    display: flex; gap: 8px; padding: 8px 10px; margin-bottom: 4px;
    background: var(--surface2); border-radius: 8px; align-items: flex-start;
    border: 1px solid transparent; transition: border-color 0.15s;
  }
  .tl-ms-item:hover { border-color: var(--border); }
  .tl-ms-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; margin-top: 3px; }
  .tl-ms-name { font-size: 12px; font-weight: 600; color: var(--text); }
  .tl-ms-date { font-size: 10px; color: var(--text2); margin-top: 1px; }
  .tl-ms-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s; margin-left: auto; }
  .tl-ms-item:hover .tl-ms-actions { opacity: 1; }
  .tl-ms-btn {
    padding: 2px 6px; background: var(--surface); color: var(--text2);
    border: 1px solid var(--border); border-radius: 3px; font-size: 10px; cursor: pointer;
  }
  .tl-ms-btn:hover { color: var(--text); border-color: var(--text2); }
  .tl-ms-btn.del:hover { color: var(--red); border-color: var(--red); }
  .tl-ms-empty { font-size: 11px; color: var(--text2); padding: 16px; text-align: center; }

  /* Grid area */
  .tl-grid-wrapper { flex: 1; overflow: auto; position: relative; }
  .tl-grid { display: flex; flex-direction: column; min-width: 100%; }

  /* Ruler */
  .tl-ruler {
    display: flex; position: sticky; top: 0; z-index: 10;
    background: var(--surface); border-bottom: 1px solid var(--border);
    padding-top: 20px; /* space for milestone flags */
  }
  .tl-ruler-label {
    width: 110px; min-width: 110px; padding: 8px 10px; font-size: 10px;
    font-weight: 600; color: var(--text2); text-transform: uppercase;
    border-right: 1px solid var(--border); display: flex; align-items: flex-end;
  }
  .tl-ruler-bar { display: flex; position: relative; flex: 1; }
  .tl-ruler-mark {
    font-size: 10px; color: var(--text2); padding: 4px 6px; text-align: center;
    border-right: 1px solid var(--border); display: flex; align-items: flex-end;
    justify-content: center; font-weight: 500; box-sizing: border-box; flex-shrink: 0;
  }

  /* Track rows */
  .tl-track {
    display: flex; border-bottom: 1px solid var(--border); min-height: 80px;
  }
  .tl-track-label {
    width: 110px; min-width: 110px; padding: 8px 10px;
    font-size: 12px; font-weight: 700; color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    border-right: 1px solid var(--border);
    display: flex; flex-direction: column; justify-content: center; align-items: flex-start;
  }
  .tl-track-bars {
    position: relative; flex: 1; padding: 6px 0; min-height: 72px;
  }

  /* Project bars â€” tall with room for info */
  .tl-bar {
    position: absolute; height: 60px; border-radius: 8px;
    display: flex; flex-direction: column; justify-content: center;
    padding: 6px 14px; cursor: grab;
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 2px 6px rgba(0,0,0,0.2); overflow: hidden;
    transition: box-shadow 0.15s, border-color 0.15s;
    user-select: none;
  }
  .tl-bar:active { cursor: grabbing; }
  .tl-bar:hover {
    box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    border-color: rgba(255,255,255,0.3); z-index: 5;
  }
  .tl-bar-row1 {
    display: flex; align-items: center; gap: 6px;
  }
  .tl-bar-label {
    font-size: 12px; font-weight: 600; color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    flex: 1; min-width: 0;
  }
  .tl-bar-sp {
    font-size: 9px; font-weight: 800; color: rgba(255,255,255,0.9);
    background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; flex-shrink: 0;
  }
  .tl-bar-row2 {
    display: flex; gap: 6px; align-items: center; margin-top: 3px;
  }
  .tl-bar-jira {
    font-size: 9px; color: rgba(255,255,255,0.6); font-weight: 600;
  }
  .tl-bar-disciplines {
    display: flex; gap: 4px; font-size: 8px; font-weight: 700;
    color: rgba(255,255,255,0.7);
  }
  .tl-bar-disciplines span {
    background: rgba(0,0,0,0.2); padding: 1px 4px; border-radius: 2px;
  }
  .tl-bar.ghost {
    border-style: dashed; opacity: 0.6;
  }
  .tl-bar.in-progress {
    box-shadow: 0 2px 6px rgba(0,0,0,0.2), inset 0 0 0 2px var(--green);
  }
  .tl-bar.has-override {
    border-color: var(--yellow); border-width: 2px;
  }

  /* Sub-lane controls */
  .sub-lane-controls { display: flex; gap: 3px; align-items: center; margin-top: 6px; }
  .sub-lane-btn {
    padding: 1px 5px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2);
    border-radius: 3px; color: white; font-size: 10px; font-weight: 600; cursor: pointer;
    transition: all 0.15s; line-height: 1.3;
  }
  .sub-lane-btn:hover { background: rgba(255,255,255,0.25); border-color: rgba(255,255,255,0.35); }

  /* Sub-lane separator lines */
  .tl-sublane-separator {
    position: absolute; left: 0; right: 0; height: 1px;
    background: rgba(255,255,255,0.08); pointer-events: none;
  }

  /* Drag handles for resizing */
  .tl-bar-handle {
    position: absolute; top: 0; width: 8px; height: 100%; cursor: col-resize;
    z-index: 6; opacity: 0; transition: opacity 0.15s;
  }
  .tl-bar:hover .tl-bar-handle { opacity: 1; }
  .tl-bar-handle.left { left: 0; border-radius: 8px 0 0 8px; background: linear-gradient(90deg, rgba(255,255,255,0.3), transparent); }
  .tl-bar-handle.right { right: 0; border-radius: 0 8px 8px 0; background: linear-gradient(-90deg, rgba(255,255,255,0.3), transparent); }

  /* Milestone lines */
  .tl-milestone-line {
    position: absolute; top: 0; bottom: 0; width: 2px; z-index: 4;
    pointer-events: none;
  }
  .tl-milestone-flag {
    position: absolute; top: 2px; transform: translateX(-50%);
    font-size: 9px; font-weight: 700; color: white; padding: 2px 6px;
    border-radius: 3px; white-space: nowrap; pointer-events: auto; cursor: default;
    z-index: 11;
  }

  /* Timeline trigger button */
  .btn-timeline {
    padding: 6px 14px; background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600;
    cursor: pointer; white-space: nowrap; transition: all 0.15s;
    box-shadow: 0 2px 8px rgba(108,92,231,0.3);
  }
  .btn-timeline:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(108,92,231,0.4); }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useMemo, useCallback, useRef, useEffect } = React;

const VERTICALS = [
  { key: 'growth', label: 'Growth', color: '#6c5ce7', icon: 'ðŸ“ˆ' },
  { key: 'sportsbook', label: 'Sportsbook', color: '#00b894', icon: 'âš½' },
  { key: 'casino', label: 'Casino', color: '#e84393', icon: 'ðŸŽ°' },
  { key: 'account', label: 'Account', color: '#0984e3', icon: 'ðŸ‘¤' },
  { key: 'payments', label: 'Payments', color: '#fdcb6e', icon: 'ðŸ’³' },
];

// â”€â”€ API Configuration â”€â”€
// Set this to your Railway API URL after deploying, e.g. 'https://your-app.railway.app'
const API_URL = window.API_URL || 'https://capacity-planner-production-1cf7.up.railway.app';

const DEFAULT_SIZE_MAP = { XS: 0.5, S: 1, M: 2, L: 3, XL: 5, XXL: 8, XXXL: 13 };
const DEFAULT_TRACK_CAPACITY = {
  'core-bonus': { backend: 0, frontend: 0, natives: 0, qa: 0 },
  'gateway': { backend: 0, frontend: 0, natives: 0, qa: 0 },
  'seo-aff': { backend: 0, frontend: 0, natives: 0, qa: 0 },
};
const DEFAULT_CAPACITY = { backend: 40, frontend: 30, natives: 25, qa: 20 };

const PILLAR_COLORS = {
  'Expansion': '#00b894', 'Acquisition': '#0984e3', 'Core Platform': '#6c5ce7',
  'Comms': '#e67e22', 'Gamification': '#e84393', 'Core Bonus': '#fdcb6e',
};
const PILLAR_CLASSES = {
  'Expansion': 'pill-expansion', 'Acquisition': 'pill-acquisition',
  'Core Platform': 'pill-core-platform', 'Comms': 'pill-comms',
  'Gamification': 'pill-gamification', 'Core Bonus': 'pill-core-bonus',
};

function getCapColor(pct) {
  if (pct <= 70) return 'var(--green)';
  if (pct <= 90) return 'var(--yellow)';
  return 'var(--red)';
}

function getBlockBg(pillar) {
  const c = PILLAR_COLORS[pillar] || '#6c5ce7';
  return `linear-gradient(135deg, ${c}cc, ${c}88)`;
}

// Migrate old track keys to new ones
function migrateTracks(tracks) {
  const result = { ...tracks };
  if ('gamification' in result && !('gateway' in result)) {
    result['gateway'] = result['gamification'];
    delete result['gamification'];
  }
  // Ensure all expected keys exist
  if (!result['core-bonus']) result['core-bonus'] = [];
  if (!result['gateway']) result['gateway'] = [];
  if (!result['seo-aff']) result['seo-aff'] = [];
  return result;
}

function migrateTrackCapacity(tc) {
  const result = tc ? JSON.parse(JSON.stringify(tc)) : {};
  const ZERO = { backend: 0, frontend: 0, natives: 0, qa: 0 };
  if (!result['core-bonus']) result['core-bonus'] = { ...ZERO };
  if (!result['gateway']) result['gateway'] = { ...ZERO };
  if (!result['seo-aff']) result['seo-aff'] = { ...ZERO };
  return result;
}

const BLOCK_HEIGHT = 94;
const MIN_WIDTH = 100;
const MAX_WIDTH = 360;
const PX_PER_SPRINT_WEEK = 50;
const DEFAULT_TIMELINE_CONFIG = {
  sprintStartDate: new Date().toISOString().split('T')[0],
  sprintDurationWeeks: 2,
  timeScale: 'months',
};
const MILESTONE_COLORS = ['#e84393','#fdcb6e','#00b894','#0984e3','#e67e22','#a29bfe','#e17055'];
const PX_PER_SPRINT = 20;

function App() {
  const [activeVertical, setActiveVertical] = useState('growth');
  const [sizeMap, setSizeMap] = useState({...DEFAULT_SIZE_MAP});
  const sizeMapRef = useRef(sizeMap);
  useEffect(() => { sizeMapRef.current = sizeMap; }, [sizeMap]);
  const [tooltip, setTooltip] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [activeTab, setActiveTab] = useState('planner');
  const [editingCell, setEditingCell] = useState(null);
  const [editValue, setEditValue] = useState('');
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [bulkField, setBulkField] = useState('pillar');
  const [bulkValue, setBulkValue] = useState('');
  const [saveStatus, setSaveStatus] = useState(null); // {type: 'ok'|'error', msg: '...'}
  const [buffer, setBuffer] = useState({ backend: 0, frontend: 0, natives: 0, qa: 0 });
  const [splitModal, setSplitModal] = useState(null); // { projectId, projectName, existing: {...} }
  const [showTimeline, setShowTimeline] = useState(false);

  const TRACKS = [
    { key: 'core-bonus', label: 'Core Bonus', gradient: 'linear-gradient(180deg, #fdcb6ecc, #fdcb6e88)', borderColor: 'rgba(253,203,110,0.4)' },
    { key: 'gateway', label: 'Gateway', gradient: 'linear-gradient(180deg, #e84393cc, #e8439388)', borderColor: 'rgba(232,67,147,0.4)' },
    { key: 'seo-aff', label: 'SEO & AFF', gradient: 'linear-gradient(180deg, #00b894cc, #00b89488)', borderColor: 'rgba(0,184,148,0.4)' },
  ];

  // Data loaded from API
  const [verticalData, setVerticalData] = useState({});
  const [verticalStates, setVerticalStates] = useState(() => {
    const state = {};
    for (const v of VERTICALS) state[v.key] = { capacity: {...DEFAULT_CAPACITY}, tracks: { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }, trackCapacity: JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY)), splits: {}, timelineConfig: {...DEFAULT_TIMELINE_CONFIG}, milestones: [], timelineOverrides: {}, trackSubLaneCounts: {}, timelineLaneAssignments: {} };
    return state;
  });

  // Load data from API
  const loadVertical = useCallback(async (key) => {
    try {
      const [projRes, stateRes] = await Promise.all([
        fetch(`${API_URL}/api/verticals/${key}/projects`).then(r => r.json()),
        fetch(`${API_URL}/api/verticals/${key}/state`).then(r => r.json()),
      ]);
      console.log('[load]', key, 'timelineOverrides from server:', JSON.stringify(stateRes.timelineOverrides || {}));
      setVerticalData(prev => ({ ...prev, [key]: projRes.projects || [] }));
      if (stateRes.sizeMap) setSizeMap(stateRes.sizeMap);
      setVerticalStates(prev => ({
        ...prev,
        [key]: {
          capacity: stateRes.capacity || {...DEFAULT_CAPACITY},
          tracks: migrateTracks(stateRes.tracks || { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }),
          trackCapacity: migrateTrackCapacity(stateRes.trackCapacity),
          splits: stateRes.splits || {},
          timelineConfig: stateRes.timelineConfig || {...DEFAULT_TIMELINE_CONFIG},
          milestones: stateRes.milestones || [],
          timelineOverrides: stateRes.timelineOverrides || {},
          trackSubLaneCounts: stateRes.trackSubLaneCounts || {},
          timelineLaneAssignments: stateRes.timelineLaneAssignments || {},
        }
      }));
    } catch (e) {
      console.error('Failed to load vertical:', key, e);
    }
  }, []);

  useEffect(() => {
    (async () => {
      setLoading(true);
      await loadVertical(activeVertical);
      setLoading(false);
    })();
  }, [activeVertical, loadVertical]);

  // Auto-save state to API (debounced)
  const saveTimer = useRef(null);
  const saveState = useCallback(async (key, state) => {
    try {
      setSaving(true);
      const payload = { capacity: state.capacity, tracks: state.tracks, trackCapacity: state.trackCapacity, splits: state.splits, timelineConfig: state.timelineConfig, milestones: state.milestones, timelineOverrides: state.timelineOverrides, trackSubLaneCounts: state.trackSubLaneCounts, timelineLaneAssignments: state.timelineLaneAssignments, sizeMap: sizeMapRef.current };
      console.log('[save]', key, 'timelineOverrides:', JSON.stringify(state.timelineOverrides || {}));
      const resp = await fetch(`${API_URL}/api/verticals/${key}/state`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!resp.ok) console.error('[save] server error:', resp.status, await resp.text());
    } catch (e) {
      console.error('Failed to save state:', e);
    } finally {
      setSaving(false);
    }
  }, []);

  const pendingSave = useRef(null);
  const debouncedSave = useCallback((key, state) => {
    if (saveTimer.current) clearTimeout(saveTimer.current);
    pendingSave.current = { key, state };
    saveTimer.current = setTimeout(() => {
      pendingSave.current = null;
      saveState(key, state);
    }, 800);
  }, [saveState]);

  // Flush pending saves before page unload
  useEffect(() => {
    const onBeforeUnload = () => {
      if (pendingSave.current) {
        const { key, state } = pendingSave.current;
        const body = JSON.stringify({ capacity: state.capacity, tracks: state.tracks, trackCapacity: state.trackCapacity, splits: state.splits, timelineConfig: state.timelineConfig, milestones: state.milestones, timelineOverrides: state.timelineOverrides, trackSubLaneCounts: state.trackSubLaneCounts, timelineLaneAssignments: state.timelineLaneAssignments, sizeMap: sizeMapRef.current });
        navigator.sendBeacon(`${API_URL}/api/verticals/${key}/state`, new Blob([body], { type: 'application/json' }));
        pendingSave.current = null;
      }
    };
    window.addEventListener('beforeunload', onBeforeUnload);
    return () => window.removeEventListener('beforeunload', onBeforeUnload);
  }, []);

  // Save sizeMap when it changes
  const sizeMapInitialized = useRef(false);
  useEffect(() => {
    if (!sizeMapInitialized.current) { sizeMapInitialized.current = true; return; }
    if (activeVertical && verticalStates[activeVertical]) {
      debouncedSave(activeVertical, verticalStates[activeVertical]);
    }
  }, [sizeMap]);

  // Save projects to API
  const projectSaveTimer = useRef(null);
  const saveStatusTimer = useRef(null);
  const saveProjects = useCallback(async (key, projects) => {
    try {
      setSaving(true);
      setSaveStatus(null);
      const url = `${API_URL}/api/verticals/${encodeURIComponent(key)}/projects`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ projects }),
      });
      let data;
      try { data = await res.json(); } catch (jsonErr) {
        const text = await res.text().catch(() => '');
        setSaveStatus({ type: 'error', msg: `Save failed (${res.status}): not JSON - ${text.slice(0,100)}` });
        return;
      }
      if (!res.ok) {
        setSaveStatus({ type: 'error', msg: `Save failed: ${data.error || res.status}` });
        console.error('Save projects failed:', data);
      } else {
        setSaveStatus({ type: 'ok', msg: `Saved ${data.projectCount} projects` });
        if (saveStatusTimer.current) clearTimeout(saveStatusTimer.current);
        saveStatusTimer.current = setTimeout(() => setSaveStatus(null), 3000);
      }
    } catch (e) {
      setSaveStatus({ type: 'error', msg: `Save error: ${e.message}` });
      console.error('Save projects error:', e);
    } finally {
      setSaving(false);
    }
  }, []);

  const debouncedSaveProjects = useCallback((key, projects) => {
    if (projectSaveTimer.current) clearTimeout(projectSaveTimer.current);
    projectSaveTimer.current = setTimeout(() => saveProjects(key, projects), 800);
  }, [saveProjects]);

  const currentData = verticalData[activeVertical] || [];
  const currentState = verticalStates[activeVertical] || { capacity: {...DEFAULT_CAPACITY}, tracks: { 'core-bonus': [], 'gateway': [], 'seo-aff': [] }, trackCapacity: JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY)), splits: {}, timelineConfig: {...DEFAULT_TIMELINE_CONFIG}, milestones: [], timelineOverrides: {}, trackSubLaneCounts: {}, timelineLaneAssignments: {} };
  const capacity = currentState.capacity;
  const tracks = currentState.tracks;
  const trackCapacity = currentState.trackCapacity || JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY));
  const splits = currentState.splits || {};
  const timelineConfig = currentState.timelineConfig || {...DEFAULT_TIMELINE_CONFIG};
  const milestones = currentState.milestones || [];
  const timelineOverrides = currentState.timelineOverrides || {};
  const trackSubLaneCounts = currentState.trackSubLaneCounts || {};
  const timelineLaneAssignments = currentState.timelineLaneAssignments || {};

  const roadmapIds = useMemo(() => {
    const s = new Set();
    for (const arr of Object.values(tracks)) {
      if (Array.isArray(arr)) arr.forEach(id => s.add(id));
    }
    return s;
  }, [tracks]);

  const setCapacity = (updater) => {
    setVerticalStates(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          capacity: typeof updater === 'function' ? updater(prev[activeVertical].capacity) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };
  const updateTrackCapacity = (trackKey, discipline, value) => {
    setVerticalStates(prev => {
      const prevTC = prev[activeVertical].trackCapacity || JSON.parse(JSON.stringify(DEFAULT_TRACK_CAPACITY));
      const newTC = { ...prevTC, [trackKey]: { ...prevTC[trackKey], [discipline]: value } };
      // Validate: sum across tracks for this discipline can't exceed total capacity
      const sum = Object.values(newTC).reduce((s, tc) => s + (tc[discipline] || 0), 0);
      if (sum > prev[activeVertical].capacity[discipline]) return prev; // block the change
      const newState = {
        ...prev,
        [activeVertical]: { ...prev[activeVertical], trackCapacity: newTC }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const saveSplit = (projectId, targetTrack, sizings) => {
    setVerticalStates(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (!prevSplits[projectId]) prevSplits[projectId] = {};
      prevSplits[projectId] = { ...prevSplits[projectId], [targetTrack]: sizings };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const removeSplit = (projectId, targetTrack) => {
    setVerticalStates(prev => {
      const prevSplits = { ...(prev[activeVertical].splits || {}) };
      if (prevSplits[projectId]) {
        const updated = { ...prevSplits[projectId] };
        delete updated[targetTrack];
        if (Object.keys(updated).length === 0) delete prevSplits[projectId];
        else prevSplits[projectId] = updated;
      }
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], splits: prevSplits } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const setTracks = (updater) => {
    setVerticalStates(prev => {
      const newState = {
        ...prev,
        [activeVertical]: {
          ...prev[activeVertical],
          tracks: typeof updater === 'function' ? updater(prev[activeVertical].tracks) : updater,
        }
      };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  };

  const [search, setSearch] = useState('');
  const [filters, setFilters] = useState({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
  const [openFilter, setOpenFilter] = useState(null);
  const [sortBy, setSortBy] = useState('impact');
  const [colorBy, setColorBy] = useState('pillar');
  const dragItem = useRef(null);
  const dragSource = useRef(null);

  const handleVerticalChange = (key) => {
    setActiveVertical(key);
    setSearch('');
    setFilters({ pillar: [], market: [], epic: [], kpi: [], impact: [] });
    setLoading(true);
  };

  const sizeToSprints = useCallback((size) => {
    if (!size || size === 'nan' || size === '' || size === 'NaN') return 0;
    return sizeMap[size] || 0;
  }, [sizeMap]);

  const projectSprints = useCallback((p) => ({
    backend: sizeToSprints(p.backend),
    frontend: sizeToSprints(p.frontend),
    natives: sizeToSprints(p.natives),
    qa: sizeToSprints(p.qa),
    total: sizeToSprints(p.backend) + sizeToSprints(p.frontend) + sizeToSprints(p.natives) + sizeToSprints(p.qa)
  }), [sizeToSprints]);

  const uniqueValues = useMemo(() => ({
    pillar: [...new Set(currentData.map(p => p.pillar).filter(Boolean))].sort(),
    market: [...new Set(currentData.map(p => p.targetMarket).filter(Boolean))].sort(),
    epic: [...new Set(currentData.map(p => p.masterEpic).filter(Boolean))].sort(),
    kpi: [...new Set(currentData.map(p => p.targetKPI).filter(Boolean))].sort(),
    impact: ['XS','S','M','L','XL','XXL','XXXL'],
  }), [currentData]);

  const filterProjects = useCallback((projects) => {
    return projects.filter(p => {
      if (search) {
        const q = search.toLowerCase();
        if (!(p.subTask||'').toLowerCase().includes(q) && !(p.nvrd||'').toLowerCase().includes(q) && !(p.masterEpic||'').toLowerCase().includes(q)) return false;
      }
      if (filters.pillar.length && !filters.pillar.includes(p.pillar)) return false;
      if (filters.market.length && !filters.market.includes(p.targetMarket)) return false;
      if (filters.epic.length && !filters.epic.includes(p.masterEpic)) return false;
      if (filters.kpi.length && !filters.kpi.includes(p.targetKPI)) return false;
      if (filters.impact.length && !filters.impact.includes(p.impact)) return false;
      return true;
    });
  }, [search, filters]);

  const impactOrder = { XXXL: 7, XXL: 6, XL: 5, L: 4, M: 3, S: 2, XS: 1 };
  const sortProjects = useCallback((projects) => {
    return [...projects].sort((a, b) => {
      if (sortBy === 'impact') return (impactOrder[b.impact]||0) - (impactOrder[a.impact]||0);
      if (sortBy === 'effort') return projectSprints(b).total - projectSprints(a).total;
      if (sortBy === 'name') return a.subTask.localeCompare(b.subTask);
      if (sortBy === 'epic') return a.masterEpic.localeCompare(b.masterEpic);
      if (sortBy === 'pillar') return a.pillar.localeCompare(b.pillar);
      return 0;
    });
  }, [sortBy, projectSprints]);

  const roadmapProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);
  const backlogProjects = useMemo(() => sortProjects(filterProjects(currentData.filter(p => !roadmapIds.has(p.id)))), [roadmapIds, filterProjects, sortProjects, currentData]);

  const usedCapacity = useMemo(() => {
    return currentData.filter(p => roadmapIds.has(p.id)).reduce((acc, p) => {
      const s = projectSprints(p);
      return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
    }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
  }, [roadmapIds, projectSprints, currentData]);

  // Apply buffer to roadmap used capacity
  const bufferedUsed = useMemo(() => ({
    backend: Math.round(usedCapacity.backend * (1 + buffer.backend / 100) * 10) / 10,
    frontend: Math.round(usedCapacity.frontend * (1 + buffer.frontend / 100) * 10) / 10,
    natives: Math.round(usedCapacity.natives * (1 + buffer.natives / 100) * 10) / 10,
    qa: Math.round(usedCapacity.qa * (1 + buffer.qa / 100) * 10) / 10,
  }), [usedCapacity, buffer]);

  const totalCapacity = capacity.backend + capacity.frontend + capacity.natives + capacity.qa;
  const totalUsed = bufferedUsed.backend + bufferedUsed.frontend + bufferedUsed.natives + bufferedUsed.qa;

  // Total demand across ALL projects (not just roadmap)
  const totalDemand = useMemo(() => {
    return currentData.reduce((acc, p) => {
      const s = projectSprints(p);
      return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
    }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
  }, [currentData, projectSprints]);

  const bufferedDemand = useMemo(() => ({
    backend: Math.round(totalDemand.backend * (1 + buffer.backend / 100) * 10) / 10,
    frontend: Math.round(totalDemand.frontend * (1 + buffer.frontend / 100) * 10) / 10,
    natives: Math.round(totalDemand.natives * (1 + buffer.natives / 100) * 10) / 10,
    qa: Math.round(totalDemand.qa * (1 + buffer.qa / 100) * 10) / 10,
  }), [totalDemand, buffer]);

  // Remove id from all tracks
  const removeFromTracks = (trks, id) => {
    const n = {};
    for (const k of Object.keys(trks)) n[k] = trks[k].filter(x => x !== id);
    return n;
  };

  const moveToTrack = (id, trackKey, insertIndex) => setTracks(prev => {
    const n = removeFromTracks(prev, id);
    if (insertIndex !== undefined) n[trackKey].splice(insertIndex, 0, id);
    else n[trackKey].push(id);
    return n;
  });
  const moveToBacklog = (id) => setTracks(prev => removeFromTracks(prev, id));

  const handleDragStart = (e, id, source) => {
    dragItem.current = id; dragSource.current = source;
    e.dataTransfer.effectAllowed = 'move';
    setTimeout(() => e.target.classList.add('dragging'), 0);
  };
  const handleDragEnd = (e) => {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
  };
  const handleDragOver = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
  const handleDragEnter = (e) => { e.currentTarget.classList.add('drag-over'); };
  const handleDragLeave = (e) => { if (!e.currentTarget.contains(e.relatedTarget)) e.currentTarget.classList.remove('drag-over'); };

  const handleDropOnTrack = (e, trackKey) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current) return;
    moveToTrack(dragItem.current, trackKey);
  };

  const handleDropOnBlock = (e, trackKey, blockId, blockIndex) => {
    e.preventDefault(); e.stopPropagation();
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    if (!dragItem.current || dragItem.current === blockId) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    const insertIdx = dropAfter ? blockIndex + 1 : blockIndex;
    // Adjust index if dragging from same track before this position
    const currentTrackIds = tracks[trackKey] || [];
    const currentIdx = currentTrackIds.indexOf(dragItem.current);
    let adjustedIdx = insertIdx;
    if (currentIdx !== -1 && currentIdx < insertIdx) adjustedIdx = insertIdx - 1;
    moveToTrack(dragItem.current, trackKey, adjustedIdx);
  };

  const handleDragOverBlock = (e, trackKey, blockId) => {
    e.preventDefault(); e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    if (!dragItem.current || dragItem.current === blockId) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const dropAfter = (e.clientX - rect.left) > rect.width / 2;
    // Show drop indicator
    const existing = e.currentTarget.parentElement.querySelectorAll('.drop-indicator');
    existing.forEach(el => el.remove());
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    if (dropAfter) {
      e.currentTarget.after(indicator);
    } else {
      e.currentTarget.before(indicator);
    }
  };

  const handleDropOnBacklog = (e) => {
    e.preventDefault(); e.currentTarget.classList.remove('drag-over');
    if (dragItem.current && dragSource.current !== 'backlog') moveToBacklog(dragItem.current);
  };

  const toggleFilter = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: prev[key].includes(value) ? prev[key].filter(v => v !== value) : [...prev[key], value] }));
  };
  const activeFilterCount = Object.values(filters).reduce((s, a) => s + a.length, 0);

  useEffect(() => {
    const handler = (e) => { if (!e.target.closest('.filter-group')) setOpenFilter(null); };
    document.addEventListener('click', handler);
    return () => document.removeEventListener('click', handler);
  }, []);

  const getBlockWidth = (p) => {
    const sprints = projectSprints(p).total;
    return Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, sprints * PX_PER_SPRINT));
  };

  const handleMouseEnter = (e, p) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setTooltip({ p, x: rect.right + 8, y: rect.top });
  };
  const handleMouseLeave = () => setTooltip(null);

  const renderCapBar = (label, used, total) => {
    const pct = total > 0 ? Math.round((used / total) * 100) : 0;
    const barColor = getCapColor(pct);
    return (
      <div className="cap-bar-container">
        <div className="cap-bar-label">
          <span>{label}</span>
          <span style={{color: barColor, fontWeight:700}}>{used}/{total} ({pct}%)</span>
        </div>
        <div className="cap-bar-track">
          <div className="cap-bar-fill" style={{ width: `${Math.min(pct,100)}%`, background: barColor }}>
            {pct > 15 ? `${pct}%` : ''}
          </div>
        </div>
      </div>
    );
  };

  // Project lookup by ID â€” must be before ghostsByTrack which depends on it
  const projectById = useMemo(() => {
    const m = {};
    for (const p of currentData) m[p.id] = p;
    return m;
  }, [currentData]);

  // Compute effective sprints for a project in its home track:
  // full sizing minus any capacity sent to other tracks via splits
  const effectiveSprints = useCallback((p) => {
    const full = projectSprints(p);
    const projectSplits = splits[p.id];
    if (!projectSplits || typeof projectSplits !== 'object') return full;
    // Sum all split sizings across target tracks
    let subtracted = { backend: 0, frontend: 0, natives: 0, qa: 0 };
    for (const sizing of Object.values(projectSplits)) {
      if (sizing && typeof sizing === 'object') {
        subtracted.backend += (sizing.backend || 0);
        subtracted.frontend += (sizing.frontend || 0);
        subtracted.natives += (sizing.natives || 0);
        subtracted.qa += (sizing.qa || 0);
      }
    }
    return {
      backend: Math.max(0, full.backend - subtracted.backend),
      frontend: Math.max(0, full.frontend - subtracted.frontend),
      natives: Math.max(0, full.natives - subtracted.natives),
      qa: Math.max(0, full.qa - subtracted.qa),
      total: Math.max(0, full.total - subtracted.backend - subtracted.frontend - subtracted.natives - subtracted.qa),
    };
  }, [projectSprints, splits]);

  // Find which track a project primarily lives in
  const getProjectHomeTrack = useCallback((projectId) => {
    for (const t of TRACKS) {
      if ((tracks[t.key] || []).includes(projectId)) return t;
    }
    return null;
  }, [tracks]);

  const renderBlock = (p, lane, trackKey, blockIndex) => {
    const s = projectSprints(p);
    const eff = effectiveSprints(p);
    const hasSplits = splits[p.id] && Object.keys(splits[p.id]).length > 0;
    const isTrack = lane === 'roadmap' && trackKey;
    // Use effective width for blocks in tracks that have splits
    const displaySprints = (isTrack && hasSplits) ? eff : s;
    const w = (isTrack && hasSplits)
      ? Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, eff.total * PX_PER_SPRINT))
      : getBlockWidth(p);
    const overflowDisciplines = (isTrack && trackOverflow[trackKey] && trackOverflow[trackKey][p.id]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    return (
      <div key={p.id}
        className={`project-block ${p.inProgress ? 'in-progress' : ''} ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar) }}
        draggable
        onDragStart={(e) => handleDragStart(e, p.id, lane)}
        onDragEnd={handleDragEnd}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
        {...(isTrack ? {
          onDragOver: (e) => handleDragOverBlock(e, trackKey, p.id),
          onDrop: (e) => handleDropOnBlock(e, trackKey, p.id, blockIndex),
        } : {})}
      >
        {isOverflow && (
          <div className="overflow-badge" title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        {hasSplits && <div className="ghost-link-icon" title="Has split allocations">ðŸ”—</div>}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{hasSplits && isTrack ? `${eff.total}/${s.total}sp` : `${s.total}sp`}</span>
          </div>
        </div>
        {isTrack && (
          <button className="block-split"
            onClick={(e) => { e.stopPropagation(); setSplitModal({ projectId: p.id, projectName: p.subTask, homeTrack: trackKey }); }}
            title="Split to another swimlane">
            â‘‚
          </button>
        )}
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); lane === 'backlog' ? moveToTrack(p.id, 'core-bonus') : moveToBacklog(p.id); }}
          title={lane === 'backlog' ? 'Add to Roadmap' : 'Remove from Roadmap'}>
          {lane === 'backlog' ? 'ï¼‹' : 'âœ•'}
        </button>
      </div>
    );
  };

  const renderGhostBlock = (p, splitSizing, trackKey, homeTrack) => {
    if (!p || !splitSizing) return null;
    const totalSp = (splitSizing.backend || 0) + (splitSizing.frontend || 0) + (splitSizing.natives || 0) + (splitSizing.qa || 0);
    const w = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, totalSp * PX_PER_SPRINT));
    const homeLabel = TRACKS.find(t => t.key === homeTrack)?.label || homeTrack;
    // Check overflow for ghost blocks too
    const overflowDisciplines = (trackOverflow[trackKey] && trackOverflow[trackKey][`ghost-${p.id}`]) || null;
    const isOverflow = overflowDisciplines && overflowDisciplines.length > 0;
    return (
      <div key={`ghost-${p.id}`}
        className={`project-block ghost-block ${isOverflow ? 'overflow-block' : ''}`}
        style={{ width: w, height: BLOCK_HEIGHT, background: getBlockBg(p.pillar) }}
        onMouseEnter={(e) => handleMouseEnter(e, p)}
        onMouseLeave={handleMouseLeave}
      >
        <div className="ghost-link-icon">ðŸ”—</div>
        {isOverflow && (
          <div className="overflow-badge" style={{left:'auto',right:3}} title={`Exceeds ${overflowDisciplines.join(', ')} capacity`}>
            âš  {overflowDisciplines.map(d => d.charAt(0).toUpperCase()).join('Â·')}
          </div>
        )}
        <div className="block-content">
          <div className="block-title">{p.subTask}</div>
          <div className="block-bottom">
            <span className="block-jira">{p.nvrd}</span>
            <span className="block-sprints">{totalSp}sp</span>
          </div>
        </div>
        <div className="ghost-origin">â†— {homeLabel}</div>
        <button className="block-move"
          onClick={(e) => { e.stopPropagation(); removeSplit(p.id, trackKey); }}
          title="Remove split">
          âœ•
        </button>
      </div>
    );
  };

  // Compute ghost blocks per track
  const ghostsByTrack = useMemo(() => {
    try {
      const result = {};
      for (const t of TRACKS) result[t.key] = [];
      if (!splits || typeof splits !== 'object' || Array.isArray(splits)) return result;
      const entries = Object.entries(splits);
      for (let ei = 0; ei < entries.length; ei++) {
        const pidStr = entries[ei][0];
        const trackSplits = entries[ei][1];
        if (!trackSplits || typeof trackSplits !== 'object') continue;
        const pid = parseInt(pidStr);
        if (isNaN(pid)) continue;
        const p = projectById[pid];
        if (!p) continue;
        const tsEntries = Object.entries(trackSplits);
        for (let ti = 0; ti < tsEntries.length; ti++) {
          const targetTrack = tsEntries[ti][0];
          const sizing = tsEntries[ti][1];
          if (result[targetTrack] && sizing && typeof sizing === 'object') {
            result[targetTrack].push({ project: p, sizing, homeTrack: getProjectHomeTrack(pid)?.key || '' });
          }
        }
      }
      return result;
    } catch (err) {
      console.error('ghostsByTrack error:', err, 'splits:', JSON.stringify(splits));
      const result = {};
      for (const t of TRACKS) result[t.key] = [];
      return result;
    }
  }, [splits, projectById, getProjectHomeTrack]);

  const FilterDropdown = ({ filterKey, label }) => {
    const values = uniqueValues[filterKey];
    const selected = filters[filterKey];
    const isOpen = openFilter === filterKey;
    return (
      <div className="filter-group">
        <button className={`filter-btn ${selected.length ? 'active' : ''}`}
          onClick={(e) => { e.stopPropagation(); setOpenFilter(isOpen ? null : filterKey); }}>
          {label}
          {selected.length > 0 && <span className="count">{selected.length}</span>}
          <span style={{fontSize:10}}>â–¾</span>
        </button>
        <div className={`filter-dropdown ${isOpen ? 'open' : ''}`}>
          {values.map(v => (
            <label key={v} className="filter-option">
              <input type="checkbox" checked={selected.includes(v)} onChange={() => toggleFilter(filterKey, v)} />
              {v}
            </label>
          ))}
        </div>
      </div>
    );
  };

  const trackProjects = useMemo(() => {
    const result = {};
    const filtered = new Set(filterProjects(currentData).map(p => p.id));
    for (const t of TRACKS) {
      result[t.key] = (tracks[t.key] || []).map(id => projectById[id]).filter(p => p && filtered.has(p.id));
    }
    return result;
  }, [tracks, projectById, filterProjects, currentData]);

  // Per-track used capacity: home projects use effectiveSprints (minus splits), ghosts add their sizing
  const trackUsed = useMemo(() => {
    const result = {};
    for (const t of TRACKS) {
      const fromProjects = (trackProjects[t.key] || []).reduce((acc, p) => {
        const s = effectiveSprints(p);
        return { backend: acc.backend + s.backend, frontend: acc.frontend + s.frontend, natives: acc.natives + s.natives, qa: acc.qa + s.qa };
      }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
      // Add ghost split sizings (these are the capacity sent FROM other tracks)
      const fromGhosts = (ghostsByTrack[t.key] || []).reduce((acc, g) => {
        if (!g || !g.sizing) return acc;
        return { backend: acc.backend + (g.sizing.backend || 0), frontend: acc.frontend + (g.sizing.frontend || 0), natives: acc.natives + (g.sizing.natives || 0), qa: acc.qa + (g.sizing.qa || 0) };
      }, { backend: 0, frontend: 0, natives: 0, qa: 0 });
      result[t.key] = {
        backend: fromProjects.backend + fromGhosts.backend,
        frontend: fromProjects.frontend + fromGhosts.frontend,
        natives: fromProjects.natives + fromGhosts.natives,
        qa: fromProjects.qa + fromGhosts.qa,
      };
    }
    return result;
  }, [trackProjects, effectiveSprints, ghostsByTrack]);

  // Unallocated capacity per discipline
  const unallocated = useMemo(() => {
    const result = {};
    for (const d of ['backend', 'frontend', 'natives', 'qa']) {
      const allocated = Object.values(trackCapacity).reduce((s, tc) => s + (tc[d] || 0), 0);
      result[d] = capacity[d] - allocated;
    }
    return result;
  }, [capacity, trackCapacity]);

  // Per-track overflow detection: which projects push a discipline over the track's allocation
  const trackOverflow = useMemo(() => {
    const result = {};
    for (const t of TRACKS) {
      const tc = trackCapacity[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
      const hasAllocation = Object.values(tc).some(v => v > 0);
      if (!hasAllocation) { result[t.key] = {}; continue; }
      const running = { backend:0, frontend:0, natives:0, qa:0 };
      const overflows = {};
      // Check real projects (using effective sprints minus splits)
      for (const p of (trackProjects[t.key] || [])) {
        const s = effectiveSprints(p);
        for (const d of ['backend','frontend','natives','qa']) running[d] += s[d];
        const exceeded = [];
        for (const d of ['backend','frontend','natives','qa']) {
          if (tc[d] > 0 && running[d] > tc[d]) exceeded.push(d);
        }
        if (exceeded.length > 0) overflows[p.id] = exceeded;
      }
      // Check ghost blocks
      for (const g of (ghostsByTrack[t.key] || [])) {
        if (!g || !g.sizing) continue;
        for (const d of ['backend','frontend','natives','qa']) running[d] += (g.sizing[d] || 0);
        const exceeded = [];
        for (const d of ['backend','frontend','natives','qa']) {
          if (tc[d] > 0 && running[d] > tc[d]) exceeded.push(d);
        }
        if (exceeded.length > 0) overflows[`ghost-${g.project.id}`] = exceeded;
      }
      result[t.key] = overflows;
    }
    return result;
  }, [trackProjects, trackCapacity, effectiveSprints, ghostsByTrack]);

  // â”€â”€ Timeline helpers â”€â”€
  const updateTimelineConfig = useCallback((updates) => {
    setVerticalStates(prev => {
      const tc = { ...(prev[activeVertical].timelineConfig || DEFAULT_TIMELINE_CONFIG), ...updates };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineConfig: tc } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave]);

  const addMilestone = useCallback((name, date, color) => {
    setVerticalStates(prev => {
      const ms = [...(prev[activeVertical].milestones || [])];
      const id = ms.length > 0 ? Math.max(...ms.map(m => m.id)) + 1 : 1;
      ms.push({ id, name, date, color: color || MILESTONE_COLORS[ms.length % MILESTONE_COLORS.length] });
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave]);

  const updateMilestone = useCallback((id, updates) => {
    setVerticalStates(prev => {
      const ms = (prev[activeVertical].milestones || []).map(m => m.id === id ? { ...m, ...updates } : m);
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave]);

  const removeMilestone = useCallback((id) => {
    setVerticalStates(prev => {
      const ms = (prev[activeVertical].milestones || []).filter(m => m.id !== id);
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], milestones: ms } };
      debouncedSave(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, debouncedSave]);

  const updateTimelineOverride = useCallback((projectId, trackKey, updates) => {
    setVerticalStates(prev => {
      const overrides = { ...(prev[activeVertical].timelineOverrides || {}) };
      const key = `${trackKey}:${projectId}`;
      overrides[key] = { ...(overrides[key] || {}), ...updates };
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineOverrides: overrides } };
      // Save immediately (not debounced) â€” only fires on mouseup so no rapid-fire risk
      if (saveTimer.current) clearTimeout(saveTimer.current);
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState]);

  const clearTimelineOverride = useCallback((projectId, trackKey) => {
    setVerticalStates(prev => {
      const overrides = { ...(prev[activeVertical].timelineOverrides || {}) };
      delete overrides[`${trackKey}:${projectId}`];
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineOverrides: overrides } };
      if (saveTimer.current) clearTimeout(saveTimer.current);
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState]);

  // Sub-lane management
  const addSubLane = useCallback((trackKey) => {
    setVerticalStates(prev => {
      const counts = { ...(prev[activeVertical].trackSubLaneCounts || {}) };
      counts[trackKey] = (counts[trackKey] || 1) + 1;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackSubLaneCounts: counts } };
      if (saveTimer.current) clearTimeout(saveTimer.current);
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState]);

  const removeSubLane = useCallback((trackKey) => {
    setVerticalStates(prev => {
      const counts = { ...(prev[activeVertical].trackSubLaneCounts || {}) };
      if ((counts[trackKey] || 1) <= 1) return prev;
      counts[trackKey] = counts[trackKey] - 1;
      // Move projects from removed lane to last valid lane
      const assignments = { ...(prev[activeVertical].timelineLaneAssignments || {}) };
      for (const key in assignments) {
        if (key.startsWith(trackKey + ':') && assignments[key] >= counts[trackKey]) {
          assignments[key] = counts[trackKey] - 1;
        }
      }
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], trackSubLaneCounts: counts, timelineLaneAssignments: assignments } };
      if (saveTimer.current) clearTimeout(saveTimer.current);
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState]);

  const updateLaneAssignment = useCallback((projectId, trackKey, laneIndex) => {
    setVerticalStates(prev => {
      const assignments = { ...(prev[activeVertical].timelineLaneAssignments || {}) };
      const key = `${trackKey}:${projectId}`;
      if (laneIndex === 0) delete assignments[key];
      else assignments[key] = laneIndex;
      const newState = { ...prev, [activeVertical]: { ...prev[activeVertical], timelineLaneAssignments: assignments } };
      if (saveTimer.current) clearTimeout(saveTimer.current);
      saveState(activeVertical, newState[activeVertical]);
      return newState;
    });
  }, [activeVertical, saveState]);

  // Drag-to-resize state ref
  const dragRef = useRef(null);

  // Compute timeline layout data
  const timelineData = useMemo(() => {
    const sprintWeeks = timelineConfig.sprintDurationWeeks || 2;
    const scale = timelineConfig.timeScale || 'months';
    const startDate = new Date(timelineConfig.sprintStartDate || Date.now());

    // Pixel width per sprint based on scale
    const pxPerSprint = scale === 'weeks' ? PX_PER_SPRINT_WEEK * sprintWeeks
      : scale === 'months' ? PX_PER_SPRINT_WEEK * sprintWeeks * 0.7
      : PX_PER_SPRINT_WEEK * sprintWeeks * 0.35; // quarters

    // Build track bars: { trackKey: [{project, left, width, sprints, trackKey, disciplines}] }
    const trackBars = {};
    let maxPx = 0;
    for (const t of TRACKS) {
      const bars = [];
      let cumSprints = 0;
      for (const pid of (tracks[t.key] || [])) {
        const p = projectById[pid];
        if (!p) continue;
        const eff = effectiveSprints(p);
        const ovKey = `${t.key}:${pid}`;
        const ov = timelineOverrides[ovKey];
        const autoStart = cumSprints;
        const autoSprints = eff.total;
        const startSp = ov && ov.startSprints != null ? ov.startSprints : autoStart;
        const durSp = ov && ov.durationSprints != null ? ov.durationSprints : autoSprints;
        const left = startSp * pxPerSprint;
        const width = Math.max(40, durSp * pxPerSprint);
        const laneIndex = timelineLaneAssignments[`${t.key}:${pid}`] || 0;
        bars.push({ project: p, left, width, sprints: durSp, autoSprints, startSprints: startSp, autoStart, trackKey: t.key, hasOverride: !!ov, disciplines: eff, laneIndex });
        cumSprints = Math.max(cumSprints, startSp + durSp);
        if (!ov) cumSprints = autoStart + autoSprints; // without override, sequential
      }
      // Ghost blocks appended at the end of the track
      for (const g of (ghostsByTrack[t.key] || [])) {
        const totalSp = (g.sizing.backend||0) + (g.sizing.frontend||0) + (g.sizing.natives||0) + (g.sizing.qa||0);
        const ovKey = `${t.key}:${g.project.id}`;
        const ov = timelineOverrides[ovKey];
        const autoStart = cumSprints;
        const startSp = ov && ov.startSprints != null ? ov.startSprints : autoStart;
        const durSp = ov && ov.durationSprints != null ? ov.durationSprints : totalSp;
        const left = startSp * pxPerSprint;
        const width = Math.max(40, durSp * pxPerSprint);
        const gLaneIndex = timelineLaneAssignments[`${t.key}:${g.project.id}`] || 0;
        bars.push({ project: g.project, left, width, sprints: durSp, autoSprints: totalSp, startSprints: startSp, autoStart, trackKey: t.key, hasOverride: !!ov, ghost: true, homeTrack: g.homeTrack, disciplines: g.sizing, laneIndex: gLaneIndex });
        cumSprints = Math.max(cumSprints, startSp + durSp);
        if (!ov) cumSprints = autoStart + totalSp;
      }
      trackBars[t.key] = bars;
      const trackMax = bars.reduce((m, b) => Math.max(m, b.left + b.width), 0);
      maxPx = Math.max(maxPx, trackMax);
    }

    const totalWeeks = (maxPx / PX_PER_SPRINT_WEEK) * (scale === 'months' ? 1/0.7 : scale === 'quarters' ? 1/0.35 : 1);

    // Generate ruler marks
    const marks = [];
    const totalPx = maxPx + 200; // extra padding
    if (scale === 'weeks') {
      const weekPx = PX_PER_SPRINT_WEEK;
      const numWeeks = Math.ceil(totalPx / weekPx);
      for (let i = 0; i < numWeeks; i++) {
        const d = new Date(startDate);
        d.setDate(d.getDate() + i * 7);
        marks.push({ label: `W${i+1}`, width: weekPx, date: d });
      }
    } else if (scale === 'months') {
      const monthPx = PX_PER_SPRINT_WEEK * (4.33 / sprintWeeks) * pxPerSprint / PX_PER_SPRINT_WEEK * sprintWeeks;
      // Simpler approach: compute months from start to end
      const d = new Date(startDate);
      let px = 0;
      while (px < totalPx) {
        const nextMonth = new Date(d.getFullYear(), d.getMonth() + 1, 1);
        const daysInMonth = (nextMonth - d) / (1000*60*60*24);
        const weeksInMonth = daysInMonth / 7;
        const w = weeksInMonth / sprintWeeks * pxPerSprint;
        marks.push({ label: d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }), width: Math.max(60, w), date: new Date(d) });
        px += w;
        d.setMonth(d.getMonth() + 1); d.setDate(1);
      }
    } else { // quarters
      const d = new Date(startDate);
      let px = 0;
      const qNames = ['Q1','Q2','Q3','Q4'];
      while (px < totalPx) {
        const q = Math.floor(d.getMonth() / 3);
        const nextQ = new Date(d.getFullYear(), (q + 1) * 3, 1);
        const daysInQ = (nextQ - d) / (1000*60*60*24);
        const weeksInQ = daysInQ / 7;
        const w = weeksInQ / sprintWeeks * pxPerSprint;
        marks.push({ label: `${qNames[q]} ${d.getFullYear()}`, width: Math.max(80, w), date: new Date(d) });
        px += w;
        d.setTime(nextQ.getTime());
      }
    }

    // Milestone positions (date to px)
    const msPositions = (milestones || []).map(m => {
      const mDate = new Date(m.date);
      const daysDiff = (mDate - startDate) / (1000*60*60*24);
      const weeksDiff = daysDiff / 7;
      const sprintsDiff = weeksDiff / sprintWeeks;
      return { ...m, px: sprintsDiff * pxPerSprint };
    }).filter(m => m.px >= 0);

    return { trackBars, marks, totalPx: totalPx, msPositions, pxPerSprint };
  }, [tracks, projectById, effectiveSprints, ghostsByTrack, timelineConfig, milestones, timelineOverrides, timelineLaneAssignments, trackSubLaneCounts]);

  // Drag handlers for timeline bars (resize left/right + move with lane support)
  const handleBarDragStart = useCallback((e, bar, side) => {
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startY = e.clientY;
    const pxPerSprint = timelineData.pxPerSprint;
    const origLeft = bar.left;
    const origWidth = bar.width;
    const origStartSp = bar.startSprints;
    const origDurSp = bar.sprints;
    const origLaneIndex = bar.laneIndex || 0;

    const barEl = e.target.closest('.tl-bar');
    const trackBarsEl = barEl?.closest('.tl-track-bars');
    const maxLane = (trackSubLaneCounts[bar.trackKey] || 1) - 1;

    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX;
      const el = barEl;
      if (side === 'right') {
        const newWidth = Math.max(40, origWidth + dx);
        const newDurSp = Math.max(1, Math.round(newWidth / pxPerSprint));
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: origStartSp, durationSprints: newDurSp, laneIndex: origLaneIndex };
        if (el) { el.style.width = (newDurSp * pxPerSprint) + 'px'; }
      } else if (side === 'left') {
        const newLeft = origLeft + dx;
        const newStartSp = Math.max(0, Math.round(newLeft / pxPerSprint));
        const newDurSp = Math.max(1, origDurSp + (origStartSp - newStartSp));
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: newStartSp, durationSprints: newDurSp, laneIndex: origLaneIndex };
        if (el) { el.style.left = (newStartSp * pxPerSprint) + 'px'; el.style.width = (newDurSp * pxPerSprint) + 'px'; }
      } else { // move (horizontal + vertical lane)
        const newLeft = origLeft + dx;
        const newStartSp = Math.max(0, Math.round(newLeft / pxPerSprint));
        // Detect vertical lane from cursor position
        let newLaneIndex = origLaneIndex;
        if (trackBarsEl && maxLane > 0) {
          const rect = trackBarsEl.getBoundingClientRect();
          const relativeY = ev.clientY - rect.top;
          newLaneIndex = Math.max(0, Math.min(maxLane, Math.floor(relativeY / 66)));
        }
        dragRef.current = { projectId: bar.project.id, trackKey: bar.trackKey, startSprints: newStartSp, durationSprints: origDurSp, laneIndex: newLaneIndex };
        if (el) {
          el.style.left = (newStartSp * pxPerSprint) + 'px';
          el.style.top = (newLaneIndex * 66 + 6) + 'px';
        }
      }
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      document.body.style.cursor = '';
      if (dragRef.current) {
        updateTimelineOverride(dragRef.current.projectId, dragRef.current.trackKey, {
          startSprints: dragRef.current.startSprints,
          durationSprints: dragRef.current.durationSprints,
        });
        // Update lane assignment if changed
        if (dragRef.current.laneIndex !== origLaneIndex) {
          updateLaneAssignment(dragRef.current.projectId, dragRef.current.trackKey, dragRef.current.laneIndex);
        }
        dragRef.current = null;
      }
    };

    document.body.style.cursor = side === 'move' ? 'grabbing' : 'col-resize';
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }, [timelineData.pxPerSprint, updateTimelineOverride, updateLaneAssignment, trackSubLaneCounts]);

  const activeV = VERTICALS.find(v => v.key === activeVertical);
  const roadmapTotalSprints = currentData.filter(p => roadmapIds.has(p.id)).reduce((s, p) => s + projectSprints(p).total, 0);

  // â”€â”€ Projects Table Component â”€â”€
  const VALID_SIZES = ['', 'XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];
  const VALID_IMPACTS = ['XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL'];

  const updateProject = (projectId, field, value) => {
    const updated = currentData.map(p => p.id === projectId ? { ...p, [field]: value } : p);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell(null);
  };

  const addProject = () => {
    const maxId = currentData.length > 0 ? Math.max(...currentData.map(p => p.id)) : 0;
    const newProject = {
      id: maxId + 1, nvrd: '', masterEpic: '', subTask: 'New Project',
      pillar: '', targetMarket: '', targetKPI: '', impact: 'M',
      backend: '', frontend: '', natives: '', qa: '', inProgress: false,
    };
    const updated = [...currentData, newProject];
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
    setEditingCell({ id: newProject.id, field: 'subTask' });
    setEditValue('New Project');
  };

  const deleteProject = (projectId) => {
    if (!window.confirm('Delete this project?')) return;
    const updated = currentData.filter(p => p.id !== projectId);
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => removeFromTracks(prev, projectId));
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
  };

  // â”€â”€ Bulk operations â”€â”€
  const toggleSelect = (id) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  };

  const toggleSelectAll = () => {
    if (selectedIds.size === currentData.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(currentData.map(p => p.id)));
    }
  };

  const bulkDelete = () => {
    if (selectedIds.size === 0) return;
    if (!window.confirm(`Delete ${selectedIds.size} selected project${selectedIds.size > 1 ? 's' : ''}?`)) return;
    const updated = currentData.filter(p => !selectedIds.has(p.id));
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    setTracks(prev => {
      let t = prev;
      for (const id of selectedIds) t = removeFromTracks(t, id);
      return t;
    });
    // Save immediately â€” no debounce for deletes
    saveProjects(activeVertical, updated);
    setSelectedIds(new Set());
  };

  const bulkEdit = () => {
    if (selectedIds.size === 0 || !bulkField) return;
    const updated = currentData.map(p =>
      selectedIds.has(p.id) ? { ...p, [bulkField]: bulkValue } : p
    );
    setVerticalData(prev => ({ ...prev, [activeVertical]: updated }));
    debouncedSaveProjects(activeVertical, updated);
  };

  const BULK_FIELD_OPTIONS = [
    { key: 'pillar', label: 'Pillar' },
    { key: 'targetMarket', label: 'Market' },
    { key: 'targetKPI', label: 'KPI' },
    { key: 'impact', label: 'Impact' },
    { key: 'backend', label: 'Backend' },
    { key: 'frontend', label: 'Frontend' },
    { key: 'natives', label: 'Natives' },
    { key: 'qa', label: 'QA' },
    { key: 'masterEpic', label: 'Epic' },
  ];

  const sizeFields = new Set(['impact', 'backend', 'frontend', 'natives', 'qa']);

  const startEdit = (id, field, value) => {
    setEditingCell({ id, field });
    setEditValue(value || '');
  };

  const commitEditRef = useRef(null);
  commitEditRef.current = () => {
    if (editingCell) {
      updateProject(editingCell.id, editingCell.field, editValue);
    }
  };
  const commitEdit = () => commitEditRef.current();

  const dropdownFields = { impact: VALID_IMPACTS, backend: VALID_SIZES, frontend: VALID_SIZES, natives: VALID_SIZES, qa: VALID_SIZES };

  const renderEditableCell = (p, field) => {
    const isEditing = editingCell?.id === p.id && editingCell?.field === field;
    const value = p[field] || '';

    if (isEditing) {
      if (dropdownFields[field]) {
        return (
          <select className="cell-select" value={editValue}
            onChange={(e) => { updateProject(p.id, field, e.target.value); }}
            onBlur={() => setEditingCell(null)}
            onKeyDown={(e) => { if (e.key === 'Escape') setEditingCell(null); }}
            autoFocus>
            {dropdownFields[field].map(v => <option key={v} value={v}>{v || 'â€”'}</option>)}
          </select>
        );
      }
      return (
        <input className="cell-input" value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={commitEdit}
          onKeyDown={(e) => {
            if (e.key === 'Enter') commitEdit();
            if (e.key === 'Escape') setEditingCell(null);
          }}
          autoFocus />
      );
    }
    return (
      <div className="cell-view" onClick={() => startEdit(p.id, field, value)}>
        {value || 'â€”'}
      </div>
    );
  };

  const TABLE_COLS = [
    { key: 'nvrd', label: 'NVRD', width: '8%' },
    { key: 'masterEpic', label: 'Epic', width: '12%' },
    { key: 'subTask', label: 'Sub Task', width: '22%' },
    { key: 'pillar', label: 'Pillar', width: '9%' },
    { key: 'targetMarket', label: 'Market', width: '7%' },
    { key: 'targetKPI', label: 'KPI', width: '8%' },
    { key: 'impact', label: 'Impact', width: '6%' },
    { key: 'backend', label: 'BE', width: '5%' },
    { key: 'frontend', label: 'FE', width: '5%' },
    { key: 'natives', label: 'Native', width: '5%' },
    { key: 'qa', label: 'QA', width: '5%' },
  ];

  const projectsTableJSX = (
    <div className="projects-container">
      <div className="projects-toolbar">
        <button className="btn btn-primary" onClick={addProject}>+ Add Project</button>
        <span className="project-count-badge">{currentData.length} projects</span>
        {selectedIds.size > 0 && (
          <button className="btn-sm" onClick={() => setSelectedIds(new Set())} style={{marginLeft:4}}>
            Deselect all
          </button>
        )}
        {saveStatus && (
          <span style={{
            fontSize: 11, padding: '3px 10px', borderRadius: 6, fontWeight: 600,
            background: saveStatus.type === 'ok' ? 'rgba(0,184,148,0.15)' : 'rgba(225,112,85,0.15)',
            color: saveStatus.type === 'ok' ? 'var(--green)' : 'var(--red)',
          }}>{saveStatus.msg}</span>
        )}
      </div>

      {selectedIds.size > 0 && (
        <div className="bulk-bar">
          <span className="bulk-count">{selectedIds.size} selected</span>
          <div className="bulk-sep" />
          <button className="btn-sm danger" onClick={bulkDelete}>
            Delete selected
          </button>
          <div className="bulk-sep" />
          <div className="bulk-edit-group">
            <span style={{fontSize:11, color:'var(--text2)'}}>Set</span>
            <select value={bulkField} onChange={e => { setBulkField(e.target.value); setBulkValue(''); }}>
              {BULK_FIELD_OPTIONS.map(o => <option key={o.key} value={o.key}>{o.label}</option>)}
            </select>
            <span style={{fontSize:11, color:'var(--text2)'}}>to</span>
            {sizeFields.has(bulkField) ? (
              <select value={bulkValue} onChange={e => setBulkValue(e.target.value)}>
                <option value="">â€” select â€”</option>
                {(bulkField === 'impact' ? VALID_IMPACTS : VALID_SIZES.filter(Boolean)).map(v =>
                  <option key={v} value={v}>{v}</option>
                )}
              </select>
            ) : (
              <input type="text" value={bulkValue} onChange={e => setBulkValue(e.target.value)}
                placeholder="value..." style={{width:120}} />
            )}
            <button className="btn-sm apply" onClick={bulkEdit} disabled={!bulkValue}>
              Apply
            </button>
          </div>
        </div>
      )}

      <table className="projects-table">
        <thead>
          <tr>
            <th className="check-col">
              <input type="checkbox" className="row-checkbox"
                checked={currentData.length > 0 && selectedIds.size === currentData.length}
                onChange={toggleSelectAll} />
            </th>
            <th style={{width:'3%'}}>#</th>
            {TABLE_COLS.map(c => <th key={c.key} style={{width:c.width}}>{c.label}</th>)}
            <th style={{width:'5%'}}></th>
          </tr>
        </thead>
        <tbody>
          {currentData.map((p, i) => (
            <tr key={p.id} className={`${editingCell?.id === p.id ? 'editing-row' : ''} ${selectedIds.has(p.id) ? 'editing-row' : ''}`}>
              <td className="check-col">
                <input type="checkbox" className="row-checkbox"
                  checked={selectedIds.has(p.id)}
                  onChange={() => toggleSelect(p.id)} />
              </td>
              <td style={{color:'var(--text2)', fontSize:10}}>{i+1}</td>
              {TABLE_COLS.map(c => <td key={c.key}>{renderEditableCell(p, c.key)}</td>)}
              <td>
                <button className="btn-icon danger" onClick={() => deleteProject(p.id)} title="Delete project">
                  Ã—
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      {currentData.length === 0 && (
        <div style={{textAlign:'center', padding:'60px 40px', color:'var(--text2)'}}>
          <p style={{fontSize:16, marginBottom:12}}>No projects yet</p>
          <p style={{fontSize:13}}>Click <strong>"+ Add Project"</strong> to create your first project.</p>
        </div>
      )}
    </div>
  );

  const renderTooltip = () => {
    if (!tooltip) return null;
    const { p, x, y } = tooltip;
    const s = projectSprints(p);
    const eff = effectiveSprints(p);
    const hasSplit = splits[p.id] && Object.keys(splits[p.id]).length > 0;
    const efforts = [];
    if (s.backend) efforts.push({ label: 'BE', val: p.backend, sprints: s.backend, effective: eff.backend });
    if (s.frontend) efforts.push({ label: 'FE', val: p.frontend, sprints: s.frontend, effective: eff.frontend });
    if (s.natives) efforts.push({ label: 'Native', val: p.natives, sprints: s.natives, effective: eff.natives });
    if (s.qa) efforts.push({ label: 'QA', val: p.qa, sprints: s.qa, effective: eff.qa });
    // Keep tooltip on screen
    const tx = Math.min(x, window.innerWidth - 340);
    const ty = Math.min(y, window.innerHeight - 200);
    return (
      <div className="tooltip-overlay" style={{ left: tx, top: ty }}>
        <div className="tooltip-card">
          <div className="tt-title">{p.subTask}</div>
          <div className="tt-meta">
            <span className={`pill pill-pillar ${PILLAR_CLASSES[p.pillar]||''}`}>{p.pillar}</span>
            <span className="pill pill-market">{p.targetMarket}</span>
            <span className="pill pill-kpi">{p.targetKPI}</span>
            <span className={`pill pill-impact impact-${p.impact}`}>Impact: {p.impact}</span>
          </div>
          <div className="tt-efforts">
            {efforts.map(e => (
              <span key={e.label} className="effort-tag">
                {e.label}: <span className="val">{e.val}</span> ({e.sprints}sp)
                {hasSplit && e.effective !== e.sprints && <span style={{color:'var(--yellow)',marginLeft:3}}>â†’ {e.effective}sp here</span>}
              </span>
            ))}
          </div>
          <div className="tt-total">Total: {s.total} man-sprints{hasSplit && ` (${eff.total} in home lane)`}</div>
          {hasSplit && (
            <div style={{fontSize:10,color:'var(--yellow)',marginTop:4,borderTop:'1px solid var(--border)',paddingTop:4}}>
              â‘‚ Split: {Object.entries(splits[p.id]).map(([tk, sz]) => {
                const label = TRACKS.find(t => t.key === tk)?.label || tk;
                const total = (sz.backend||0) + (sz.frontend||0) + (sz.natives||0) + (sz.qa||0);
                return `${label} ${total}sp`;
              }).join(', ')}
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <>
      <div className="app-header">
        <h1>
          <span style={{color: activeV.color}}>{activeV.icon}</span>
          {' '}{activeV.label} <span>Capacity Planner</span>
        </h1>
        <div className="header-right">
          <div className="tab-switcher">
            <button className={`tab-btn ${activeTab === 'planner' ? 'active' : ''}`}
              onClick={() => setActiveTab('planner')}>Planner</button>
            <button className={`tab-btn ${activeTab === 'projects' ? 'active' : ''}`}
              onClick={() => setActiveTab('projects')}>Projects</button>
          </div>
          <div className="vertical-selector">
            <label>Vertical</label>
            <select className="vertical-select" value={activeVertical}
              onChange={e => handleVerticalChange(e.target.value)}>
              {VERTICALS.map(v => (
                <option key={v.key} value={v.key}>{v.icon} {v.label}</option>
              ))}
            </select>
          </div>
          {saving && <span style={{fontSize:11, color:'var(--accent2)'}}>Saving...</span>}
          {currentData.length > 0 && activeTab === 'planner' && (
            <span style={{fontSize:12, color:'var(--text2)'}}>
              {roadmapIds.size} in roadmap Â· {currentData.length - roadmapIds.size} in backlog
            </span>
          )}
        </div>
      </div>

      {loading ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon" style={{animation:'pulse-indicator 1s ease-in-out infinite alternate'}}>â³</div>
          <h2>Loading {activeV.label} data...</h2>
        </div>
      ) : activeTab === 'projects' ? (
        projectsTableJSX
      ) : currentData.length === 0 ? (
        <div className="empty-vertical">
          <div className="empty-vertical-icon">{activeV.icon}</div>
          <h2>{activeV.label} Backlog</h2>
          <p>No project data loaded for this vertical yet. Switch to the <strong>Projects</strong> tab above to add projects.</p>
        </div>
      ) : (<>

      <div className="config-bar">
        <div className="section-title">âš™ï¸ Configuration</div>
        <div className="config-section">
          <h3>Team Capacity (man-sprints)</h3>
          <div className="config-inputs">
            {['backend','frontend','natives','qa'].map(k => (
              <div key={k} className="config-field">
                <label>{k.charAt(0).toUpperCase() + k.slice(1)}</label>
                <input type="number" min="0" value={capacity[k]}
                  onChange={e => setCapacity(prev => ({...prev, [k]: parseInt(e.target.value)||0}))} />
              </div>
            ))}
          </div>
        </div>
        <div className="config-section">
          <h3>T-shirt â†’ Sprints</h3>
          <div className="size-mapping">
            {Object.entries(sizeMap).map(([size, val]) => (
              <div key={size} className="size-chip">
                <span>{size}</span>
                <input type="number" min="0" step="0.5" value={val}
                  onChange={e => setSizeMap(prev => ({...prev, [size]: parseFloat(e.target.value)||0}))} />
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="track-alloc-section">
        <h3>ðŸ“Š Capacity Allocation per Swimlane</h3>
        <div className="track-alloc-grid">
          <div className="track-alloc-header"></div>
          {['backend','frontend','natives','qa'].map(d => (
            <div key={d} className="track-alloc-header">{d.charAt(0).toUpperCase()+d.slice(1)}</div>
          ))}
          <div className="track-alloc-header"></div>
          {TRACKS.map(t => {
            const used = trackUsed[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
            const tc = trackCapacity[t.key] || { backend:0, frontend:0, natives:0, qa:0 };
            return (
              <React.Fragment key={t.key}>
                <div className="track-alloc-label" style={{borderLeft:`3px solid ${t.borderColor}`, paddingLeft:8}}>{t.label}</div>
                {['backend','frontend','natives','qa'].map(d => {
                  const pct = tc[d] > 0 ? Math.round(used[d] / tc[d] * 100) : 0;
                  const color = pct > 100 ? '#e17055' : pct > 80 ? '#fdcb6e' : '#00b894';
                  return (
                    <div key={d}>
                      <input type="number" min="0" className={`track-alloc-input${used[d] > tc[d] && tc[d] > 0 ? ' over-cap' : ''}`}
                        value={tc[d]} onChange={e => updateTrackCapacity(t.key, d, parseInt(e.target.value)||0)} />
                      {tc[d] > 0 && <div className="track-cap-bar"><div className="track-cap-fill" style={{width:`${Math.min(pct,100)}%`, background: color}} /></div>}
                    </div>
                  );
                })}
                <div style={{fontSize:10,color:'var(--muted)'}}>
                  {Object.values(used).reduce((a,b)=>a+b,0)}/{Object.values(tc).reduce((a,b)=>a+b,0)}
                </div>
              </React.Fragment>
            );
          })}
          <div className="track-alloc-label" style={{fontWeight:700}}>Remaining</div>
          {['backend','frontend','natives','qa'].map(d => (
            <div key={d} className={`track-alloc-remaining ${unallocated[d] < 0 ? 'over' : unallocated[d] === 0 ? 'warn' : 'ok'}`}>
              {unallocated[d]}
            </div>
          ))}
          <div></div>
        </div>
      </div>

      <div className="capacity-overview">
        <div className="section-title">ðŸ“ˆ Roadmap Capacity Usage</div>
        {renderCapBar('Backend', bufferedUsed.backend, capacity.backend)}
        {renderCapBar('Frontend', bufferedUsed.frontend, capacity.frontend)}
        {renderCapBar('Natives', bufferedUsed.natives, capacity.natives)}
        {renderCapBar('QA', bufferedUsed.qa, capacity.qa)}
        <div className="cap-total">
          {renderCapBar('Total Capacity', totalUsed, totalCapacity)}
        </div>
      </div>

      <div className="demand-section">
        <div className="section-title">ðŸŽ¯ Total Demand & Buffer</div>
        {['backend', 'frontend', 'natives', 'qa'].map(k => (
          <div key={k} className="demand-card">
            <div className="demand-card-title">{k.charAt(0).toUpperCase() + k.slice(1)} Total Demand</div>
            <div className="demand-card-value">{totalDemand[k]} <span style={{fontSize:11,color:'var(--muted)',fontWeight:400}}>sprints</span></div>
            <div className="demand-buffer-row">
              <button className="demand-buffer-btn" onClick={() => setBuffer(prev => ({...prev, [k]: prev[k] - 5}))}>âˆ’</button>
              <span className="demand-buffer-pct">{buffer[k] >= 0 ? '+' : ''}{buffer[k]}%</span>
              <button className="demand-buffer-btn" onClick={() => setBuffer(prev => ({...prev, [k]: prev[k] + 5}))}>+</button>
            </div>
            {buffer[k] !== 0 && (
              <div className="demand-card-buffered">With buffer: {bufferedDemand[k]} sprints</div>
            )}
          </div>
        ))}
      </div>

      <div className="filters-bar">
        <input className="search-input" placeholder="Search projects..." value={search} onChange={e => setSearch(e.target.value)} />
        <FilterDropdown filterKey="pillar" label="Pillar" />
        <FilterDropdown filterKey="epic" label="Epic" />
        <FilterDropdown filterKey="market" label="Market" />
        <FilterDropdown filterKey="kpi" label="KPI" />
        <FilterDropdown filterKey="impact" label="Impact" />
        {activeFilterCount > 0 && (
          <button className="btn" onClick={() => setFilters({pillar:[],market:[],epic:[],kpi:[],impact:[]})}>
            Clear ({activeFilterCount})
          </button>
        )}
        <div style={{marginLeft:'auto'}} className="sort-controls">
          <span style={{fontSize:10,color:'var(--text2)'}}>Sort:</span>
          <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
            <option value="impact">Impact â†“</option>
            <option value="effort">Effort â†“</option>
            <option value="epic">Epic</option>
            <option value="pillar">Pillar</option>
            <option value="name">Name</option>
          </select>
        </div>
        <div className="color-legend">
          {Object.entries(PILLAR_COLORS).map(([name, color]) => (
            <div key={name} className="legend-item">
              <div className="legend-dot" style={{background: color}}></div>
              {name}
            </div>
          ))}
        </div>
      </div>

      <div className="main-scroll">
        {/* Roadmap Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              âœ… In Roadmap
              <span className="badge roadmap-badge">{roadmapProjects.length}</span>
              <span style={{fontSize:11,color:'var(--text2)',fontWeight:400,marginLeft:8}}>
                {roadmapTotalSprints} total sprints
              </span>
            </h2>
            <div className="lane-stats">
              {['backend','frontend','natives','qa'].map(k => (
                <span key={k} className="stat-chip">
                  {k.charAt(0).toUpperCase()+k.slice(1)}: <strong>{bufferedUsed[k]}</strong>/{capacity[k]}
                </span>
              ))}
              <button className="btn-timeline" onClick={() => setShowTimeline(true)}>ðŸ“Š Timeline</button>
            </div>
          </div>
          <div className="track-group">
            {TRACKS.map((track, i) => (
              <React.Fragment key={track.key}>
                {i > 0 && <div className="track-divider" />}
                <div className="track-row">
                  <div className="track-label" style={{background: track.gradient}}>
                    {track.label}
                    {(() => {
                      const tc = trackCapacity[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                      const tu = trackUsed[track.key] || {backend:0,frontend:0,natives:0,qa:0};
                      const totalAlloc = Object.values(tc).reduce((a,b)=>a+b,0);
                      const totalUsedTrack = Object.values(tu).reduce((a,b)=>a+b,0);
                      return totalAlloc > 0 ? (
                        <span style={{fontSize:9,opacity:0.9,display:'block',marginTop:2}}>
                          {totalUsedTrack}/{totalAlloc}
                        </span>
                      ) : null;
                    })()}
                  </div>
                  <div className="track-flow"
                    onDragOver={handleDragOver} onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                    onDrop={(e) => handleDropOnTrack(e, track.key)}
                    style={{borderColor: track.borderColor}}>
                    {(trackProjects[track.key] || []).length === 0 && (ghostsByTrack[track.key] || []).length === 0 && <div className="track-empty">Drag projects here</div>}
                    {(trackProjects[track.key] || []).map((p, idx) => renderBlock(p, 'roadmap', track.key, idx))}
                    {(ghostsByTrack[track.key] || []).map(g => renderGhostBlock(g.project, g.sizing, track.key, g.homeTrack))}
                  </div>
                </div>
              </React.Fragment>
            ))}
          </div>
        </div>

        {/* Backlog Lane */}
        <div className="lane-section">
          <div className="lane-header-row">
            <h2>
              ðŸ“‹ Backlog
              <span className="badge backlog-badge">{backlogProjects.length}</span>
            </h2>
            <div style={{display:'flex',gap:6}}>
              <button className="btn btn-primary" onClick={() => {
                const sorted = [...currentData].sort((a,b) => (impactOrder[b.impact]||0) - (impactOrder[a.impact]||0));
                let used = {backend:0,frontend:0,natives:0,qa:0};
                const newTracks = {};
                for (const t of TRACKS) newTracks[t.key] = [];
                for (const p of sorted) {
                  const s = projectSprints(p);
                  if (used.backend+s.backend <= capacity.backend && used.frontend+s.frontend <= capacity.frontend && used.natives+s.natives <= capacity.natives && used.qa+s.qa <= capacity.qa) {
                    newTracks['core-bonus'].push(p.id); used.backend += s.backend; used.frontend += s.frontend; used.natives += s.natives; used.qa += s.qa;
                  }
                }
                setTracks(newTracks);
              }}>Auto-fill by Impact</button>
              <button className="btn" onClick={() => {
                const empty = {};
                for (const t of TRACKS) empty[t.key] = [];
                setTracks(empty);
              }}>Clear All</button>
            </div>
          </div>
          <div className="flow-container"
            onDragOver={handleDragOver} onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave} onDrop={handleDropOnBacklog}>
            {backlogProjects.length === 0 && <div className="empty-flow">All projects are in the roadmap</div>}
            {backlogProjects.map(p => renderBlock(p, 'backlog'))}
          </div>
        </div>
      </div>

      {renderTooltip()}
      </>)}

      {showTimeline && (
        <div className="timeline-overlay" onClick={() => setShowTimeline(false)}>
          <div className="timeline-modal" onClick={e => e.stopPropagation()}>
            <div className="tl-header">
              <h2>ðŸ“Š Timeline</h2>
              <div className="tl-controls">
                <div className="tl-ctrl-group">
                  <label>Start:</label>
                  <input type="date" value={timelineConfig.sprintStartDate}
                    onChange={e => updateTimelineConfig({ sprintStartDate: e.target.value })} />
                </div>
                <div className="tl-ctrl-group">
                  <label>Sprint:</label>
                  <select value={timelineConfig.sprintDurationWeeks}
                    onChange={e => updateTimelineConfig({ sprintDurationWeeks: parseInt(e.target.value) })}>
                    <option value={1}>1 wk</option>
                    <option value={2}>2 wk</option>
                    <option value={3}>3 wk</option>
                    <option value={4}>4 wk</option>
                  </select>
                </div>
                <div className="tl-ctrl-group">
                  <label>Scale:</label>
                  <select value={timelineConfig.timeScale}
                    onChange={e => updateTimelineConfig({ timeScale: e.target.value })}>
                    <option value="weeks">Weeks</option>
                    <option value="months">Months</option>
                    <option value="quarters">Quarters</option>
                  </select>
                </div>
              </div>
              <button className="tl-close" onClick={() => setShowTimeline(false)} title="Close">âœ•</button>
            </div>
            <div className="tl-body">
              {/* Milestones sidebar */}
              <div className="tl-sidebar">
                <div className="tl-sidebar-header">
                  <span>Milestones</span>
                  <button className="tl-btn" onClick={() => {
                    const name = prompt('Milestone name:');
                    if (name) {
                      const date = prompt('Date (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
                      if (date) addMilestone(name, date);
                    }
                  }}>+ Add</button>
                </div>
                <div className="tl-sidebar-content">
                  {milestones.length === 0 && <div className="tl-ms-empty">No milestones yet. Click "+ Add" to create one.</div>}
                  {milestones.map(m => (
                    <div key={m.id} className="tl-ms-item">
                      <div className="tl-ms-dot" style={{background: m.color}} />
                      <div style={{flex:1,minWidth:0}}>
                        <div className="tl-ms-name">{m.name}</div>
                        <div className="tl-ms-date">{m.date}</div>
                      </div>
                      <div className="tl-ms-actions">
                        <button className="tl-ms-btn" onClick={() => {
                          const name = prompt('Milestone name:', m.name);
                          if (name !== null) updateMilestone(m.id, { name });
                        }}>âœŽ</button>
                        <button className="tl-ms-btn" onClick={() => {
                          const date = prompt('Date (YYYY-MM-DD):', m.date);
                          if (date !== null) updateMilestone(m.id, { date });
                        }}>ðŸ“…</button>
                        <button className="tl-ms-btn del" onClick={() => {
                          if (confirm('Remove this milestone?')) removeMilestone(m.id);
                        }}>âœ•</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              {/* Timeline grid */}
              <div className="tl-grid-wrapper">
                <div className="tl-grid" style={{width: timelineData.totalPx}}>
                  {/* Ruler */}
                  <div className="tl-ruler">
                    <div className="tl-ruler-label">Swimlane</div>
                    <div className="tl-ruler-bar">
                      {timelineData.marks.map((m, i) => (
                        <div key={i} className="tl-ruler-mark" style={{width: m.width}}>{m.label}</div>
                      ))}
                      {/* Milestone flags in ruler */}
                      {timelineData.msPositions.map(m => (
                        <div key={m.id} className="tl-milestone-flag"
                          style={{left: m.px, background: m.color}}>
                          {m.name}
                        </div>
                      ))}
                    </div>
                  </div>
                  {/* Track rows */}
                  {TRACKS.map(track => {
                    const laneCount = trackSubLaneCounts[track.key] || 1;
                    const trackHeight = Math.max(80, laneCount * 66 + 14);
                    return (
                    <div key={track.key} className="tl-track" style={{minHeight: trackHeight}}>
                      <div className="tl-track-label" style={{background: track.gradient}}>
                        <span>{track.label}</span>
                        <div className="sub-lane-controls">
                          <button className="sub-lane-btn" onClick={() => addSubLane(track.key)} title="Add parallel lane">+</button>
                          {laneCount > 1 && <button className="sub-lane-btn" onClick={() => removeSubLane(track.key)} title="Remove last lane">âˆ’</button>}
                          {laneCount > 1 && <span style={{fontSize:'9px',color:'rgba(255,255,255,0.6)'}}>{laneCount}</span>}
                        </div>
                      </div>
                      <div className="tl-track-bars" style={{width: timelineData.totalPx - 110, minHeight: trackHeight - 8}}>
                        {/* Sub-lane separator lines */}
                        {Array.from({length: laneCount - 1}, (_, i) => (
                          <div key={`sep-${i}`} className="tl-sublane-separator" style={{top: (i + 1) * 66}} />
                        ))}
                        {(timelineData.trackBars[track.key] || []).map((bar, i) => {
                          const d = bar.disciplines || {};
                          const dB = d.backend||0;
                          const dF = d.frontend||0;
                          const dN = d.natives||0;
                          const dQ = d.qa||0;
                          return (
                          <div key={bar.ghost ? `g-${bar.project.id}` : bar.project.id}
                            className={`tl-bar ${bar.ghost ? 'ghost' : ''} ${bar.project.inProgress ? 'in-progress' : ''} ${bar.hasOverride ? 'has-override' : ''}`}
                            style={{left: bar.left, width: bar.width, top: bar.laneIndex * 66 + 6, background: getBlockBg(bar.project.pillar)}}
                            onMouseEnter={(e) => handleMouseEnter(e, bar.project)}
                            onMouseLeave={handleMouseLeave}
                            onMouseDown={e => { if (!e.target.classList.contains('tl-bar-handle')) handleBarDragStart(e, bar, 'move'); }}
                            onDoubleClick={() => {
                              if (bar.hasOverride && confirm('Reset this bar to auto-layout?')) {
                                clearTimelineOverride(bar.project.id, bar.trackKey);
                              }
                            }}
                            title={`${bar.project.subTask}${bar.hasOverride ? ' (double-click to reset)' : ''}${bar.ghost ? ' (split from ' + (TRACKS.find(t=>t.key===bar.homeTrack)?.label||'') + ')' : ''}`}>
                            <div className="tl-bar-handle left"
                              onMouseDown={e => handleBarDragStart(e, bar, 'left')} />
                            <div className="tl-bar-row1">
                              <span className="tl-bar-label">{bar.project.subTask}</span>
                            </div>
                            <div className="tl-bar-row2">
                              {bar.project.nvrd && <span className="tl-bar-jira">{bar.project.nvrd}</span>}
                              <div className="tl-bar-disciplines">
                                {dB > 0 && <span>B:{dB}</span>}
                                {dF > 0 && <span>F:{dF}</span>}
                                {dN > 0 && <span>N:{dN}</span>}
                                {dQ > 0 && <span>Q:{dQ}</span>}
                              </div>
                            </div>
                            <div className="tl-bar-handle right"
                              onMouseDown={e => handleBarDragStart(e, bar, 'right')} />
                          </div>
                          );
                        })}
                        {/* Milestone lines in each track */}
                        {timelineData.msPositions.map(m => (
                          <div key={m.id} className="tl-milestone-line"
                            style={{left: m.px, background: m.color}} />
                        ))}
                      </div>
                    </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {splitModal && (() => {
        const { projectId, projectName, homeTrack } = splitModal;
        const proj = projectById[projectId];
        const fullSprints = proj ? projectSprints(proj) : { backend:0,frontend:0,natives:0,qa:0,total:0 };
        const existingSplits = splits[projectId] || {};
        const otherTracks = TRACKS.filter(t => t.key !== homeTrack);
        const [targetTrack, setTargetTrack] = [
          splitModal._targetTrack || otherTracks[0]?.key,
          (v) => setSplitModal(prev => ({ ...prev, _targetTrack: v }))
        ];
        const [splitSizing, setSplitSizing] = [
          splitModal._sizing || existingSplits[targetTrack] || { backend: 0, frontend: 0, natives: 0, qa: 0 },
          (v) => setSplitModal(prev => ({ ...prev, _sizing: typeof v === 'function' ? v(prev._sizing || existingSplits[prev._targetTrack || otherTracks[0]?.key] || { backend:0,frontend:0,natives:0,qa:0 }) : v }))
        ];
        // Calculate total split-out per discipline (existing + current form)
        const allSplitOut = { backend:0, frontend:0, natives:0, qa:0 };
        for (const [tk, sz] of Object.entries(existingSplits)) {
          if (tk === targetTrack) continue; // current form replaces this track's split
          allSplitOut.backend += (sz.backend||0);
          allSplitOut.frontend += (sz.frontend||0);
          allSplitOut.natives += (sz.natives||0);
          allSplitOut.qa += (sz.qa||0);
        }
        // Add current form values
        const totalOut = {
          backend: allSplitOut.backend + (splitSizing.backend||0),
          frontend: allSplitOut.frontend + (splitSizing.frontend||0),
          natives: allSplitOut.natives + (splitSizing.natives||0),
          qa: allSplitOut.qa + (splitSizing.qa||0),
        };
        const remaining = {
          backend: fullSprints.backend - totalOut.backend,
          frontend: fullSprints.frontend - totalOut.frontend,
          natives: fullSprints.natives - totalOut.natives,
          qa: fullSprints.qa - totalOut.qa,
        };
        const hasOverSplit = remaining.backend < 0 || remaining.frontend < 0 || remaining.natives < 0 || remaining.qa < 0;
        const homeLabel = TRACKS.find(t => t.key === homeTrack)?.label || homeTrack;
        return (
          <div className="split-modal-overlay" onClick={() => setSplitModal(null)}>
            <div className="split-modal" onClick={e => e.stopPropagation()}>
              <h3>Split: {projectName}</h3>
              <div style={{fontSize:11,color:'var(--text2)',marginBottom:8}}>
                Full sizing: B{fullSprints.backend} F{fullSprints.frontend} N{fullSprints.natives} Q{fullSprints.qa} = {fullSprints.total}sp
              </div>
              {Object.keys(existingSplits).length > 0 && (
                <div className="split-existing">
                  <div style={{fontSize:10,color:'var(--text2)',marginBottom:4,fontWeight:600}}>EXISTING SPLITS</div>
                  {Object.entries(existingSplits).map(([tk, sz]) => {
                    const tLabel = TRACKS.find(t => t.key === tk)?.label || tk;
                    const total = (sz.backend||0) + (sz.frontend||0) + (sz.natives||0) + (sz.qa||0);
                    return (
                      <div key={tk} className="split-existing-item">
                        <span>{tLabel}: B{sz.backend||0} F{sz.frontend||0} N{sz.natives||0} Q{sz.qa||0} = {total}sp</span>
                        <button className="btn-sm" style={{fontSize:10,padding:'2px 6px',background:'var(--red)',color:'white',border:'none',borderRadius:3,cursor:'pointer'}}
                          onClick={() => { removeSplit(projectId, tk); setSplitModal(prev => ({...prev})); }}>Remove</button>
                      </div>
                    );
                  })}
                </div>
              )}
              <div className="split-modal-fields">
                <div className="split-field-row">
                  <label>Target Lane</label>
                  <select value={targetTrack} onChange={e => {
                    const newTrack = e.target.value;
                    setSplitModal(prev => ({ ...prev, _targetTrack: newTrack, _sizing: existingSplits[newTrack] || { backend:0, frontend:0, natives:0, qa:0 } }));
                  }}>
                    {otherTracks.map(t => <option key={t.key} value={t.key}>{t.label}</option>)}
                  </select>
                </div>
                {['backend','frontend','natives','qa'].map(d => {
                  const max = fullSprints[d] - allSplitOut[d];
                  const isOver = (splitSizing[d]||0) > max;
                  return (
                    <div key={d} className="split-field-row">
                      <label>{d.charAt(0).toUpperCase()+d.slice(1)}</label>
                      <input type="number" min="0" max={max} step="0.5" value={splitSizing[d] || 0}
                        style={isOver ? {borderColor:'var(--red)',color:'var(--red)'} : {}}
                        onChange={e => setSplitSizing(prev => ({...prev, [d]: parseFloat(e.target.value)||0}))} />
                      <span style={{fontSize:10,color: isOver ? 'var(--red)' : 'var(--text2)'}}> / {max}sp max</span>
                    </div>
                  );
                })}
              </div>
              <div style={{fontSize:11,margin:'8px 0',padding:'6px 8px',borderRadius:6,background: hasOverSplit ? 'rgba(225,112,85,0.15)' : 'rgba(0,184,148,0.1)',border: `1px solid ${hasOverSplit ? 'var(--red)' : 'var(--green)'}`}}>
                Remaining in <strong>{homeLabel}</strong>: B{remaining.backend} F{remaining.frontend} N{remaining.natives} Q{remaining.qa}
                {hasOverSplit && <span style={{color:'var(--red)',fontWeight:600}}> â€” over-split!</span>}
              </div>
              <div className="split-modal-actions">
                <button className="btn-cancel" onClick={() => setSplitModal(null)}>Cancel</button>
                <button className="btn-save" onClick={() => {
                  const finalTarget = splitModal._targetTrack || otherTracks[0]?.key;
                  const finalSizing = splitModal._sizing || existingSplits[finalTarget] || { backend:0,frontend:0,natives:0,qa:0 };
                  saveSplit(projectId, finalTarget, finalSizing);
                  setSplitModal(null);
                }}>Save Split</button>
              </div>
            </div>
          </div>
        );
      })()}
    </>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
